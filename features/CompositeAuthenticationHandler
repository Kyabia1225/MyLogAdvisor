[ {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "setEnableStartTls",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void setEnableStartTls(Boolean enableStartTls)\n{\r\n    this.enableStartTls = enableStartTls;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "setDisableHostNameVerification",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void setDisableHostNameVerification(Boolean disableHostNameVerification)\n{\r\n    this.disableHostNameVerification = disableHostNameVerification;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getType",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getType()\n{\r\n    return TYPE;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "init",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void init(Properties config) throws ServletException\n{\r\n    this.baseDN = config.getProperty(BASE_DN);\r\n    this.providerUrl = config.getProperty(PROVIDER_URL);\r\n    this.ldapDomain = config.getProperty(LDAP_BIND_DOMAIN);\r\n    this.enableStartTls = Boolean.valueOf(config.getProperty(ENABLE_START_TLS, \"false\"));\r\n    if (this.providerUrl == null) {\r\n        throw new NullPointerException(\"The LDAP URI can not be null\");\r\n    }\r\n    if (!((this.baseDN == null) ^ (this.ldapDomain == null))) {\r\n        throw new IllegalArgumentException(\"Either LDAP base DN or LDAP domain value needs to be specified\");\r\n    }\r\n    if (this.enableStartTls) {\r\n        String tmp = this.providerUrl.toLowerCase();\r\n        if (tmp.startsWith(\"ldaps\")) {\r\n            throw new IllegalArgumentException(\"Can not use ldaps and StartTLS option at the same time\");\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "destroy",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void destroy()\n{\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "managementOperation",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean managementOperation(AuthenticationToken token, HttpServletRequest request, HttpServletResponse response) throws IOException, AuthenticationException\n{\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "authenticate",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "AuthenticationToken authenticate(HttpServletRequest request, HttpServletResponse response) throws IOException, AuthenticationException\n{\r\n    AuthenticationToken token = null;\r\n    String authorization = request.getHeader(HttpConstants.AUTHORIZATION_HEADER);\r\n    if (authorization == null || !AuthenticationHandlerUtil.matchAuthScheme(HttpConstants.BASIC, authorization)) {\r\n        response.setHeader(WWW_AUTHENTICATE, HttpConstants.BASIC);\r\n        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\r\n        if (authorization == null) {\r\n            logger.trace(\"Basic auth starting\");\r\n        } else {\r\n            logger.warn(\"'\" + HttpConstants.AUTHORIZATION_HEADER + \"' does not start with '\" + HttpConstants.BASIC + \"' :  {}\", authorization);\r\n        }\r\n    } else {\r\n        authorization = authorization.substring(HttpConstants.BASIC.length()).trim();\r\n        final Base64 base64 = new Base64(0);\r\n        String[] credentials = new String(base64.decode(authorization), StandardCharsets.UTF_8).split(\":\", 2);\r\n        if (credentials.length == 2) {\r\n            token = authenticateUser(credentials[0], credentials[1]);\r\n            response.setStatus(HttpServletResponse.SC_OK);\r\n        }\r\n    }\r\n    return token;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "authenticateUser",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "AuthenticationToken authenticateUser(String userName, String password) throws AuthenticationException\n{\r\n    if (userName == null || userName.isEmpty()) {\r\n        throw new AuthenticationException(\"Error validating LDAP user:\" + \" a null or blank username has been provided\");\r\n    }\r\n    if (!hasDomain(userName) && ldapDomain != null) {\r\n        userName = userName + \"@\" + ldapDomain;\r\n    }\r\n    if (password == null || password.isEmpty() || password.getBytes(StandardCharsets.UTF_8)[0] == 0) {\r\n        throw new AuthenticationException(\"Error validating LDAP user:\" + \" a null or blank password has been provided\");\r\n    }\r\n    String bindDN;\r\n    if (baseDN == null) {\r\n        bindDN = userName;\r\n    } else {\r\n        bindDN = \"uid=\" + userName + \",\" + baseDN;\r\n    }\r\n    if (this.enableStartTls) {\r\n        authenticateWithTlsExtension(bindDN, password);\r\n    } else {\r\n        authenticateWithoutTlsExtension(bindDN, password);\r\n    }\r\n    return new AuthenticationToken(userName, userName, TYPE);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "authenticateWithTlsExtension",
  "errType" : [ "NamingException|IOException", "NamingException" ],
  "containingMethodsNum" : 11,
  "sourceCodeText" : "void authenticateWithTlsExtension(String userDN, String password) throws AuthenticationException\n{\r\n    LdapContext ctx = null;\r\n    Hashtable<String, Object> env = new Hashtable<String, Object>();\r\n    env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\r\n    env.put(Context.PROVIDER_URL, providerUrl);\r\n    try {\r\n        ctx = new InitialLdapContext(env, null);\r\n        StartTlsResponse tls = (StartTlsResponse) ctx.extendedOperation(new StartTlsRequest());\r\n        if (disableHostNameVerification) {\r\n            tls.setHostnameVerifier(new HostnameVerifier() {\r\n\r\n                @Override\r\n                public boolean verify(String hostname, SSLSession session) {\r\n                    return true;\r\n                }\r\n            });\r\n        }\r\n        tls.negotiate();\r\n        ctx.addToEnvironment(Context.SECURITY_AUTHENTICATION, SECURITY_AUTHENTICATION);\r\n        ctx.addToEnvironment(Context.SECURITY_PRINCIPAL, userDN);\r\n        ctx.addToEnvironment(Context.SECURITY_CREDENTIALS, password);\r\n        ctx.lookup(userDN);\r\n        logger.debug(\"Authentication successful for {}\", userDN);\r\n    } catch (NamingException | IOException ex) {\r\n        throw new AuthenticationException(\"Error validating LDAP user\", ex);\r\n    } finally {\r\n        if (ctx != null) {\r\n            try {\r\n                ctx.close();\r\n            } catch (NamingException e) {\r\n            }\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "authenticateWithoutTlsExtension",
  "errType" : [ "NamingException" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void authenticateWithoutTlsExtension(String userDN, String password) throws AuthenticationException\n{\r\n    Hashtable<String, Object> env = new Hashtable<String, Object>();\r\n    env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\r\n    env.put(Context.PROVIDER_URL, providerUrl);\r\n    env.put(Context.SECURITY_AUTHENTICATION, SECURITY_AUTHENTICATION);\r\n    env.put(Context.SECURITY_PRINCIPAL, userDN);\r\n    env.put(Context.SECURITY_CREDENTIALS, password);\r\n    try {\r\n        Context ctx = new InitialDirContext(env);\r\n        ctx.close();\r\n        logger.debug(\"Authentication successful for {}\", userDN);\r\n    } catch (NamingException e) {\r\n        throw new AuthenticationException(\"Error validating LDAP user\", e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "hasDomain",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean hasDomain(String userName)\n{\r\n    return (indexOfDomainMatch(userName) > 0);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "indexOfDomainMatch",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "int indexOfDomainMatch(String userName)\n{\r\n    if (userName == null) {\r\n        return -1;\r\n    }\r\n    int idx = userName.indexOf('/');\r\n    int idx2 = userName.indexOf('@');\r\n    int endIdx = Math.min(idx, idx2);\r\n    if (endIdx == -1) {\r\n        endIdx = Math.max(idx, idx2);\r\n    }\r\n    return endIdx;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getType",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getType()\n{\r\n    return TYPE;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "init",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void init(Properties config) throws ServletException\n{\r\n    super.init(config);\r\n    nonBrowserUserAgents = config.getProperty(NON_BROWSER_USER_AGENTS, NON_BROWSER_USER_AGENTS_DEFAULT).split(\"\\\\W*,\\\\W*\");\r\n    for (int i = 0; i < nonBrowserUserAgents.length; i++) {\r\n        nonBrowserUserAgents[i] = nonBrowserUserAgents[i].toLowerCase(Locale.ENGLISH);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "authenticate",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "AuthenticationToken authenticate(HttpServletRequest request, HttpServletResponse response) throws IOException, AuthenticationException\n{\r\n    AuthenticationToken token;\r\n    if (isBrowser(request.getHeader(\"User-Agent\"))) {\r\n        token = alternateAuthenticate(request, response);\r\n    } else {\r\n        token = super.authenticate(request, response);\r\n    }\r\n    return token;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "isBrowser",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "boolean isBrowser(String userAgent)\n{\r\n    if (userAgent == null) {\r\n        return false;\r\n    }\r\n    userAgent = userAgent.toLowerCase(Locale.ENGLISH);\r\n    boolean isBrowser = true;\r\n    for (String nonBrowserUserAgent : nonBrowserUserAgents) {\r\n        if (userAgent.contains(nonBrowserUserAgent)) {\r\n            isBrowser = false;\r\n            break;\r\n        }\r\n    }\r\n    return isBrowser;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "alternateAuthenticate",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "AuthenticationToken alternateAuthenticate(HttpServletRequest request, HttpServletResponse response) throws IOException, AuthenticationException",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "init",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void init(Properties config, ServletContext servletContext, long tokenValidity) throws Exception\n{\r\n    String signatureSecretFile = config.getProperty(AuthenticationFilter.SIGNATURE_SECRET_FILE, null);\r\n    if (signatureSecretFile != null) {\r\n        try (Reader reader = new InputStreamReader(Files.newInputStream(Paths.get(signatureSecretFile)), StandardCharsets.UTF_8)) {\r\n            StringBuilder sb = new StringBuilder();\r\n            int c = reader.read();\r\n            while (c > -1) {\r\n                sb.append((char) c);\r\n                c = reader.read();\r\n            }\r\n            secret = sb.toString().getBytes(StandardCharsets.UTF_8);\r\n            if (secret.length == 0) {\r\n                throw new RuntimeException(\"No secret in signature secret file: \" + signatureSecretFile);\r\n            }\r\n        } catch (IOException ex) {\r\n            throw new RuntimeException(\"Could not read signature secret file: \" + signatureSecretFile);\r\n        }\r\n    }\r\n    secrets = new byte[][] { secret };\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getCurrentSecret",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "byte[] getCurrentSecret()\n{\r\n    return secret;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getAllSecrets",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "byte[][] getAllSecrets()\n{\r\n    return secrets;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\util",
  "methodName" : "main",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void main(String[] args)\n{\r\n    System.out.println(PLATFORM_NAME);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "resetDefaultRealm",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void resetDefaultRealm()\n{\r\n    try {\r\n        defaultRealm = KerberosUtil.getDefaultRealm();\r\n    } catch (Exception ke) {\r\n        LOG.debug(\"resetting default realm failed, \" + \"current default realm will still be used.\", ke);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getDefaultRealm",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String getDefaultRealm()\n{\r\n    if (defaultRealm == null) {\r\n        try {\r\n            defaultRealm = KerberosUtil.getDefaultRealm();\r\n        } catch (Exception ke) {\r\n            LOG.debug(\"Kerberos krb5 configuration not found, setting default realm to empty\");\r\n            defaultRealm = \"\";\r\n        }\r\n    }\r\n    return defaultRealm;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "toString",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "String toString()\n{\r\n    StringBuilder result = new StringBuilder();\r\n    result.append(serviceName);\r\n    if (hostName != null) {\r\n        result.append('/');\r\n        result.append(hostName);\r\n    }\r\n    if (realm != null) {\r\n        result.append('@');\r\n        result.append(realm);\r\n    }\r\n    return result.toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getServiceName",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getServiceName()\n{\r\n    return serviceName;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getHostName",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getHostName()\n{\r\n    return hostName;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getRealm",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getRealm()\n{\r\n    return realm;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "parseRules",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "List<Rule> parseRules(String rules)\n{\r\n    List<Rule> result = new ArrayList<Rule>();\r\n    String remaining = rules.trim();\r\n    while (remaining.length() > 0) {\r\n        Matcher matcher = ruleParser.matcher(remaining);\r\n        if (!matcher.lookingAt()) {\r\n            throw new IllegalArgumentException(\"Invalid rule: \" + remaining);\r\n        }\r\n        if (matcher.group(2) != null) {\r\n            result.add(new Rule());\r\n        } else {\r\n            result.add(new Rule(Integer.parseInt(matcher.group(4)), matcher.group(5), matcher.group(7), matcher.group(9), matcher.group(10), \"g\".equals(matcher.group(11)), \"L\".equals(matcher.group(12))));\r\n        }\r\n        remaining = remaining.substring(matcher.end());\r\n    }\r\n    return result;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getShortName",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "String getShortName() throws IOException\n{\r\n    String[] params;\r\n    if (hostName == null) {\r\n        if (realm == null) {\r\n            return serviceName;\r\n        }\r\n        params = new String[] { realm, serviceName };\r\n    } else {\r\n        params = new String[] { realm, serviceName, hostName };\r\n    }\r\n    String ruleMechanism = this.ruleMechanism;\r\n    if (ruleMechanism == null && rules != null) {\r\n        LOG.warn(\"auth_to_local rule mechanism not set.\" + \"Using default of \" + DEFAULT_MECHANISM);\r\n        ruleMechanism = DEFAULT_MECHANISM;\r\n    }\r\n    for (Rule r : rules) {\r\n        String result = r.apply(params, ruleMechanism);\r\n        if (result != null) {\r\n            return result;\r\n        }\r\n    }\r\n    if (ruleMechanism.equalsIgnoreCase(MECHANISM_HADOOP)) {\r\n        throw new NoMatchingRule(\"No rules applied to \" + toString());\r\n    }\r\n    return toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getRules",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String getRules()\n{\r\n    String ruleString = null;\r\n    if (rules != null) {\r\n        StringBuilder sb = new StringBuilder();\r\n        for (Rule rule : rules) {\r\n            sb.append(rule.toString()).append(\"\\n\");\r\n        }\r\n        ruleString = sb.toString().trim();\r\n    }\r\n    return ruleString;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "hasRulesBeenSet",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean hasRulesBeenSet()\n{\r\n    return rules != null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "hasRuleMechanismBeenSet",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean hasRuleMechanismBeenSet()\n{\r\n    return ruleMechanism != null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "setRules",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void setRules(String ruleString)\n{\r\n    rules = (ruleString != null) ? parseRules(ruleString) : null;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "setRuleMechanism",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void setRuleMechanism(String ruleMech)\n{\r\n    if (ruleMech != null && (!ruleMech.equalsIgnoreCase(MECHANISM_HADOOP) && !ruleMech.equalsIgnoreCase(MECHANISM_MIT))) {\r\n        throw new IllegalArgumentException(\"Invalid rule mechanism: \" + ruleMech);\r\n    }\r\n    ruleMechanism = ruleMech;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getRuleMechanism",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getRuleMechanism()\n{\r\n    return ruleMechanism;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "printRules",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void printRules() throws IOException\n{\r\n    int i = 0;\r\n    for (Rule r : rules) {\r\n        System.out.println(++i + \" \" + r);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "setConnectionConfigurator",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void setConnectionConfigurator(ConnectionConfigurator configurator)\n{\r\n    connConfigurator = configurator;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "authenticate",
  "errType" : [ "IOException", "AuthenticationException" ],
  "containingMethodsNum" : 18,
  "sourceCodeText" : "void authenticate(URL url, AuthenticatedURL.Token token) throws IOException, AuthenticationException\n{\r\n    if (!token.isSet()) {\r\n        this.url = url;\r\n        base64 = new Base64(0);\r\n        HttpURLConnection conn = null;\r\n        try {\r\n            conn = token.openConnection(url, connConfigurator);\r\n            conn.setRequestMethod(AUTH_HTTP_METHOD);\r\n            conn.connect();\r\n            boolean needFallback = false;\r\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\r\n                LOG.debug(\"JDK performed authentication on our behalf.\");\r\n                AuthenticatedURL.extractToken(conn, token);\r\n                if (isTokenKerberos(token)) {\r\n                    return;\r\n                }\r\n                needFallback = true;\r\n            }\r\n            if (!needFallback && isNegotiate(conn)) {\r\n                LOG.debug(\"Performing our own SPNEGO sequence.\");\r\n                doSpnegoSequence(token);\r\n            } else {\r\n                LOG.debug(\"Using fallback authenticator sequence.\");\r\n                Authenticator auth = getFallBackAuthenticator();\r\n                auth.setConnectionConfigurator(connConfigurator);\r\n                auth.authenticate(url, token);\r\n            }\r\n        } catch (IOException ex) {\r\n            throw wrapExceptionWithMessage(ex, \"Error while authenticating with endpoint: \" + url);\r\n        } catch (AuthenticationException ex) {\r\n            throw wrapExceptionWithMessage(ex, \"Error while authenticating with endpoint: \" + url);\r\n        } finally {\r\n            if (conn != null) {\r\n                conn.disconnect();\r\n            }\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "wrapExceptionWithMessage",
  "errType" : [ "Throwable" ],
  "containingMethodsNum" : 5,
  "sourceCodeText" : "T wrapExceptionWithMessage(T exception, String msg)\n{\r\n    Class<? extends Throwable> exceptionClass = exception.getClass();\r\n    try {\r\n        Constructor<? extends Throwable> ctor = exceptionClass.getConstructor(String.class);\r\n        Throwable t = ctor.newInstance(msg);\r\n        return (T) (t.initCause(exception));\r\n    } catch (Throwable e) {\r\n        LOG.debug(\"Unable to wrap exception of type {}, it has \" + \"no (String) constructor.\", exceptionClass, e);\r\n        return exception;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "getFallBackAuthenticator",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Authenticator getFallBackAuthenticator()\n{\r\n    Authenticator auth = new PseudoAuthenticator();\r\n    if (connConfigurator != null) {\r\n        auth.setConnectionConfigurator(connConfigurator);\r\n    }\r\n    return auth;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "isTokenKerberos",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "boolean isTokenKerberos(AuthenticatedURL.Token token) throws AuthenticationException\n{\r\n    if (token.isSet()) {\r\n        AuthToken aToken = AuthToken.parse(token.toString());\r\n        if (aToken.getType().equals(\"kerberos\") || aToken.getType().equals(\"kerberos-dt\")) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "isNegotiate",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "boolean isNegotiate(HttpURLConnection conn) throws IOException\n{\r\n    boolean negotiate = false;\r\n    if (conn.getResponseCode() == HttpURLConnection.HTTP_UNAUTHORIZED) {\r\n        String authHeader = conn.getHeaderField(WWW_AUTHENTICATE);\r\n        negotiate = authHeader != null && authHeader.trim().startsWith(NEGOTIATE);\r\n    }\r\n    return negotiate;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "doSpnegoSequence",
  "errType" : [ "PrivilegedActionException", "LoginException" ],
  "containingMethodsNum" : 12,
  "sourceCodeText" : "void doSpnegoSequence(final AuthenticatedURL.Token token) throws IOException, AuthenticationException\n{\r\n    try {\r\n        AccessControlContext context = AccessController.getContext();\r\n        Subject subject = Subject.getSubject(context);\r\n        if (subject == null || (!KerberosUtil.hasKerberosKeyTab(subject) && !KerberosUtil.hasKerberosTicket(subject))) {\r\n            LOG.debug(\"No subject in context, logging in\");\r\n            subject = new Subject();\r\n            LoginContext login = new LoginContext(\"\", subject, null, new KerberosConfiguration());\r\n            login.login();\r\n        }\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Using subject: \" + subject);\r\n        }\r\n        Subject.doAs(subject, new PrivilegedExceptionAction<Void>() {\r\n\r\n            @Override\r\n            public Void run() throws Exception {\r\n                GSSContext gssContext = null;\r\n                try {\r\n                    GSSManager gssManager = GSSManager.getInstance();\r\n                    String servicePrincipal = KerberosUtil.getServicePrincipal(\"HTTP\", KerberosAuthenticator.this.url.getHost());\r\n                    Oid oid = KerberosUtil.NT_GSS_KRB5_PRINCIPAL_OID;\r\n                    GSSName serviceName = gssManager.createName(servicePrincipal, oid);\r\n                    oid = KerberosUtil.GSS_KRB5_MECH_OID;\r\n                    gssContext = gssManager.createContext(serviceName, oid, null, GSSContext.DEFAULT_LIFETIME);\r\n                    gssContext.requestCredDeleg(true);\r\n                    gssContext.requestMutualAuth(true);\r\n                    byte[] inToken = new byte[0];\r\n                    byte[] outToken;\r\n                    boolean established = false;\r\n                    while (!established) {\r\n                        HttpURLConnection conn = token.openConnection(url, connConfigurator);\r\n                        outToken = gssContext.initSecContext(inToken, 0, inToken.length);\r\n                        if (outToken != null) {\r\n                            sendToken(conn, outToken);\r\n                        }\r\n                        if (!gssContext.isEstablished()) {\r\n                            inToken = readToken(conn);\r\n                        } else {\r\n                            established = true;\r\n                        }\r\n                    }\r\n                } finally {\r\n                    if (gssContext != null) {\r\n                        gssContext.dispose();\r\n                        gssContext = null;\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n    } catch (PrivilegedActionException ex) {\r\n        if (ex.getException() instanceof IOException) {\r\n            throw (IOException) ex.getException();\r\n        } else {\r\n            throw new AuthenticationException(ex.getException());\r\n        }\r\n    } catch (LoginException ex) {\r\n        throw new AuthenticationException(ex);\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "sendToken",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void sendToken(HttpURLConnection conn, byte[] outToken) throws IOException\n{\r\n    String token = base64.encodeToString(outToken);\r\n    conn.setRequestMethod(AUTH_HTTP_METHOD);\r\n    conn.setRequestProperty(AUTHORIZATION, NEGOTIATE + \" \" + token);\r\n    conn.connect();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "readToken",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "byte[] readToken(HttpURLConnection conn) throws IOException, AuthenticationException\n{\r\n    int status = conn.getResponseCode();\r\n    if (status == HttpURLConnection.HTTP_OK || status == HttpURLConnection.HTTP_UNAUTHORIZED) {\r\n        String authHeader = conn.getHeaderField(WWW_AUTHENTICATE);\r\n        if (authHeader == null || !authHeader.trim().startsWith(NEGOTIATE)) {\r\n            throw new AuthenticationException(\"Invalid SPNEGO sequence, '\" + WWW_AUTHENTICATE + \"' header incorrect: \" + authHeader);\r\n        }\r\n        String negotiation = authHeader.trim().substring((NEGOTIATE + \" \").length()).trim();\r\n        return base64.decode(negotiation);\r\n    }\r\n    throw new AuthenticationException(\"Invalid SPNEGO sequence, status code: \" + status);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "generateNewSecret",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "byte[] generateNewSecret()\n{\r\n    byte[] secret = new byte[32];\r\n    rand.nextBytes(secret);\r\n    return secret;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getAuthenticationHandlerClassName",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "String getAuthenticationHandlerClassName(String authHandler)\n{\r\n    if (authHandler == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    String handlerName = authHandler.toLowerCase(Locale.ENGLISH);\r\n    String authHandlerClassName = null;\r\n    if (handlerName.equals(PseudoAuthenticationHandler.TYPE)) {\r\n        authHandlerClassName = PseudoAuthenticationHandler.class.getName();\r\n    } else if (handlerName.equals(KerberosAuthenticationHandler.TYPE)) {\r\n        authHandlerClassName = KerberosAuthenticationHandler.class.getName();\r\n    } else if (handlerName.equals(LdapAuthenticationHandler.TYPE)) {\r\n        authHandlerClassName = LdapAuthenticationHandler.class.getName();\r\n    } else if (handlerName.equals(MultiSchemeAuthenticationHandler.TYPE)) {\r\n        authHandlerClassName = MultiSchemeAuthenticationHandler.class.getName();\r\n    } else {\r\n        authHandlerClassName = authHandler;\r\n    }\r\n    return authHandlerClassName;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "checkAuthScheme",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "String checkAuthScheme(String scheme)\n{\r\n    if (BASIC.equalsIgnoreCase(scheme)) {\r\n        return BASIC;\r\n    } else if (NEGOTIATE.equalsIgnoreCase(scheme)) {\r\n        return NEGOTIATE;\r\n    } else if (DIGEST.equalsIgnoreCase(scheme)) {\r\n        return DIGEST;\r\n    }\r\n    throw new IllegalArgumentException(String.format(\"Unsupported HTTP authentication scheme %s .\" + \" Supported schemes are [%s, %s, %s]\", scheme, BASIC, NEGOTIATE, DIGEST));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "matchAuthScheme",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "boolean matchAuthScheme(String scheme, String auth)\n{\r\n    if (scheme == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    scheme = scheme.trim();\r\n    if (auth == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    auth = auth.trim();\r\n    return auth.regionMatches(true, 0, scheme, 0, scheme.length());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "setConnectionConfigurator",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void setConnectionConfigurator(ConnectionConfigurator configurator)\n{\r\n    connConfigurator = configurator;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "authenticate",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void authenticate(URL url, AuthenticatedURL.Token token) throws IOException, AuthenticationException\n{\r\n    String strUrl = url.toString();\r\n    String paramSeparator = (strUrl.contains(\"?\")) ? \"&\" : \"?\";\r\n    strUrl += paramSeparator + USER_NAME_EQ + getUserName();\r\n    url = new URL(strUrl);\r\n    HttpURLConnection conn = token.openConnection(url, connConfigurator);\r\n    conn.setRequestMethod(\"OPTIONS\");\r\n    conn.connect();\r\n    AuthenticatedURL.extractToken(conn, token);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "getUserName",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String getUserName()\n{\r\n    return System.getProperty(\"user.name\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "checkForIllegalArgument",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void checkForIllegalArgument(String value, String name)\n{\r\n    if (value == null || value.length() == 0 || value.contains(ATTR_SEPARATOR)) {\r\n        throw new IllegalArgumentException(name + ILLEGAL_ARG_MSG);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "setMaxInactives",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void setMaxInactives(long interval)\n{\r\n    this.maxInactives = interval;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "setExpires",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void setExpires(long expires)\n{\r\n    this.expires = expires;\r\n    generateToken();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "isExpired",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "boolean isExpired()\n{\r\n    return (getMaxInactives() != -1 && System.currentTimeMillis() > getMaxInactives()) || (getExpires() != -1 && System.currentTimeMillis() > getExpires());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "generateToken",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void generateToken()\n{\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(USER_NAME).append(\"=\").append(getUserName()).append(ATTR_SEPARATOR);\r\n    sb.append(PRINCIPAL).append(\"=\").append(getName()).append(ATTR_SEPARATOR);\r\n    sb.append(TYPE).append(\"=\").append(getType()).append(ATTR_SEPARATOR);\r\n    if (getMaxInactives() != -1) {\r\n        sb.append(MAX_INACTIVES).append(\"=\").append(getMaxInactives()).append(ATTR_SEPARATOR);\r\n    }\r\n    sb.append(EXPIRES).append(\"=\").append(getExpires());\r\n    tokenStr = sb.toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getUserName",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getUserName()\n{\r\n    return userName;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getName",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getName()\n{\r\n    return principal;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getType",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getType()\n{\r\n    return type;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getMaxInactives",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "long getMaxInactives()\n{\r\n    return maxInactives;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getExpires",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "long getExpires()\n{\r\n    return expires;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "toString",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String toString()\n{\r\n    return tokenStr;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "parse",
  "errType" : null,
  "containingMethodsNum" : 15,
  "sourceCodeText" : "AuthToken parse(String tokenStr) throws AuthenticationException\n{\r\n    if (tokenStr.length() >= 2) {\r\n        if (tokenStr.charAt(0) == '\\\"' && tokenStr.charAt(tokenStr.length() - 1) == '\\\"') {\r\n            tokenStr = tokenStr.substring(1, tokenStr.length() - 1);\r\n        }\r\n    }\r\n    Map<String, String> map = split(tokenStr);\r\n    map.remove(\"s\");\r\n    if (!map.keySet().containsAll(ATTRIBUTES)) {\r\n        throw new AuthenticationException(\"Invalid token string, missing attributes\");\r\n    }\r\n    long expires = Long.parseLong(map.get(EXPIRES));\r\n    AuthToken token = new AuthToken(map.get(USER_NAME), map.get(PRINCIPAL), map.get(TYPE));\r\n    if (map.containsKey(MAX_INACTIVES)) {\r\n        long maxInactives = Long.parseLong(map.get(MAX_INACTIVES));\r\n        token.setMaxInactives(maxInactives);\r\n    }\r\n    token.setExpires(expires);\r\n    return token;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "split",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "Map<String, String> split(String tokenStr) throws AuthenticationException\n{\r\n    Map<String, String> map = new HashMap<String, String>();\r\n    StringTokenizer st = new StringTokenizer(tokenStr, ATTR_SEPARATOR);\r\n    while (st.hasMoreTokens()) {\r\n        String part = st.nextToken();\r\n        int separator = part.indexOf('=');\r\n        if (separator == -1) {\r\n            throw new AuthenticationException(\"Invalid authentication token\");\r\n        }\r\n        String key = part.substring(0, separator);\r\n        String value = part.substring(separator + 1);\r\n        map.put(key, value);\r\n    }\r\n    return map;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "parseRSAPublicKey",
  "errType" : [ "CertificateException" ],
  "containingMethodsNum" : 5,
  "sourceCodeText" : "RSAPublicKey parseRSAPublicKey(String pem) throws ServletException\n{\r\n    String fullPem = PEM_HEADER + pem + PEM_FOOTER;\r\n    PublicKey key = null;\r\n    try {\r\n        CertificateFactory fact = CertificateFactory.getInstance(\"X.509\");\r\n        ByteArrayInputStream is = new ByteArrayInputStream(fullPem.getBytes(StandardCharsets.UTF_8));\r\n        X509Certificate cer = (X509Certificate) fact.generateCertificate(is);\r\n        key = cer.getPublicKey();\r\n    } catch (CertificateException ce) {\r\n        String message = null;\r\n        if (pem.startsWith(PEM_HEADER)) {\r\n            message = \"CertificateException - be sure not to include PEM header \" + \"and footer in the PEM configuration element.\";\r\n        } else {\r\n            message = \"CertificateException - PEM may be corrupt\";\r\n        }\r\n        throw new ServletException(message, ce);\r\n    }\r\n    return (RSAPublicKey) key;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "init",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void init(Properties config, ServletContext servletContext, long tokenValidity) throws Exception\n{\r\n    initSecrets(generateNewSecret(), null);\r\n    startScheduler(tokenValidity, tokenValidity);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "initSecrets",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void initSecrets(byte[] currentSecret, byte[] previousSecret)\n{\r\n    secrets = new byte[][] { currentSecret, previousSecret };\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "startScheduler",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void startScheduler(long initialDelay, long period)\n{\r\n    if (!schedulerRunning) {\r\n        schedulerRunning = true;\r\n        scheduler = Executors.newSingleThreadScheduledExecutor();\r\n        scheduler.scheduleAtFixedRate(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                rollSecret();\r\n            }\r\n        }, initialDelay, period, TimeUnit.MILLISECONDS);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "destroy",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void destroy()\n{\r\n    if (!isDestroyed) {\r\n        isDestroyed = true;\r\n        if (scheduler != null) {\r\n            scheduler.shutdown();\r\n        }\r\n        schedulerRunning = false;\r\n        super.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "rollSecret",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void rollSecret()\n{\r\n    if (!isDestroyed) {\r\n        LOG.debug(\"rolling secret\");\r\n        byte[] newSecret = generateNewSecret();\r\n        secrets = new byte[][] { newSecret, secrets[0] };\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "generateNewSecret",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "byte[] generateNewSecret()",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getCurrentSecret",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "byte[] getCurrentSecret()\n{\r\n    return secrets[0];\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getAllSecrets",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "byte[][] getAllSecrets()\n{\r\n    return secrets;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "init",
  "errType" : [ "Exception", "PrivilegedActionException" ],
  "containingMethodsNum" : 22,
  "sourceCodeText" : "void init(Properties config) throws ServletException\n{\r\n    try {\r\n        String principal = config.getProperty(PRINCIPAL);\r\n        if (principal == null || principal.trim().length() == 0) {\r\n            throw new ServletException(\"Principal not defined in configuration\");\r\n        }\r\n        keytab = config.getProperty(KEYTAB, keytab);\r\n        if (keytab == null || keytab.trim().length() == 0) {\r\n            throw new ServletException(\"Keytab not defined in configuration\");\r\n        }\r\n        File keytabFile = new File(keytab);\r\n        if (!keytabFile.exists()) {\r\n            throw new ServletException(\"Keytab does not exist: \" + keytab);\r\n        }\r\n        final String[] spnegoPrincipals;\r\n        if (principal.equals(\"*\")) {\r\n            spnegoPrincipals = KerberosUtil.getPrincipalNames(keytab, Pattern.compile(\"HTTP/.*\"));\r\n            if (spnegoPrincipals.length == 0) {\r\n                throw new ServletException(\"Principals do not exist in the keytab\");\r\n            }\r\n        } else {\r\n            spnegoPrincipals = new String[] { principal };\r\n        }\r\n        KeyTab keytabInstance = KeyTab.getInstance(keytabFile);\r\n        serverSubject.getPrivateCredentials().add(keytabInstance);\r\n        for (String spnegoPrincipal : spnegoPrincipals) {\r\n            Principal krbPrincipal = new KerberosPrincipal(spnegoPrincipal);\r\n            LOG.info(\"Using keytab {}, for principal {}\", keytab, krbPrincipal);\r\n            serverSubject.getPrincipals().add(krbPrincipal);\r\n        }\r\n        String nameRules = config.getProperty(NAME_RULES, null);\r\n        if (nameRules != null) {\r\n            KerberosName.setRules(nameRules);\r\n        }\r\n        String ruleMechanism = config.getProperty(RULE_MECHANISM, null);\r\n        if (ruleMechanism != null) {\r\n            KerberosName.setRuleMechanism(ruleMechanism);\r\n        }\r\n        final String whitelistStr = config.getProperty(ENDPOINT_WHITELIST, null);\r\n        if (whitelistStr != null) {\r\n            final String[] strs = whitelistStr.trim().split(\"\\\\s*[,\\n]\\\\s*\");\r\n            for (String s : strs) {\r\n                if (s.isEmpty())\r\n                    continue;\r\n                if (ENDPOINT_PATTERN.matcher(s).matches()) {\r\n                    whitelist.add(s);\r\n                } else {\r\n                    throw new ServletException(\"The element of the whitelist: \" + s + \" must start with '/'\" + \" and must not contain special characters afterwards\");\r\n                }\r\n            }\r\n        }\r\n        try {\r\n            gssManager = Subject.doAs(serverSubject, new PrivilegedExceptionAction<GSSManager>() {\r\n\r\n                @Override\r\n                public GSSManager run() throws Exception {\r\n                    return GSSManager.getInstance();\r\n                }\r\n            });\r\n        } catch (PrivilegedActionException ex) {\r\n            throw ex.getException();\r\n        }\r\n    } catch (Exception ex) {\r\n        throw new ServletException(ex);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "destroy",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void destroy()\n{\r\n    keytab = null;\r\n    serverSubject = null;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getType",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getType()\n{\r\n    return type;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getPrincipals",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Set<KerberosPrincipal> getPrincipals()\n{\r\n    return serverSubject.getPrincipals(KerberosPrincipal.class);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getKeytab",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getKeytab()\n{\r\n    return keytab;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "managementOperation",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean managementOperation(AuthenticationToken token, HttpServletRequest request, HttpServletResponse response) throws IOException, AuthenticationException\n{\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "authenticate",
  "errType" : [ "PrivilegedActionException", "Exception" ],
  "containingMethodsNum" : 16,
  "sourceCodeText" : "AuthenticationToken authenticate(HttpServletRequest request, final HttpServletResponse response) throws IOException, AuthenticationException\n{\r\n    final String path = request.getServletPath();\r\n    for (final String endpoint : whitelist) {\r\n        if (endpoint.equals(path)) {\r\n            return AuthenticationToken.ANONYMOUS;\r\n        }\r\n    }\r\n    AuthenticationToken token = null;\r\n    String authorization = request.getHeader(KerberosAuthenticator.AUTHORIZATION);\r\n    if (authorization == null || !authorization.startsWith(KerberosAuthenticator.NEGOTIATE)) {\r\n        response.setHeader(WWW_AUTHENTICATE, KerberosAuthenticator.NEGOTIATE);\r\n        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\r\n        if (authorization == null) {\r\n            LOG.trace(\"SPNEGO starting for url: {}\", request.getRequestURL());\r\n        } else {\r\n            LOG.warn(\"'\" + KerberosAuthenticator.AUTHORIZATION + \"' does not start with '\" + KerberosAuthenticator.NEGOTIATE + \"' :  {}\", authorization);\r\n        }\r\n    } else {\r\n        authorization = authorization.substring(KerberosAuthenticator.NEGOTIATE.length()).trim();\r\n        final Base64 base64 = new Base64(0);\r\n        final byte[] clientToken = base64.decode(authorization);\r\n        try {\r\n            final String serverPrincipal = KerberosUtil.getTokenServerName(clientToken);\r\n            if (!serverPrincipal.startsWith(\"HTTP/\")) {\r\n                throw new IllegalArgumentException(\"Invalid server principal \" + serverPrincipal + \"decoded from client request\");\r\n            }\r\n            token = Subject.doAs(serverSubject, new PrivilegedExceptionAction<AuthenticationToken>() {\r\n\r\n                @Override\r\n                public AuthenticationToken run() throws Exception {\r\n                    return runWithPrincipal(serverPrincipal, clientToken, base64, response);\r\n                }\r\n            });\r\n        } catch (PrivilegedActionException ex) {\r\n            if (ex.getException() instanceof IOException) {\r\n                throw (IOException) ex.getException();\r\n            } else {\r\n                throw new AuthenticationException(ex.getException());\r\n            }\r\n        } catch (Exception ex) {\r\n            throw new AuthenticationException(ex);\r\n        }\r\n    }\r\n    return token;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "runWithPrincipal",
  "errType" : null,
  "containingMethodsNum" : 16,
  "sourceCodeText" : "AuthenticationToken runWithPrincipal(String serverPrincipal, byte[] clientToken, Base64 base64, HttpServletResponse response) throws IOException, GSSException\n{\r\n    GSSContext gssContext = null;\r\n    GSSCredential gssCreds = null;\r\n    AuthenticationToken token = null;\r\n    try {\r\n        LOG.trace(\"SPNEGO initiated with server principal [{}]\", serverPrincipal);\r\n        gssCreds = this.gssManager.createCredential(this.gssManager.createName(serverPrincipal, KerberosUtil.NT_GSS_KRB5_PRINCIPAL_OID), GSSCredential.INDEFINITE_LIFETIME, new Oid[] { KerberosUtil.GSS_SPNEGO_MECH_OID, KerberosUtil.GSS_KRB5_MECH_OID }, GSSCredential.ACCEPT_ONLY);\r\n        gssContext = this.gssManager.createContext(gssCreds);\r\n        byte[] serverToken = gssContext.acceptSecContext(clientToken, 0, clientToken.length);\r\n        if (serverToken != null && serverToken.length > 0) {\r\n            String authenticate = base64.encodeToString(serverToken);\r\n            response.setHeader(KerberosAuthenticator.WWW_AUTHENTICATE, KerberosAuthenticator.NEGOTIATE + \" \" + authenticate);\r\n        }\r\n        if (!gssContext.isEstablished()) {\r\n            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\r\n            LOG.trace(\"SPNEGO in progress\");\r\n        } else {\r\n            String clientPrincipal = gssContext.getSrcName().toString();\r\n            KerberosName kerberosName = new KerberosName(clientPrincipal);\r\n            String userName = kerberosName.getShortName();\r\n            token = new AuthenticationToken(userName, clientPrincipal, getType());\r\n            response.setStatus(HttpServletResponse.SC_OK);\r\n            LOG.trace(\"SPNEGO completed for client principal [{}]\", clientPrincipal);\r\n        }\r\n    } finally {\r\n        if (gssContext != null) {\r\n            gssContext.dispose();\r\n        }\r\n        if (gssCreds != null) {\r\n            gssCreds.dispose();\r\n        }\r\n    }\r\n    return token;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "init",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void init(Properties config) throws ServletException\n{\r\n    acceptAnonymous = Boolean.parseBoolean(config.getProperty(ANONYMOUS_ALLOWED, \"false\"));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getAcceptAnonymous",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean getAcceptAnonymous()\n{\r\n    return acceptAnonymous;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "destroy",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void destroy()\n{\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getType",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getType()\n{\r\n    return type;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "managementOperation",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean managementOperation(AuthenticationToken token, HttpServletRequest request, HttpServletResponse response) throws IOException, AuthenticationException\n{\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getUserName",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "String getUserName(HttpServletRequest request)\n{\r\n    String queryString = request.getQueryString();\r\n    if (queryString == null || queryString.length() == 0) {\r\n        return null;\r\n    }\r\n    List<NameValuePair> list = URLEncodedUtils.parse(queryString, UTF8_CHARSET);\r\n    if (list != null) {\r\n        for (NameValuePair nv : list) {\r\n            if (PseudoAuthenticator.USER_NAME.equals(nv.getName())) {\r\n                return nv.getValue();\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "authenticate",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "AuthenticationToken authenticate(HttpServletRequest request, HttpServletResponse response) throws IOException, AuthenticationException\n{\r\n    AuthenticationToken token;\r\n    String userName = getUserName(request);\r\n    if (userName == null) {\r\n        if (getAcceptAnonymous()) {\r\n            token = AuthenticationToken.ANONYMOUS;\r\n        } else {\r\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\r\n            response.setHeader(WWW_AUTHENTICATE, PSEUDO_AUTH);\r\n            token = null;\r\n        }\r\n    } else {\r\n        token = new AuthenticationToken(userName, userName, getType());\r\n    }\r\n    return token;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "setDefaultAuthenticator",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void setDefaultAuthenticator(Class<? extends Authenticator> authenticator)\n{\r\n    DEFAULT_AUTHENTICATOR = authenticator;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "getDefaultAuthenticator",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Class<? extends Authenticator> getDefaultAuthenticator()\n{\r\n    return DEFAULT_AUTHENTICATOR;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "getAuthenticator",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Authenticator getAuthenticator()\n{\r\n    return authenticator;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "openConnection",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "HttpURLConnection openConnection(URL url, Token token) throws IOException, AuthenticationException\n{\r\n    if (url == null) {\r\n        throw new IllegalArgumentException(\"url cannot be NULL\");\r\n    }\r\n    if (!url.getProtocol().equalsIgnoreCase(\"http\") && !url.getProtocol().equalsIgnoreCase(\"https\")) {\r\n        throw new IllegalArgumentException(\"url must be for a HTTP or HTTPS resource\");\r\n    }\r\n    if (token == null) {\r\n        throw new IllegalArgumentException(\"token cannot be NULL\");\r\n    }\r\n    authenticator.authenticate(url, token);\r\n    return token.openConnection(url, connConfigurator);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "injectToken",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void injectToken(HttpURLConnection conn, Token token)\n{\r\n    HttpCookie authCookie = token.cookieHandler.getAuthCookie();\r\n    if (authCookie != null) {\r\n        conn.addRequestProperty(\"Cookie\", authCookie.toString());\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "extractToken",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void extractToken(HttpURLConnection conn, Token token) throws IOException, AuthenticationException\n{\r\n    int respCode = conn.getResponseCode();\r\n    if (respCode == HttpURLConnection.HTTP_OK || respCode == HttpURLConnection.HTTP_CREATED || respCode == HttpURLConnection.HTTP_ACCEPTED) {\r\n        token.cookieHandler.put(null, conn.getHeaderFields());\r\n    } else if (respCode == HttpURLConnection.HTTP_NOT_FOUND) {\r\n        LOG.trace(\"Setting token value to null ({}), resp={}\", token, respCode);\r\n        token.set(null);\r\n        throw new FileNotFoundException(conn.getURL().toString());\r\n    } else {\r\n        LOG.trace(\"Setting token value to null ({}), resp={}\", token, respCode);\r\n        token.set(null);\r\n        throw new AuthenticationException(\"Authentication failed\" + \", URL: \" + conn.getURL() + \", status: \" + conn.getResponseCode() + \", message: \" + conn.getResponseMessage());\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "setMaxInactives",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void setMaxInactives(long maxInactives)\n{\r\n    if (this != AuthenticationToken.ANONYMOUS) {\r\n        super.setMaxInactives(maxInactives);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "setExpires",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void setExpires(long expires)\n{\r\n    if (this != AuthenticationToken.ANONYMOUS) {\r\n        super.setExpires(expires);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "isExpired",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean isExpired()\n{\r\n    return super.isExpired();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "parse",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "AuthenticationToken parse(String tokenStr) throws AuthenticationException\n{\r\n    return new AuthenticationToken(AuthToken.parse(tokenStr));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "sign",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "String sign(String str)\n{\r\n    if (str == null || str.length() == 0) {\r\n        throw new IllegalArgumentException(\"NULL or empty string to sign\");\r\n    }\r\n    byte[] secret = secretProvider.getCurrentSecret();\r\n    String signature = computeSignature(secret, str);\r\n    return str + SIGNATURE + signature;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "verifyAndExtract",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "String verifyAndExtract(String signedStr) throws SignerException\n{\r\n    int index = signedStr.lastIndexOf(SIGNATURE);\r\n    if (index == -1) {\r\n        throw new SignerException(\"Invalid signed text: \" + signedStr);\r\n    }\r\n    String originalSignature = signedStr.substring(index + SIGNATURE.length());\r\n    String rawValue = signedStr.substring(0, index);\r\n    checkSignatures(rawValue, originalSignature);\r\n    return rawValue;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "computeSignature",
  "errType" : [ "NoSuchAlgorithmException|InvalidKeyException" ],
  "containingMethodsNum" : 5,
  "sourceCodeText" : "String computeSignature(byte[] secret, String str)\n{\r\n    try {\r\n        SecretKeySpec key = new SecretKeySpec((secret), SIGNING_ALGORITHM);\r\n        Mac mac = Mac.getInstance(SIGNING_ALGORITHM);\r\n        mac.init(key);\r\n        byte[] sig = mac.doFinal(StringUtils.getBytesUtf8(str));\r\n        return new Base64(0).encodeToString(sig);\r\n    } catch (NoSuchAlgorithmException | InvalidKeyException ex) {\r\n        throw new RuntimeException(\"It should not happen, \" + ex.getMessage(), ex);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "checkSignatures",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void checkSignatures(String rawValue, String originalSignature) throws SignerException\n{\r\n    byte[] orginalSignatureBytes = StringUtils.getBytesUtf8(originalSignature);\r\n    boolean isValid = false;\r\n    byte[][] secrets = secretProvider.getAllSecrets();\r\n    for (int i = 0; i < secrets.length; i++) {\r\n        byte[] secret = secrets[i];\r\n        if (secret != null) {\r\n            String currentSignature = computeSignature(secret, rawValue);\r\n            if (MessageDigest.isEqual(orginalSignatureBytes, StringUtils.getBytesUtf8(currentSignature))) {\r\n                isValid = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (!isValid) {\r\n        throw new SignerException(\"Invalid signature\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "init",
  "errType" : null,
  "containingMethodsNum" : 11,
  "sourceCodeText" : "void init(FilterConfig filterConfig) throws ServletException\n{\r\n    String configPrefix = filterConfig.getInitParameter(CONFIG_PREFIX);\r\n    configPrefix = (configPrefix != null) ? configPrefix + \".\" : \"\";\r\n    config = getConfiguration(configPrefix, filterConfig);\r\n    String authHandlerName = config.getProperty(AUTH_TYPE, null);\r\n    String authHandlerClassName;\r\n    if (authHandlerName == null) {\r\n        throw new ServletException(\"Authentication type must be specified: \" + PseudoAuthenticationHandler.TYPE + \"|\" + KerberosAuthenticationHandler.TYPE + \"|<class>\");\r\n    }\r\n    authHandlerClassName = AuthenticationHandlerUtil.getAuthenticationHandlerClassName(authHandlerName);\r\n    maxInactiveInterval = Long.parseLong(config.getProperty(AUTH_TOKEN_MAX_INACTIVE_INTERVAL, \"-1\"));\r\n    if (maxInactiveInterval > 0) {\r\n        maxInactiveInterval *= 1000;\r\n    }\r\n    validity = Long.parseLong(config.getProperty(AUTH_TOKEN_VALIDITY, \"36000\")) * 1000;\r\n    initializeSecretProvider(filterConfig);\r\n    initializeAuthHandler(authHandlerClassName, filterConfig);\r\n    cookieDomain = config.getProperty(COOKIE_DOMAIN, null);\r\n    cookiePath = config.getProperty(COOKIE_PATH, null);\r\n    isCookiePersistent = Boolean.parseBoolean(config.getProperty(COOKIE_PERSISTENT, \"false\"));\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "initializeAuthHandler",
  "errType" : [ "ClassNotFoundException|InstantiationException|IllegalAccessException" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void initializeAuthHandler(String authHandlerClassName, FilterConfig filterConfig) throws ServletException\n{\r\n    try {\r\n        Class<?> klass = Thread.currentThread().getContextClassLoader().loadClass(authHandlerClassName);\r\n        authHandler = (AuthenticationHandler) klass.newInstance();\r\n        authHandler.init(config);\r\n    } catch (ClassNotFoundException | InstantiationException | IllegalAccessException ex) {\r\n        throw new ServletException(ex);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "initializeSecretProvider",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void initializeSecretProvider(FilterConfig filterConfig) throws ServletException\n{\r\n    secretProvider = (SignerSecretProvider) filterConfig.getServletContext().getAttribute(SIGNER_SECRET_PROVIDER_ATTRIBUTE);\r\n    if (secretProvider == null) {\r\n        try {\r\n            secretProvider = constructSecretProvider(filterConfig.getServletContext(), config, false);\r\n            destroySecretProvider = true;\r\n        } catch (Exception ex) {\r\n            throw new ServletException(ex);\r\n        }\r\n    }\r\n    signer = new Signer(secretProvider);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "constructSecretProvider",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 14,
  "sourceCodeText" : "SignerSecretProvider constructSecretProvider(ServletContext ctx, Properties config, boolean disallowFallbackToRandomSecretProvider) throws Exception\n{\r\n    String name = config.getProperty(SIGNER_SECRET_PROVIDER, \"file\");\r\n    long validity = Long.parseLong(config.getProperty(AUTH_TOKEN_VALIDITY, \"36000\")) * 1000;\r\n    if (!disallowFallbackToRandomSecretProvider && \"file\".equals(name) && config.getProperty(SIGNATURE_SECRET_FILE) == null) {\r\n        name = \"random\";\r\n    }\r\n    SignerSecretProvider provider;\r\n    if (\"file\".equals(name)) {\r\n        provider = new FileSignerSecretProvider();\r\n        try {\r\n            provider.init(config, ctx, validity);\r\n        } catch (Exception e) {\r\n            if (!disallowFallbackToRandomSecretProvider) {\r\n                LOG.warn(\"Unable to initialize FileSignerSecretProvider, \" + \"falling back to use random secrets. Reason: \" + e.getMessage());\r\n                provider = new RandomSignerSecretProvider();\r\n                provider.init(config, ctx, validity);\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n    } else if (\"random\".equals(name)) {\r\n        provider = new RandomSignerSecretProvider();\r\n        provider.init(config, ctx, validity);\r\n    } else if (\"zookeeper\".equals(name)) {\r\n        provider = new ZKSignerSecretProvider();\r\n        provider.init(config, ctx, validity);\r\n    } else {\r\n        provider = (SignerSecretProvider) Thread.currentThread().getContextClassLoader().loadClass(name).newInstance();\r\n        provider.init(config, ctx, validity);\r\n    }\r\n    return provider;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getConfiguration",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Properties getConfiguration()\n{\r\n    return config;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getAuthenticationHandler",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "AuthenticationHandler getAuthenticationHandler()\n{\r\n    return authHandler;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "isRandomSecret",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean isRandomSecret()\n{\r\n    return secretProvider.getClass() == RandomSignerSecretProvider.class;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "isCustomSignerSecretProvider",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean isCustomSignerSecretProvider()\n{\r\n    Class<?> clazz = secretProvider.getClass();\r\n    return clazz != FileSignerSecretProvider.class && clazz != RandomSignerSecretProvider.class && clazz != ZKSignerSecretProvider.class;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getMaxInactiveInterval",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "long getMaxInactiveInterval()\n{\r\n    return maxInactiveInterval / 1000;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getValidity",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "long getValidity()\n{\r\n    return validity / 1000;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getCookieDomain",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getCookieDomain()\n{\r\n    return cookieDomain;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getCookiePath",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getCookiePath()\n{\r\n    return cookiePath;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "isCookiePersistent",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean isCookiePersistent()\n{\r\n    return isCookiePersistent;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "destroy",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void destroy()\n{\r\n    if (authHandler != null) {\r\n        authHandler.destroy();\r\n        authHandler = null;\r\n    }\r\n    if (secretProvider != null && destroySecretProvider) {\r\n        secretProvider.destroy();\r\n        secretProvider = null;\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getConfiguration",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "Properties getConfiguration(String configPrefix, FilterConfig filterConfig) throws ServletException\n{\r\n    Properties props = new Properties();\r\n    Enumeration<?> names = filterConfig.getInitParameterNames();\r\n    while (names.hasMoreElements()) {\r\n        String name = (String) names.nextElement();\r\n        if (name.startsWith(configPrefix)) {\r\n            String value = filterConfig.getInitParameter(name);\r\n            props.put(name.substring(configPrefix.length()), value);\r\n        }\r\n    }\r\n    return props;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getRequestURL",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "String getRequestURL(HttpServletRequest request)\n{\r\n    StringBuffer sb = request.getRequestURL();\r\n    if (request.getQueryString() != null) {\r\n        sb.append(\"?\").append(request.getQueryString());\r\n    }\r\n    return sb.toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getToken",
  "errType" : [ "SignerException" ],
  "containingMethodsNum" : 8,
  "sourceCodeText" : "AuthenticationToken getToken(HttpServletRequest request) throws IOException, AuthenticationException\n{\r\n    AuthenticationToken token = null;\r\n    String tokenStr = null;\r\n    Cookie[] cookies = request.getCookies();\r\n    if (cookies != null) {\r\n        for (Cookie cookie : cookies) {\r\n            if (cookie.getName().equals(AuthenticatedURL.AUTH_COOKIE)) {\r\n                tokenStr = cookie.getValue();\r\n                if (tokenStr.isEmpty()) {\r\n                    throw new AuthenticationException(\"Unauthorized access\");\r\n                }\r\n                try {\r\n                    tokenStr = signer.verifyAndExtract(tokenStr);\r\n                } catch (SignerException ex) {\r\n                    throw new AuthenticationException(ex);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (tokenStr != null) {\r\n        token = AuthenticationToken.parse(tokenStr);\r\n        boolean match = verifyTokenType(getAuthenticationHandler(), token);\r\n        if (!match) {\r\n            throw new AuthenticationException(\"Invalid AuthenticationToken type\");\r\n        }\r\n        if (token.isExpired()) {\r\n            throw new AuthenticationException(\"AuthenticationToken expired\");\r\n        }\r\n    }\r\n    return token;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "verifyTokenType",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "boolean verifyTokenType(AuthenticationHandler handler, AuthenticationToken token)\n{\r\n    if (!(handler instanceof CompositeAuthenticationHandler)) {\r\n        return handler.getType().equals(token.getType());\r\n    }\r\n    boolean match = false;\r\n    Collection<String> tokenTypes = ((CompositeAuthenticationHandler) handler).getTokenTypes();\r\n    for (String tokenType : tokenTypes) {\r\n        if (tokenType.equals(token.getType())) {\r\n            match = true;\r\n            break;\r\n        }\r\n    }\r\n    return match;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "doFilter",
  "errType" : [ "AuthenticationException", "AuthenticationException" ],
  "containingMethodsNum" : 36,
  "sourceCodeText" : "void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException\n{\r\n    boolean unauthorizedResponse = true;\r\n    int errCode = HttpServletResponse.SC_UNAUTHORIZED;\r\n    AuthenticationException authenticationEx = null;\r\n    HttpServletRequest httpRequest = (HttpServletRequest) request;\r\n    HttpServletResponse httpResponse = (HttpServletResponse) response;\r\n    boolean isHttps = \"https\".equals(httpRequest.getScheme());\r\n    try {\r\n        boolean newToken = false;\r\n        AuthenticationToken token;\r\n        try {\r\n            token = getToken(httpRequest);\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"Got token {} from httpRequest {}\", token, getRequestURL(httpRequest));\r\n            }\r\n        } catch (AuthenticationException ex) {\r\n            LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\r\n            authenticationEx = ex;\r\n            token = null;\r\n        }\r\n        if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\r\n            if (token == null) {\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Request [{}] triggering authentication. handler: {}\", getRequestURL(httpRequest), authHandler.getClass());\r\n                }\r\n                token = authHandler.authenticate(httpRequest, httpResponse);\r\n                if (token != null && token != AuthenticationToken.ANONYMOUS) {\r\n                    if (token.getMaxInactives() > 0) {\r\n                        token.setMaxInactives(System.currentTimeMillis() + getMaxInactiveInterval() * 1000);\r\n                    }\r\n                    if (token.getExpires() != 0) {\r\n                        token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\r\n                    }\r\n                }\r\n                newToken = true;\r\n            }\r\n            if (token != null) {\r\n                unauthorizedResponse = false;\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\r\n                }\r\n                final AuthenticationToken authToken = token;\r\n                httpRequest = new HttpServletRequestWrapper(httpRequest) {\r\n\r\n                    @Override\r\n                    public String getAuthType() {\r\n                        return authToken.getType();\r\n                    }\r\n\r\n                    @Override\r\n                    public String getRemoteUser() {\r\n                        return authToken.getUserName();\r\n                    }\r\n\r\n                    @Override\r\n                    public Principal getUserPrincipal() {\r\n                        return (authToken != AuthenticationToken.ANONYMOUS) ? authToken : null;\r\n                    }\r\n                };\r\n                if (!newToken && !isCookiePersistent() && getMaxInactiveInterval() > 0) {\r\n                    token.setMaxInactives(System.currentTimeMillis() + getMaxInactiveInterval() * 1000);\r\n                    token.setExpires(token.getExpires());\r\n                    newToken = true;\r\n                }\r\n                if (newToken && !token.isExpired() && token != AuthenticationToken.ANONYMOUS) {\r\n                    String signedToken = signer.sign(token.toString());\r\n                    createAuthCookie(httpResponse, signedToken, getCookieDomain(), getCookiePath(), token.getExpires(), isCookiePersistent(), isHttps);\r\n                }\r\n                doFilter(filterChain, httpRequest, httpResponse);\r\n            }\r\n        } else {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"managementOperation returned false for request {}.\" + \" token: {}\", getRequestURL(httpRequest), token);\r\n            }\r\n            unauthorizedResponse = false;\r\n        }\r\n    } catch (AuthenticationException ex) {\r\n        errCode = HttpServletResponse.SC_FORBIDDEN;\r\n        authenticationEx = ex;\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Authentication exception: \" + ex.getMessage(), ex);\r\n        } else {\r\n            LOG.warn(\"Authentication exception: \" + ex.getMessage());\r\n        }\r\n    }\r\n    if (unauthorizedResponse) {\r\n        if (!httpResponse.isCommitted()) {\r\n            createAuthCookie(httpResponse, \"\", getCookieDomain(), getCookiePath(), 0, isCookiePersistent(), isHttps);\r\n            if ((errCode == HttpServletResponse.SC_UNAUTHORIZED) && (!httpResponse.containsHeader(KerberosAuthenticator.WWW_AUTHENTICATE))) {\r\n                errCode = HttpServletResponse.SC_FORBIDDEN;\r\n            }\r\n            String reason;\r\n            if (authenticationEx == null) {\r\n                reason = \"Authentication required\";\r\n            } else {\r\n                reason = authenticationEx.getMessage();\r\n            }\r\n            httpResponse.setStatus(errCode, reason);\r\n            httpResponse.sendError(errCode, reason);\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "doFilter",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void doFilter(FilterChain filterChain, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n{\r\n    filterChain.doFilter(request, response);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "createAuthCookie",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void createAuthCookie(HttpServletResponse resp, String token, String domain, String path, long expires, boolean isCookiePersistent, boolean isSecure)\n{\r\n    StringBuilder sb = new StringBuilder(AuthenticatedURL.AUTH_COOKIE).append(\"=\");\r\n    if (token != null && token.length() > 0) {\r\n        sb.append(\"\\\"\").append(token).append(\"\\\"\");\r\n    }\r\n    if (path != null) {\r\n        sb.append(\"; Path=\").append(path);\r\n    }\r\n    if (domain != null) {\r\n        sb.append(\"; Domain=\").append(domain);\r\n    }\r\n    if (expires >= 0 && isCookiePersistent) {\r\n        Date date = new Date(expires);\r\n        SimpleDateFormat df = new SimpleDateFormat(\"EEE, \" + \"dd-MMM-yyyy HH:mm:ss zzz\", Locale.US);\r\n        df.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\r\n        sb.append(\"; Expires=\").append(df.format(date));\r\n    }\r\n    if (isSecure) {\r\n        sb.append(\"; Secure\");\r\n    }\r\n    sb.append(\"; HttpOnly\");\r\n    resp.addHeader(\"Set-Cookie\", sb.toString());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "init",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void init(Properties config, ServletContext servletContext, long tokenValidity) throws Exception",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "destroy",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void destroy()\n{\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getCurrentSecret",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "byte[] getCurrentSecret()",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getAllSecrets",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "byte[][] getAllSecrets()",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getType",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getType()\n{\r\n    return authType;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getTokenTypes",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Collection<String> getTokenTypes()\n{\r\n    return types;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "init",
  "errType" : null,
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void init(Properties config) throws ServletException\n{\r\n    for (Map.Entry prop : config.entrySet()) {\r\n        logger.info(\"{} : {}\", prop.getKey(), prop.getValue());\r\n    }\r\n    this.types.clear();\r\n    if (config.getProperty(SCHEMES_PROPERTY) == null) {\r\n        throw new NullPointerException(SCHEMES_PROPERTY + \" system property is not specified.\");\r\n    }\r\n    String schemesProperty = config.getProperty(SCHEMES_PROPERTY);\r\n    for (String scheme : STR_SPLITTER.split(schemesProperty)) {\r\n        scheme = AuthenticationHandlerUtil.checkAuthScheme(scheme);\r\n        if (schemeToAuthHandlerMapping.containsKey(scheme)) {\r\n            throw new IllegalArgumentException(\"Handler is already specified for \" + scheme + \" authentication scheme.\");\r\n        }\r\n        String authHandlerPropName = String.format(AUTH_HANDLER_PROPERTY, scheme).toLowerCase();\r\n        String authHandlerName = config.getProperty(authHandlerPropName);\r\n        if (authHandlerName == null) {\r\n            throw new NullPointerException(\"No auth handler configured for scheme \" + scheme);\r\n        }\r\n        String authHandlerClassName = AuthenticationHandlerUtil.getAuthenticationHandlerClassName(authHandlerName);\r\n        AuthenticationHandler handler = initializeAuthHandler(authHandlerClassName, config);\r\n        schemeToAuthHandlerMapping.put(scheme, handler);\r\n        types.add(handler.getType());\r\n    }\r\n    logger.info(\"Successfully initialized MultiSchemeAuthenticationHandler\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "initializeAuthHandler",
  "errType" : [ "ClassNotFoundException|InstantiationException|IllegalAccessException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "AuthenticationHandler initializeAuthHandler(String authHandlerClassName, Properties config) throws ServletException\n{\r\n    try {\r\n        if (authHandlerClassName == null) {\r\n            throw new NullPointerException();\r\n        }\r\n        logger.debug(\"Initializing Authentication handler of type \" + authHandlerClassName);\r\n        Class<?> klass = Thread.currentThread().getContextClassLoader().loadClass(authHandlerClassName);\r\n        AuthenticationHandler authHandler = (AuthenticationHandler) klass.newInstance();\r\n        authHandler.init(config);\r\n        logger.info(\"Successfully initialized Authentication handler of type \" + authHandlerClassName);\r\n        return authHandler;\r\n    } catch (ClassNotFoundException | InstantiationException | IllegalAccessException ex) {\r\n        logger.error(\"Failed to initialize authentication handler \" + authHandlerClassName, ex);\r\n        throw new ServletException(ex);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "destroy",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void destroy()\n{\r\n    for (AuthenticationHandler handler : schemeToAuthHandlerMapping.values()) {\r\n        handler.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "managementOperation",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean managementOperation(AuthenticationToken token, HttpServletRequest request, HttpServletResponse response) throws IOException, AuthenticationException\n{\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "authenticate",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "AuthenticationToken authenticate(HttpServletRequest request, HttpServletResponse response) throws IOException, AuthenticationException\n{\r\n    String authorization = request.getHeader(HttpConstants.AUTHORIZATION_HEADER);\r\n    if (authorization != null) {\r\n        for (Map.Entry<String, AuthenticationHandler> entry : schemeToAuthHandlerMapping.entrySet()) {\r\n            if (AuthenticationHandlerUtil.matchAuthScheme(entry.getKey(), authorization)) {\r\n                AuthenticationToken token = entry.getValue().authenticate(request, response);\r\n                logger.trace(\"Token generated with type {}\", token.getType());\r\n                return token;\r\n            }\r\n        }\r\n    }\r\n    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\r\n    for (String scheme : schemeToAuthHandlerMapping.keySet()) {\r\n        response.addHeader(HttpConstants.WWW_AUTHENTICATE_HEADER, scheme);\r\n    }\r\n    return null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "setPublicKey",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void setPublicKey(RSAPublicKey pk)\n{\r\n    publicKey = pk;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "init",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void init(Properties config) throws ServletException\n{\r\n    super.init(config);\r\n    authenticationProviderUrl = config.getProperty(AUTHENTICATION_PROVIDER_URL);\r\n    if (authenticationProviderUrl == null) {\r\n        throw new ServletException(\"Authentication provider URL must not be null - configure: \" + AUTHENTICATION_PROVIDER_URL);\r\n    }\r\n    if (publicKey == null) {\r\n        String pemPublicKey = config.getProperty(PUBLIC_KEY_PEM);\r\n        if (pemPublicKey == null) {\r\n            throw new ServletException(\"Public key for signature validation must be provisioned.\");\r\n        }\r\n        publicKey = CertificateUtil.parseRSAPublicKey(pemPublicKey);\r\n    }\r\n    String auds = config.getProperty(EXPECTED_JWT_AUDIENCES);\r\n    if (auds != null) {\r\n        String[] audArray = auds.split(\",\");\r\n        audiences = new ArrayList<String>();\r\n        for (String a : audArray) {\r\n            audiences.add(a);\r\n        }\r\n    }\r\n    String customCookieName = config.getProperty(JWT_COOKIE_NAME);\r\n    if (customCookieName != null) {\r\n        cookieName = customCookieName;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "alternateAuthenticate",
  "errType" : [ "ParseException" ],
  "containingMethodsNum" : 15,
  "sourceCodeText" : "AuthenticationToken alternateAuthenticate(HttpServletRequest request, HttpServletResponse response) throws IOException, AuthenticationException\n{\r\n    AuthenticationToken token = null;\r\n    String serializedJWT = null;\r\n    HttpServletRequest req = (HttpServletRequest) request;\r\n    serializedJWT = getJWTFromCookie(req);\r\n    if (serializedJWT == null) {\r\n        String loginURL = constructLoginURL(request);\r\n        LOG.info(\"sending redirect to: \" + loginURL);\r\n        ((HttpServletResponse) response).sendRedirect(loginURL);\r\n    } else {\r\n        String userName = null;\r\n        SignedJWT jwtToken = null;\r\n        boolean valid = false;\r\n        try {\r\n            jwtToken = SignedJWT.parse(serializedJWT);\r\n            valid = validateToken(jwtToken);\r\n            if (valid) {\r\n                userName = jwtToken.getJWTClaimsSet().getSubject();\r\n                LOG.info(\"USERNAME: \" + userName);\r\n            } else {\r\n                LOG.warn(\"jwtToken failed validation: \" + jwtToken.serialize());\r\n            }\r\n        } catch (ParseException pe) {\r\n            LOG.warn(\"Unable to parse the JWT token\", pe);\r\n        }\r\n        if (valid) {\r\n            LOG.debug(\"Issuing AuthenticationToken for user.\");\r\n            token = new AuthenticationToken(userName, userName, getType());\r\n        } else {\r\n            String loginURL = constructLoginURL(request);\r\n            LOG.info(\"token validation failed - sending redirect to: \" + loginURL);\r\n            ((HttpServletResponse) response).sendRedirect(loginURL);\r\n        }\r\n    }\r\n    return token;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getJWTFromCookie",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "String getJWTFromCookie(HttpServletRequest req)\n{\r\n    String serializedJWT = null;\r\n    Cookie[] cookies = req.getCookies();\r\n    if (cookies != null) {\r\n        for (Cookie cookie : cookies) {\r\n            if (cookieName.equals(cookie.getName())) {\r\n                LOG.info(cookieName + \" cookie has been found and is being processed\");\r\n                serializedJWT = cookie.getValue();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return serializedJWT;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "constructLoginURL",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "String constructLoginURL(HttpServletRequest request)\n{\r\n    String delimiter = \"?\";\r\n    if (authenticationProviderUrl.contains(\"?\")) {\r\n        delimiter = \"&\";\r\n    }\r\n    String loginURL = authenticationProviderUrl + delimiter + ORIGINAL_URL_QUERY_PARAM + request.getRequestURL().toString() + getOriginalQueryString(request);\r\n    return loginURL;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getOriginalQueryString",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String getOriginalQueryString(HttpServletRequest request)\n{\r\n    String originalQueryString = request.getQueryString();\r\n    return (originalQueryString == null) ? \"\" : \"?\" + originalQueryString;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "validateToken",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "boolean validateToken(SignedJWT jwtToken)\n{\r\n    boolean sigValid = validateSignature(jwtToken);\r\n    if (!sigValid) {\r\n        LOG.warn(\"Signature could not be verified\");\r\n    }\r\n    boolean audValid = validateAudiences(jwtToken);\r\n    if (!audValid) {\r\n        LOG.warn(\"Audience validation failed.\");\r\n    }\r\n    boolean expValid = validateExpiration(jwtToken);\r\n    if (!expValid) {\r\n        LOG.info(\"Expiration validation failed.\");\r\n    }\r\n    return sigValid && audValid && expValid;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "validateSignature",
  "errType" : [ "JOSEException" ],
  "containingMethodsNum" : 8,
  "sourceCodeText" : "boolean validateSignature(SignedJWT jwtToken)\n{\r\n    boolean valid = false;\r\n    if (JWSObject.State.SIGNED == jwtToken.getState()) {\r\n        LOG.debug(\"JWT token is in a SIGNED state\");\r\n        if (jwtToken.getSignature() != null) {\r\n            LOG.debug(\"JWT token signature is not null\");\r\n            try {\r\n                JWSVerifier verifier = new RSASSAVerifier(publicKey);\r\n                if (jwtToken.verify(verifier)) {\r\n                    valid = true;\r\n                    LOG.debug(\"JWT token has been successfully verified\");\r\n                } else {\r\n                    LOG.warn(\"JWT signature verification failed.\");\r\n                }\r\n            } catch (JOSEException je) {\r\n                LOG.warn(\"Error while validating signature\", je);\r\n            }\r\n        }\r\n    }\r\n    return valid;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "validateAudiences",
  "errType" : [ "ParseException" ],
  "containingMethodsNum" : 5,
  "sourceCodeText" : "boolean validateAudiences(SignedJWT jwtToken)\n{\r\n    boolean valid = false;\r\n    try {\r\n        List<String> tokenAudienceList = jwtToken.getJWTClaimsSet().getAudience();\r\n        if (audiences == null) {\r\n            valid = true;\r\n        } else {\r\n            boolean found = false;\r\n            for (String aud : tokenAudienceList) {\r\n                if (audiences.contains(aud)) {\r\n                    LOG.debug(\"JWT token audience has been successfully validated\");\r\n                    valid = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!valid) {\r\n                LOG.warn(\"JWT audience validation failed.\");\r\n            }\r\n        }\r\n    } catch (ParseException pe) {\r\n        LOG.warn(\"Unable to parse the JWT token.\", pe);\r\n    }\r\n    return valid;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "validateExpiration",
  "errType" : [ "ParseException" ],
  "containingMethodsNum" : 5,
  "sourceCodeText" : "boolean validateExpiration(SignedJWT jwtToken)\n{\r\n    boolean valid = false;\r\n    try {\r\n        Date expires = jwtToken.getJWTClaimsSet().getExpirationTime();\r\n        if (expires == null || new Date().before(expires)) {\r\n            LOG.debug(\"JWT token expiration date has been \" + \"successfully validated\");\r\n            valid = true;\r\n        } else {\r\n            LOG.warn(\"JWT expiration date validation failed.\");\r\n        }\r\n    } catch (ParseException pe) {\r\n        LOG.warn(\"JWT expiration date validation failed.\", pe);\r\n    }\r\n    return valid;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getKrb5LoginModuleName",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getKrb5LoginModuleName()\n{\r\n    return (IBM_JAVA) ? \"com.ibm.security.auth.module.Krb5LoginModule\" : \"com.sun.security.auth.module.Krb5LoginModule\";\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getNumericOidInstance",
  "errType" : [ "GSSException" ],
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Oid getNumericOidInstance(String oidName)\n{\r\n    try {\r\n        return new Oid(oidName);\r\n    } catch (GSSException ex) {\r\n        throw new IllegalArgumentException(ex);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getOidInstance",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Oid getOidInstance(String oidName) throws ClassNotFoundException, GSSException, NoSuchFieldException, IllegalAccessException\n{\r\n    switch(oidName) {\r\n        case \"GSS_SPNEGO_MECH_OID\":\r\n            return GSS_SPNEGO_MECH_OID;\r\n        case \"GSS_KRB5_MECH_OID\":\r\n            return GSS_KRB5_MECH_OID;\r\n        case \"NT_GSS_KRB5_PRINCIPAL\":\r\n            return NT_GSS_KRB5_PRINCIPAL_OID;\r\n        default:\r\n            throw new NoSuchFieldException(\"oidName: \" + oidName + \" is not supported.\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getDefaultRealm",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String getDefaultRealm() throws ClassNotFoundException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException\n{\r\n    return new KerberosPrincipal(\"tmp\", 1).getRealm();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getDefaultRealmProtected",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String getDefaultRealmProtected()\n{\r\n    try {\r\n        return getDefaultRealm();\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getDomainRealm",
  "errType" : [ "RuntimeException", "Exception" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "String getDomainRealm(String shortprinc)\n{\r\n    Class<?> classRef;\r\n    Object principalName;\r\n    String realmString = null;\r\n    try {\r\n        if (IBM_JAVA) {\r\n            classRef = Class.forName(\"com.ibm.security.krb5.PrincipalName\");\r\n        } else {\r\n            classRef = Class.forName(\"sun.security.krb5.PrincipalName\");\r\n        }\r\n        int tKrbNtSrvHst = classRef.getField(\"KRB_NT_SRV_HST\").getInt(null);\r\n        principalName = classRef.getConstructor(String.class, int.class).newInstance(shortprinc, tKrbNtSrvHst);\r\n        realmString = (String) classRef.getMethod(\"getRealmString\", new Class[0]).invoke(principalName, new Object[0]);\r\n    } catch (RuntimeException rte) {\r\n    } catch (Exception e) {\r\n    }\r\n    if (null == realmString || realmString.equals(\"\")) {\r\n        return getDefaultRealmProtected();\r\n    } else {\r\n        return realmString;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getLocalHostName",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String getLocalHostName() throws UnknownHostException\n{\r\n    return InetAddress.getLocalHost().getCanonicalHostName();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getServicePrincipal",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "String getServicePrincipal(String service, String hostname) throws UnknownHostException\n{\r\n    String fqdn = hostname;\r\n    String shortprinc = null;\r\n    String realmString = null;\r\n    if (null == fqdn || fqdn.equals(\"\") || fqdn.equals(\"0.0.0.0\")) {\r\n        fqdn = getLocalHostName();\r\n    }\r\n    fqdn = fqdn.toLowerCase(Locale.US);\r\n    shortprinc = service + \"/\" + fqdn;\r\n    realmString = getDomainRealm(shortprinc);\r\n    if (null == realmString || realmString.equals(\"\")) {\r\n        return shortprinc;\r\n    } else {\r\n        return shortprinc + \"@\" + realmString;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getPrincipalNames",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "String[] getPrincipalNames(String keytabFileName) throws IOException\n{\r\n    Keytab keytab = Keytab.loadKeytab(new File(keytabFileName));\r\n    Set<String> principals = new HashSet<String>();\r\n    List<PrincipalName> entries = keytab.getPrincipals();\r\n    for (PrincipalName entry : entries) {\r\n        principals.add(entry.getName().replace(\"\\\\\", \"/\"));\r\n    }\r\n    return principals.toArray(new String[0]);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getPrincipalNames",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "String[] getPrincipalNames(String keytab, Pattern pattern) throws IOException\n{\r\n    String[] principals = getPrincipalNames(keytab);\r\n    if (principals.length != 0) {\r\n        List<String> matchingPrincipals = new ArrayList<String>();\r\n        for (String principal : principals) {\r\n            if (pattern.matcher(principal).matches()) {\r\n                matchingPrincipals.add(principal);\r\n            }\r\n        }\r\n        principals = matchingPrincipals.toArray(new String[0]);\r\n    }\r\n    return principals;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "hasKerberosKeyTab",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean hasKerberosKeyTab(Subject subject)\n{\r\n    return !subject.getPrivateCredentials(KeyTab.class).isEmpty();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "hasKerberosTicket",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean hasKerberosTicket(Subject subject)\n{\r\n    return !subject.getPrivateCredentials(KerberosTicket.class).isEmpty();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getTokenServerName",
  "errType" : null,
  "containingMethodsNum" : 14,
  "sourceCodeText" : "String getTokenServerName(byte[] rawToken)\n{\r\n    DER token = new DER(rawToken);\r\n    DER oid = token.next();\r\n    if (oid.equals(DER.SPNEGO_MECH_OID)) {\r\n        token = token.next().get(0xa0, 0x30, 0xa2, 0x04).next();\r\n        oid = token.next();\r\n    }\r\n    if (!oid.equals(DER.KRB5_MECH_OID)) {\r\n        throw new IllegalArgumentException(\"Malformed gss token\");\r\n    }\r\n    if (token.next().getTag() != 1) {\r\n        throw new IllegalArgumentException(\"Not an AP-REQ token\");\r\n    }\r\n    DER ticket = token.next().get(0x6e, 0x30, 0xa3, 0x61, 0x30);\r\n    String realm = ticket.get(0xa1, 0x1b).getAsString();\r\n    DER names = ticket.get(0xa2, 0x30, 0xa1, 0x30);\r\n    StringBuilder sb = new StringBuilder();\r\n    while (names.hasNext()) {\r\n        if (sb.length() > 0) {\r\n            sb.append('/');\r\n        }\r\n        sb.append(names.next().getAsString());\r\n    }\r\n    return sb.append('@').append(realm).toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "init",
  "errType" : [ "KeeperException.NodeExistsException" ],
  "containingMethodsNum" : 13,
  "sourceCodeText" : "void init(Properties config, ServletContext servletContext, long tokenValidity) throws Exception\n{\r\n    Object curatorClientObj = servletContext.getAttribute(ZOOKEEPER_SIGNER_SECRET_PROVIDER_CURATOR_CLIENT_ATTRIBUTE);\r\n    if (curatorClientObj != null && curatorClientObj instanceof CuratorFramework) {\r\n        client = (CuratorFramework) curatorClientObj;\r\n    } else {\r\n        client = createCuratorClient(config);\r\n        servletContext.setAttribute(ZOOKEEPER_SIGNER_SECRET_PROVIDER_CURATOR_CLIENT_ATTRIBUTE, client);\r\n    }\r\n    this.tokenValidity = tokenValidity;\r\n    shouldDisconnect = Boolean.parseBoolean(config.getProperty(DISCONNECT_FROM_ZOOKEEPER_ON_SHUTDOWN, \"true\"));\r\n    path = config.getProperty(ZOOKEEPER_PATH);\r\n    if (path == null) {\r\n        throw new IllegalArgumentException(ZOOKEEPER_PATH + \" must be specified\");\r\n    }\r\n    try {\r\n        nextRolloverDate = System.currentTimeMillis() + tokenValidity;\r\n        client.create().creatingParentsIfNeeded().forPath(path, generateZKData(generateRandomSecret(), generateRandomSecret(), null));\r\n        zkVersion = 0;\r\n        LOG.info(\"Creating secret znode\");\r\n    } catch (KeeperException.NodeExistsException nee) {\r\n        LOG.info(\"The secret znode already exists, retrieving data\");\r\n    }\r\n    pullFromZK(true);\r\n    long initialDelay = nextRolloverDate - System.currentTimeMillis();\r\n    if (initialDelay < 1l) {\r\n        int i = 1;\r\n        while (initialDelay < 1l) {\r\n            initialDelay = nextRolloverDate + tokenValidity * i - System.currentTimeMillis();\r\n            i++;\r\n        }\r\n    }\r\n    super.startScheduler(initialDelay, tokenValidity);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "destroy",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void destroy()\n{\r\n    if (shouldDisconnect && client != null) {\r\n        client.close();\r\n    }\r\n    super.destroy();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "rollSecret",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void rollSecret()\n{\r\n    super.rollSecret();\r\n    nextRolloverDate += tokenValidity;\r\n    byte[][] secrets = super.getAllSecrets();\r\n    pushToZK(generateRandomSecret(), secrets[0], secrets[1]);\r\n    pullFromZK(false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "generateNewSecret",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "byte[] generateNewSecret()\n{\r\n    return nextSecret;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "pushToZK",
  "errType" : [ "KeeperException.BadVersionException", "Exception" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void pushToZK(byte[] newSecret, byte[] currentSecret, byte[] previousSecret)\n{\r\n    byte[] bytes = generateZKData(newSecret, currentSecret, previousSecret);\r\n    try {\r\n        client.setData().withVersion(zkVersion).forPath(path, bytes);\r\n    } catch (KeeperException.BadVersionException bve) {\r\n        LOG.debug(\"Unable to push to znode; another server already did it\");\r\n    } catch (Exception ex) {\r\n        LOG.error(\"An unexpected exception occurred pushing data to ZooKeeper\", ex);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "generateZKData",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "byte[] generateZKData(byte[] newSecret, byte[] currentSecret, byte[] previousSecret)\n{\r\n    int newSecretLength = newSecret.length;\r\n    int currentSecretLength = currentSecret.length;\r\n    int previousSecretLength = 0;\r\n    if (previousSecret != null) {\r\n        previousSecretLength = previousSecret.length;\r\n    }\r\n    ByteBuffer bb = ByteBuffer.allocate(INT_BYTES + INT_BYTES + newSecretLength + INT_BYTES + currentSecretLength + INT_BYTES + previousSecretLength + LONG_BYTES);\r\n    bb.putInt(DATA_VERSION);\r\n    bb.putInt(newSecretLength);\r\n    bb.put(newSecret);\r\n    bb.putInt(currentSecretLength);\r\n    bb.put(currentSecret);\r\n    bb.putInt(previousSecretLength);\r\n    if (previousSecretLength > 0) {\r\n        bb.put(previousSecret);\r\n    }\r\n    bb.putLong(nextRolloverDate);\r\n    return bb.array();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "pullFromZK",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 13,
  "sourceCodeText" : "void pullFromZK(boolean isInit)\n{\r\n    try {\r\n        Stat stat = new Stat();\r\n        byte[] bytes = client.getData().storingStatIn(stat).forPath(path);\r\n        ByteBuffer bb = ByteBuffer.wrap(bytes);\r\n        int dataVersion = bb.getInt();\r\n        if (dataVersion > DATA_VERSION) {\r\n            throw new IllegalStateException(\"Cannot load data from ZooKeeper; it\" + \"was written with a newer version\");\r\n        }\r\n        int nextSecretLength = bb.getInt();\r\n        byte[] nextSecret = new byte[nextSecretLength];\r\n        bb.get(nextSecret);\r\n        this.nextSecret = nextSecret;\r\n        zkVersion = stat.getVersion();\r\n        if (isInit) {\r\n            int currentSecretLength = bb.getInt();\r\n            byte[] currentSecret = new byte[currentSecretLength];\r\n            bb.get(currentSecret);\r\n            int previousSecretLength = bb.getInt();\r\n            byte[] previousSecret = null;\r\n            if (previousSecretLength > 0) {\r\n                previousSecret = new byte[previousSecretLength];\r\n                bb.get(previousSecret);\r\n            }\r\n            super.initSecrets(currentSecret, previousSecret);\r\n            nextRolloverDate = bb.getLong();\r\n        }\r\n    } catch (Exception ex) {\r\n        LOG.error(\"An unexpected exception occurred while pulling data from\" + \"ZooKeeper\", ex);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "generateRandomSecret",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "byte[] generateRandomSecret()\n{\r\n    byte[] secret = new byte[32];\r\n    rand.nextBytes(secret);\r\n    return secret;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "createCuratorClient",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "CuratorFramework createCuratorClient(Properties config) throws Exception\n{\r\n    String connectionString = config.getProperty(ZOOKEEPER_CONNECTION_STRING, \"localhost:2181\");\r\n    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);\r\n    ACLProvider aclProvider;\r\n    String authType = config.getProperty(ZOOKEEPER_AUTH_TYPE, \"none\");\r\n    if (authType.equals(\"sasl\")) {\r\n        LOG.info(\"Connecting to ZooKeeper with SASL/Kerberos\" + \"and using 'sasl' ACLs\");\r\n        String principal = setJaasConfiguration(config);\r\n        System.setProperty(ZKClientConfig.LOGIN_CONTEXT_NAME_KEY, JAAS_LOGIN_ENTRY_NAME);\r\n        System.setProperty(\"zookeeper.authProvider.1\", \"org.apache.zookeeper.server.auth.SASLAuthenticationProvider\");\r\n        aclProvider = new SASLOwnerACLProvider(principal);\r\n    } else {\r\n        LOG.info(\"Connecting to ZooKeeper without authentication\");\r\n        aclProvider = new DefaultACLProvider();\r\n    }\r\n    CuratorFramework cf = CuratorFrameworkFactory.builder().connectString(connectionString).retryPolicy(retryPolicy).aclProvider(aclProvider).build();\r\n    cf.start();\r\n    return cf;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\main\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "setJaasConfiguration",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "String setJaasConfiguration(Properties config) throws Exception\n{\r\n    String keytabFile = config.getProperty(ZOOKEEPER_KERBEROS_KEYTAB).trim();\r\n    if (keytabFile == null || keytabFile.length() == 0) {\r\n        throw new IllegalArgumentException(ZOOKEEPER_KERBEROS_KEYTAB + \" must be specified\");\r\n    }\r\n    String principal = config.getProperty(ZOOKEEPER_KERBEROS_PRINCIPAL).trim();\r\n    if (principal == null || principal.length() == 0) {\r\n        throw new IllegalArgumentException(ZOOKEEPER_KERBEROS_PRINCIPAL + \" must be specified\");\r\n    }\r\n    JaasConfiguration jConf = new JaasConfiguration(JAAS_LOGIN_ENTRY_NAME, principal, keytabFile);\r\n    Configuration.setConfiguration(jConf);\r\n    return principal.split(\"[/@]\")[0];\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
} ]