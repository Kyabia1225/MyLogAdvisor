[ {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testToken",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void testToken() throws Exception\n{\r\n    AuthenticatedURL.Token token = new AuthenticatedURL.Token();\r\n    Assert.assertFalse(token.isSet());\r\n    token = new AuthenticatedURL.Token(\"foo\");\r\n    Assert.assertTrue(token.isSet());\r\n    Assert.assertEquals(\"foo\", token.toString());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testInjectToken",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void testInjectToken() throws Exception\n{\r\n    HttpURLConnection conn = Mockito.mock(HttpURLConnection.class);\r\n    AuthenticatedURL.Token token = new AuthenticatedURL.Token();\r\n    token.set(\"foo\");\r\n    AuthenticatedURL.injectToken(conn, token);\r\n    Mockito.verify(conn).addRequestProperty(Mockito.eq(\"Cookie\"), Mockito.anyString());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testExtractTokenOK",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void testExtractTokenOK() throws Exception\n{\r\n    HttpURLConnection conn = Mockito.mock(HttpURLConnection.class);\r\n    Mockito.when(conn.getResponseCode()).thenReturn(HttpURLConnection.HTTP_OK);\r\n    String tokenStr = \"foo\";\r\n    Map<String, List<String>> headers = new HashMap<String, List<String>>();\r\n    List<String> cookies = new ArrayList<String>();\r\n    cookies.add(AuthenticatedURL.AUTH_COOKIE + \"=\" + tokenStr);\r\n    headers.put(\"Set-Cookie\", cookies);\r\n    Mockito.when(conn.getHeaderFields()).thenReturn(headers);\r\n    AuthenticatedURL.Token token = new AuthenticatedURL.Token();\r\n    AuthenticatedURL.extractToken(conn, token);\r\n    Assert.assertEquals(tokenStr, token.toString());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testExtractTokenFail",
  "errType" : [ "AuthenticationException", "Exception" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void testExtractTokenFail() throws Exception\n{\r\n    HttpURLConnection conn = Mockito.mock(HttpURLConnection.class);\r\n    Mockito.when(conn.getResponseCode()).thenReturn(HttpURLConnection.HTTP_UNAUTHORIZED);\r\n    String tokenStr = \"foo\";\r\n    Map<String, List<String>> headers = new HashMap<String, List<String>>();\r\n    List<String> cookies = new ArrayList<String>();\r\n    cookies.add(AuthenticatedURL.AUTH_COOKIE + \"=\" + tokenStr);\r\n    headers.put(\"Set-Cookie\", cookies);\r\n    Mockito.when(conn.getHeaderFields()).thenReturn(headers);\r\n    AuthenticatedURL.Token token = new AuthenticatedURL.Token();\r\n    token.set(\"bar\");\r\n    try {\r\n        AuthenticatedURL.extractToken(conn, token);\r\n        Assert.fail();\r\n    } catch (AuthenticationException ex) {\r\n        Assert.assertFalse(token.isSet());\r\n    } catch (Exception ex) {\r\n        Assert.fail();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testConnectionConfigurator",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void testConnectionConfigurator() throws Exception\n{\r\n    HttpURLConnection conn = Mockito.mock(HttpURLConnection.class);\r\n    Mockito.when(conn.getResponseCode()).thenReturn(HttpURLConnection.HTTP_UNAUTHORIZED);\r\n    ConnectionConfigurator connConf = Mockito.mock(ConnectionConfigurator.class);\r\n    Mockito.when(connConf.configure(Mockito.<HttpURLConnection>any())).thenReturn(conn);\r\n    Authenticator authenticator = Mockito.mock(Authenticator.class);\r\n    AuthenticatedURL aURL = new AuthenticatedURL(authenticator, connConf);\r\n    aURL.openConnection(new URL(\"http://foo\"), new AuthenticatedURL.Token());\r\n    Mockito.verify(connConf).configure(Mockito.<HttpURLConnection>any());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testGetAuthenticator",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void testGetAuthenticator() throws Exception\n{\r\n    Authenticator authenticator = Mockito.mock(Authenticator.class);\r\n    AuthenticatedURL aURL = new AuthenticatedURL(authenticator);\r\n    Assert.assertEquals(authenticator, aURL.getAuthenticator());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "setup",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void setup() throws Exception\n{\r\n    File keytabFile = new File(KerberosTestUtils.getKeytabFile());\r\n    String clientPrincipal = KerberosTestUtils.getClientPrincipal();\r\n    String serverPrincipal = KerberosTestUtils.getServerPrincipal();\r\n    clientPrincipal = clientPrincipal.substring(0, clientPrincipal.lastIndexOf(\"@\"));\r\n    serverPrincipal = serverPrincipal.substring(0, serverPrincipal.lastIndexOf(\"@\"));\r\n    getKdc().createPrincipal(keytabFile, clientPrincipal, serverPrincipal);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "getAuthenticationHandlerConfiguration",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "Properties getAuthenticationHandlerConfiguration()\n{\r\n    Properties props = new Properties();\r\n    props.setProperty(AuthenticationFilter.AUTH_TYPE, \"kerberos\");\r\n    props.setProperty(KerberosAuthenticationHandler.PRINCIPAL, KerberosTestUtils.getServerPrincipal());\r\n    props.setProperty(KerberosAuthenticationHandler.KEYTAB, KerberosTestUtils.getKeytabFile());\r\n    props.setProperty(KerberosAuthenticationHandler.NAME_RULES, \"RULE:[1:$1@$0](.*@\" + KerberosTestUtils.getRealm() + \")s/@.*//\\n\");\r\n    props.setProperty(KerberosAuthenticationHandler.RULE_MECHANISM, \"hadoop\");\r\n    return props;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "getMultiAuthHandlerConfiguration",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "Properties getMultiAuthHandlerConfiguration()\n{\r\n    Properties props = new Properties();\r\n    props.setProperty(AUTH_TYPE, MultiSchemeAuthenticationHandler.TYPE);\r\n    props.setProperty(SCHEMES_PROPERTY, \"negotiate\");\r\n    props.setProperty(String.format(AUTH_HANDLER_PROPERTY, \"negotiate\"), \"kerberos\");\r\n    props.setProperty(PRINCIPAL, KerberosTestUtils.getServerPrincipal());\r\n    props.setProperty(KEYTAB, KerberosTestUtils.getKeytabFile());\r\n    props.setProperty(NAME_RULES, \"RULE:[1:$1@$0](.*@\" + KerberosTestUtils.getRealm() + \")s/@.*//\\n\");\r\n    return props;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testFallbacktoPseudoAuthenticator",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void testFallbacktoPseudoAuthenticator() throws Exception\n{\r\n    AuthenticatorTestCase auth = new AuthenticatorTestCase();\r\n    Properties props = new Properties();\r\n    props.setProperty(AuthenticationFilter.AUTH_TYPE, \"simple\");\r\n    props.setProperty(PseudoAuthenticationHandler.ANONYMOUS_ALLOWED, \"false\");\r\n    AuthenticatorTestCase.setAuthenticationHandlerConfig(props);\r\n    auth._testAuthentication(new KerberosAuthenticator(), false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testFallbacktoPseudoAuthenticatorAnonymous",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void testFallbacktoPseudoAuthenticatorAnonymous() throws Exception\n{\r\n    AuthenticatorTestCase auth = new AuthenticatorTestCase();\r\n    Properties props = new Properties();\r\n    props.setProperty(AuthenticationFilter.AUTH_TYPE, \"simple\");\r\n    props.setProperty(PseudoAuthenticationHandler.ANONYMOUS_ALLOWED, \"true\");\r\n    AuthenticatorTestCase.setAuthenticationHandlerConfig(props);\r\n    auth._testAuthentication(new KerberosAuthenticator(), false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testNotAuthenticated",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void testNotAuthenticated() throws Exception\n{\r\n    AuthenticatorTestCase auth = new AuthenticatorTestCase();\r\n    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration());\r\n    auth.start();\r\n    try {\r\n        URL url = new URL(auth.getBaseURL());\r\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\r\n        conn.connect();\r\n        Assert.assertEquals(HttpURLConnection.HTTP_UNAUTHORIZED, conn.getResponseCode());\r\n        Assert.assertTrue(conn.getHeaderField(KerberosAuthenticator.WWW_AUTHENTICATE) != null);\r\n    } finally {\r\n        auth.stop();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testAuthentication",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void testAuthentication() throws Exception\n{\r\n    final AuthenticatorTestCase auth = new AuthenticatorTestCase();\r\n    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration());\r\n    KerberosTestUtils.doAsClient(new Callable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            auth._testAuthentication(new KerberosAuthenticator(), false);\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testAuthenticationPost",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void testAuthenticationPost() throws Exception\n{\r\n    final AuthenticatorTestCase auth = new AuthenticatorTestCase();\r\n    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration());\r\n    KerberosTestUtils.doAsClient(new Callable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            auth._testAuthentication(new KerberosAuthenticator(), true);\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testAuthenticationHttpClient",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void testAuthenticationHttpClient() throws Exception\n{\r\n    final AuthenticatorTestCase auth = new AuthenticatorTestCase();\r\n    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration());\r\n    KerberosTestUtils.doAsClient(new Callable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            auth._testAuthenticationHttpClient(new KerberosAuthenticator(), false);\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testAuthenticationHttpClientPost",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void testAuthenticationHttpClientPost() throws Exception\n{\r\n    final AuthenticatorTestCase auth = new AuthenticatorTestCase();\r\n    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration());\r\n    KerberosTestUtils.doAsClient(new Callable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            auth._testAuthenticationHttpClient(new KerberosAuthenticator(), true);\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testNotAuthenticatedWithMultiAuthHandler",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void testNotAuthenticatedWithMultiAuthHandler() throws Exception\n{\r\n    AuthenticatorTestCase auth = new AuthenticatorTestCase();\r\n    AuthenticatorTestCase.setAuthenticationHandlerConfig(getMultiAuthHandlerConfiguration());\r\n    auth.start();\r\n    try {\r\n        URL url = new URL(auth.getBaseURL());\r\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\r\n        conn.connect();\r\n        Assert.assertEquals(HttpURLConnection.HTTP_UNAUTHORIZED, conn.getResponseCode());\r\n        Assert.assertTrue(conn.getHeaderField(KerberosAuthenticator.WWW_AUTHENTICATE) != null);\r\n    } finally {\r\n        auth.stop();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testAuthenticationWithMultiAuthHandler",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void testAuthenticationWithMultiAuthHandler() throws Exception\n{\r\n    final AuthenticatorTestCase auth = new AuthenticatorTestCase();\r\n    AuthenticatorTestCase.setAuthenticationHandlerConfig(getMultiAuthHandlerConfiguration());\r\n    KerberosTestUtils.doAsClient(new Callable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            auth._testAuthentication(new KerberosAuthenticator(), false);\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testAuthenticationHttpClientPostWithMultiAuthHandler",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void testAuthenticationHttpClientPostWithMultiAuthHandler() throws Exception\n{\r\n    final AuthenticatorTestCase auth = new AuthenticatorTestCase();\r\n    AuthenticatorTestCase.setAuthenticationHandlerConfig(getMultiAuthHandlerConfiguration());\r\n    KerberosTestUtils.doAsClient(new Callable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            auth._testAuthenticationHttpClient(new KerberosAuthenticator(), true);\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testWrapExceptionWithMessage",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void testWrapExceptionWithMessage()\n{\r\n    IOException ex;\r\n    ex = new IOException(\"Induced exception\");\r\n    ex = KerberosAuthenticator.wrapExceptionWithMessage(ex, \"Error while \" + \"authenticating with endpoint: localhost\");\r\n    Assert.assertEquals(\"Induced exception\", ex.getCause().getMessage());\r\n    Assert.assertEquals(\"Error while authenticating with endpoint: localhost\", ex.getMessage());\r\n    ex = new AuthenticationException(\"Auth exception\");\r\n    ex = KerberosAuthenticator.wrapExceptionWithMessage(ex, \"Error while \" + \"authenticating with endpoint: localhost\");\r\n    Assert.assertEquals(\"Auth exception\", ex.getCause().getMessage());\r\n    Assert.assertEquals(\"Error while authenticating with endpoint: localhost\", ex.getMessage());\r\n    ex = new CharacterCodingException();\r\n    Exception ex2 = KerberosAuthenticator.wrapExceptionWithMessage(ex, \"Error while authenticating with endpoint: localhost\");\r\n    Assert.assertTrue(ex instanceof CharacterCodingException);\r\n    Assert.assertTrue(ex.equals(ex2));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "init",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void init(Properties config, ServletContext servletContext, long tokenValidity) throws Exception\n{\r\n    String signatureSecret = config.getProperty(AuthenticationFilter.SIGNATURE_SECRET, null);\r\n    secret = signatureSecret.getBytes(Charset.forName(\"UTF-8\"));\r\n    secrets = new byte[][] { secret };\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getCurrentSecret",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "byte[] getCurrentSecret()\n{\r\n    return secret;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getAllSecrets",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "byte[][] getAllSecrets()\n{\r\n    return secrets;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getNewAuthenticationHandler",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "KerberosAuthenticationHandler getNewAuthenticationHandler()\n{\r\n    return new AltKerberosAuthenticationHandler() {\r\n\r\n        @Override\r\n        public AuthenticationToken alternateAuthenticate(HttpServletRequest request, HttpServletResponse response) throws IOException, AuthenticationException {\r\n            return new AuthenticationToken(\"A\", \"B\", getType());\r\n        }\r\n    };\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getExpectedType",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getExpectedType()\n{\r\n    return AltKerberosAuthenticationHandler.TYPE;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testAlternateAuthenticationAsBrowser",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void testAlternateAuthenticationAsBrowser() throws Exception\n{\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    Mockito.when(request.getHeader(\"User-Agent\")).thenReturn(\"Some Browser\");\r\n    AuthenticationToken token = handler.authenticate(request, response);\r\n    Assert.assertEquals(\"A\", token.getUserName());\r\n    Assert.assertEquals(\"B\", token.getName());\r\n    Assert.assertEquals(getExpectedType(), token.getType());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testNonDefaultNonBrowserUserAgentAsBrowser",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 12,
  "sourceCodeText" : "void testNonDefaultNonBrowserUserAgentAsBrowser() throws Exception\n{\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    if (handler != null) {\r\n        handler.destroy();\r\n        handler = null;\r\n    }\r\n    handler = getNewAuthenticationHandler();\r\n    Properties props = getDefaultProperties();\r\n    props.setProperty(\"alt-kerberos.non-browser.user-agents\", \"foo, bar\");\r\n    try {\r\n        handler.init(props);\r\n    } catch (Exception ex) {\r\n        handler = null;\r\n        throw ex;\r\n    }\r\n    Mockito.when(request.getHeader(\"User-Agent\")).thenReturn(\"blah\");\r\n    AuthenticationToken token = handler.authenticate(request, response);\r\n    Assert.assertEquals(\"A\", token.getUserName());\r\n    Assert.assertEquals(\"B\", token.getName());\r\n    Assert.assertEquals(getExpectedType(), token.getType());\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testNonDefaultNonBrowserUserAgentAsNonBrowser",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void testNonDefaultNonBrowserUserAgentAsNonBrowser() throws Exception\n{\r\n    if (handler != null) {\r\n        handler.destroy();\r\n        handler = null;\r\n    }\r\n    handler = getNewAuthenticationHandler();\r\n    Properties props = getDefaultProperties();\r\n    props.setProperty(\"alt-kerberos.non-browser.user-agents\", \"foo, bar\");\r\n    try {\r\n        handler.init(props);\r\n    } catch (Exception ex) {\r\n        handler = null;\r\n        throw ex;\r\n    }\r\n    testRequestWithoutAuthorization();\r\n    testRequestWithInvalidAuthorization();\r\n    testRequestWithAuthorization();\r\n    testRequestWithInvalidKerberosAuthorization();\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "newStringSignerSecretProvider",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "StringSignerSecretProvider newStringSignerSecretProvider() throws Exception\n{\r\n    return new StringSignerSecretProvider();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "setUp",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void setUp() throws Exception\n{\r\n    krbTest.startMiniKdc();\r\n    File keytabFile = new File(KerberosTestUtils.getKeytabFile());\r\n    String clientPrinc = KerberosTestUtils.getClientPrincipal();\r\n    String serverPrinc = KerberosTestUtils.getServerPrincipal();\r\n    clientPrinc = clientPrinc.substring(0, clientPrinc.lastIndexOf(\"@\"));\r\n    serverPrinc = serverPrinc.substring(0, serverPrinc.lastIndexOf(\"@\"));\r\n    krbTest.getKdc().createPrincipal(keytabFile, clientPrinc, serverPrinc);\r\n    handler = new MultiSchemeAuthenticationHandler();\r\n    try {\r\n        handler.init(getDefaultProperties());\r\n    } catch (Exception e) {\r\n        throw e;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "tearDown",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void tearDown() throws Exception\n{\r\n    krbTest.stopMiniKdc();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getDefaultProperties",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "Properties getDefaultProperties()\n{\r\n    Properties p = new Properties();\r\n    p.setProperty(SCHEMES_PROPERTY, BASIC + \",\" + NEGOTIATE);\r\n    p.setProperty(String.format(AUTH_HANDLER_PROPERTY, \"negotiate\"), \"kerberos\");\r\n    p.setProperty(String.format(AUTH_HANDLER_PROPERTY, \"basic\"), \"ldap\");\r\n    p.setProperty(PRINCIPAL, KerberosTestUtils.getServerPrincipal());\r\n    p.setProperty(KEYTAB, KerberosTestUtils.getKeytabFile());\r\n    p.setProperty(NAME_RULES, \"RULE:[1:$1@$0](.*@\" + KerberosTestUtils.getRealm() + \")s/@.*//\\n\");\r\n    p.setProperty(BASE_DN, LDAP_BASE_DN);\r\n    p.setProperty(PROVIDER_URL, String.format(\"ldap://%s:%s\", LDAP_SERVER_ADDR, getLdapServer().getPort()));\r\n    return p;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testRequestWithoutAuthorization",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void testRequestWithoutAuthorization() throws Exception\n{\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    Assert.assertNull(handler.authenticate(request, response));\r\n    Mockito.verify(response).addHeader(WWW_AUTHENTICATE_HEADER, BASIC);\r\n    Mockito.verify(response).addHeader(WWW_AUTHENTICATE_HEADER, NEGOTIATE);\r\n    Mockito.verify(response).setStatus(HttpServletResponse.SC_UNAUTHORIZED);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testRequestWithInvalidAuthorization",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void testRequestWithInvalidAuthorization() throws Exception\n{\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    final Base64 base64 = new Base64(0);\r\n    String credentials = \"bjones:invalidpassword\";\r\n    Mockito.when(request.getHeader(AUTHORIZATION_HEADER)).thenReturn(base64.encodeToString(credentials.getBytes()));\r\n    Assert.assertNull(handler.authenticate(request, response));\r\n    Mockito.verify(response).addHeader(WWW_AUTHENTICATE_HEADER, BASIC);\r\n    Mockito.verify(response).addHeader(WWW_AUTHENTICATE_HEADER, NEGOTIATE);\r\n    Mockito.verify(response).setStatus(HttpServletResponse.SC_UNAUTHORIZED);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testRequestWithLdapAuthorization",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void testRequestWithLdapAuthorization() throws Exception\n{\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    final Base64 base64 = new Base64(0);\r\n    String credentials = base64.encodeToString(\"bjones:p@ssw0rd\".getBytes());\r\n    String authHeader = BASIC + \" \" + credentials;\r\n    Mockito.when(request.getHeader(AUTHORIZATION_HEADER)).thenReturn(authHeader);\r\n    AuthenticationToken token = handler.authenticate(request, response);\r\n    Assert.assertNotNull(token);\r\n    Mockito.verify(response).setStatus(HttpServletResponse.SC_OK);\r\n    Assert.assertEquals(TYPE, token.getType());\r\n    Assert.assertEquals(\"bjones\", token.getUserName());\r\n    Assert.assertEquals(\"bjones\", token.getName());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testRequestWithInvalidKerberosAuthorization",
  "errType" : [ "AuthenticationException", "Exception" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void testRequestWithInvalidKerberosAuthorization() throws Exception\n{\r\n    String token = new Base64(0).encodeToString(new byte[] { 0, 1, 2 });\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    Mockito.when(request.getHeader(AUTHORIZATION_HEADER)).thenReturn(NEGOTIATE + token);\r\n    try {\r\n        handler.authenticate(request, response);\r\n        Assert.fail();\r\n    } catch (AuthenticationException ex) {\r\n    } catch (Exception ex) {\r\n        Assert.fail(\"Wrong exception :\" + ex);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testInit",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void testInit() throws Exception\n{\r\n    PseudoAuthenticationHandler handler = new PseudoAuthenticationHandler();\r\n    try {\r\n        Properties props = new Properties();\r\n        props.setProperty(PseudoAuthenticationHandler.ANONYMOUS_ALLOWED, \"false\");\r\n        handler.init(props);\r\n        Assert.assertEquals(false, handler.getAcceptAnonymous());\r\n    } finally {\r\n        handler.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testType",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testType() throws Exception\n{\r\n    PseudoAuthenticationHandler handler = new PseudoAuthenticationHandler();\r\n    Assert.assertEquals(PseudoAuthenticationHandler.TYPE, handler.getType());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testAnonymousOn",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void testAnonymousOn() throws Exception\n{\r\n    PseudoAuthenticationHandler handler = new PseudoAuthenticationHandler();\r\n    try {\r\n        Properties props = new Properties();\r\n        props.setProperty(PseudoAuthenticationHandler.ANONYMOUS_ALLOWED, \"true\");\r\n        handler.init(props);\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        AuthenticationToken token = handler.authenticate(request, response);\r\n        Assert.assertEquals(AuthenticationToken.ANONYMOUS, token);\r\n    } finally {\r\n        handler.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testAnonymousOff",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void testAnonymousOff() throws Exception\n{\r\n    PseudoAuthenticationHandler handler = new PseudoAuthenticationHandler();\r\n    try {\r\n        Properties props = new Properties();\r\n        props.setProperty(PseudoAuthenticationHandler.ANONYMOUS_ALLOWED, \"false\");\r\n        handler.init(props);\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        AuthenticationToken token = handler.authenticate(request, response);\r\n        Assert.assertNull(token);\r\n    } finally {\r\n        handler.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "_testUserName",
  "errType" : null,
  "containingMethodsNum" : 11,
  "sourceCodeText" : "void _testUserName(boolean anonymous) throws Exception\n{\r\n    PseudoAuthenticationHandler handler = new PseudoAuthenticationHandler();\r\n    try {\r\n        Properties props = new Properties();\r\n        props.setProperty(PseudoAuthenticationHandler.ANONYMOUS_ALLOWED, Boolean.toString(anonymous));\r\n        handler.init(props);\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        Mockito.when(request.getQueryString()).thenReturn(PseudoAuthenticator.USER_NAME + \"=\" + \"user\");\r\n        AuthenticationToken token = handler.authenticate(request, response);\r\n        Assert.assertNotNull(token);\r\n        Assert.assertEquals(\"user\", token.getUserName());\r\n        Assert.assertEquals(\"user\", token.getName());\r\n        Assert.assertEquals(PseudoAuthenticationHandler.TYPE, token.getType());\r\n    } finally {\r\n        handler.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testUserNameAnonymousOff",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testUserNameAnonymousOff() throws Exception\n{\r\n    _testUserName(false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testUserNameAnonymousOn",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testUserNameAnonymousOn() throws Exception\n{\r\n    _testUserName(true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testGetSecrets",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void testGetSecrets() throws Exception\n{\r\n    File testDir = new File(System.getProperty(\"test.build.data\", \"target/test-dir\"));\r\n    testDir.mkdirs();\r\n    String secretValue = \"hadoop\";\r\n    File secretFile = new File(testDir, \"http-secret.txt\");\r\n    Writer writer = new FileWriter(secretFile);\r\n    writer.write(secretValue);\r\n    writer.close();\r\n    FileSignerSecretProvider secretProvider = new FileSignerSecretProvider();\r\n    Properties secretProviderProps = new Properties();\r\n    secretProviderProps.setProperty(AuthenticationFilter.SIGNATURE_SECRET_FILE, secretFile.getAbsolutePath());\r\n    secretProvider.init(secretProviderProps, null, -1);\r\n    Assert.assertArrayEquals(secretValue.getBytes(), secretProvider.getCurrentSecret());\r\n    byte[][] allSecrets = secretProvider.getAllSecrets();\r\n    Assert.assertEquals(1, allSecrets.length);\r\n    Assert.assertArrayEquals(secretValue.getBytes(), allSecrets[0]);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testEmptySecretFileThrows",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void testEmptySecretFileThrows() throws Exception\n{\r\n    File secretFile = File.createTempFile(\"test_empty_secret\", \".txt\");\r\n    assertTrue(secretFile.exists());\r\n    FileSignerSecretProvider secretProvider = new FileSignerSecretProvider();\r\n    Properties secretProviderProps = new Properties();\r\n    secretProviderProps.setProperty(AuthenticationFilter.SIGNATURE_SECRET_FILE, secretFile.getAbsolutePath());\r\n    Exception exception = assertThrows(RuntimeException.class, new ThrowingRunnable() {\r\n\r\n        @Override\r\n        public void run() throws Throwable {\r\n            secretProvider.init(secretProviderProps, null, -1);\r\n        }\r\n    });\r\n    assertTrue(exception.getMessage().startsWith(\"No secret in signature secret file:\"));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "setAuthenticationHandlerConfig",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void setAuthenticationHandlerConfig(Properties config)\n{\r\n    authenticatorConfig = config;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "getLocalPort",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "int getLocalPort() throws Exception\n{\r\n    ServerSocket ss = new ServerSocket(0);\r\n    int ret = ss.getLocalPort();\r\n    ss.close();\r\n    return ret;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "start",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void start() throws Exception\n{\r\n    startJetty();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "startJetty",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void startJetty() throws Exception\n{\r\n    server = new Server();\r\n    context = new ServletContextHandler();\r\n    context.setContextPath(\"/foo\");\r\n    server.setHandler(context);\r\n    context.addFilter(new FilterHolder(TestFilter.class), \"/*\", EnumSet.of(DispatcherType.REQUEST));\r\n    context.addServlet(new ServletHolder(TestServlet.class), \"/bar\");\r\n    host = \"localhost\";\r\n    port = getLocalPort();\r\n    ServerConnector connector = new ServerConnector(server);\r\n    connector.setHost(host);\r\n    connector.setPort(port);\r\n    server.setConnectors(new Connector[] { connector });\r\n    server.start();\r\n    System.out.println(\"Running embedded servlet container at: http://\" + host + \":\" + port);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "stop",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void stop() throws Exception\n{\r\n    stopJetty();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "stopJetty",
  "errType" : [ "Exception", "Exception" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void stopJetty() throws Exception\n{\r\n    try {\r\n        server.stop();\r\n    } catch (Exception e) {\r\n    }\r\n    try {\r\n        server.destroy();\r\n    } catch (Exception e) {\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "getBaseURL",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getBaseURL()\n{\r\n    return \"http://\" + host + \":\" + port + \"/foo/bar\";\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "_testAuthentication",
  "errType" : null,
  "containingMethodsNum" : 22,
  "sourceCodeText" : "void _testAuthentication(Authenticator authenticator, boolean doPost) throws Exception\n{\r\n    start();\r\n    try {\r\n        URL url = new URL(getBaseURL());\r\n        AuthenticatedURL.Token token = new AuthenticatedURL.Token();\r\n        Assert.assertFalse(token.isSet());\r\n        TestConnectionConfigurator connConf = new TestConnectionConfigurator();\r\n        AuthenticatedURL aUrl = new AuthenticatedURL(authenticator, connConf);\r\n        HttpURLConnection conn = aUrl.openConnection(url, token);\r\n        Assert.assertTrue(connConf.invoked);\r\n        String tokenStr = token.toString();\r\n        if (doPost) {\r\n            conn.setRequestMethod(\"POST\");\r\n            conn.setDoOutput(true);\r\n        }\r\n        conn.connect();\r\n        if (doPost) {\r\n            Writer writer = new OutputStreamWriter(conn.getOutputStream());\r\n            writer.write(POST);\r\n            writer.close();\r\n        }\r\n        Assert.assertEquals(HttpURLConnection.HTTP_OK, conn.getResponseCode());\r\n        if (doPost) {\r\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\r\n            String echo = reader.readLine();\r\n            Assert.assertEquals(POST, echo);\r\n            Assert.assertNull(reader.readLine());\r\n        }\r\n        aUrl = new AuthenticatedURL();\r\n        conn = aUrl.openConnection(url, token);\r\n        conn.connect();\r\n        Assert.assertEquals(HttpURLConnection.HTTP_OK, conn.getResponseCode());\r\n        Assert.assertEquals(tokenStr, token.toString());\r\n    } finally {\r\n        stop();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "getHttpClient",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "HttpClient getHttpClient()\n{\r\n    HttpClientBuilder builder = HttpClientBuilder.create();\r\n    builder.setDefaultAuthSchemeRegistry(s -> httpContext -> new SPNegoScheme(true, true));\r\n    Credentials useJaasCreds = new Credentials() {\r\n\r\n        public String getPassword() {\r\n            return null;\r\n        }\r\n\r\n        public Principal getUserPrincipal() {\r\n            return null;\r\n        }\r\n    };\r\n    CredentialsProvider jaasCredentialProvider = new BasicCredentialsProvider();\r\n    jaasCredentialProvider.setCredentials(AuthScope.ANY, useJaasCreds);\r\n    builder.setDefaultCredentialsProvider(jaasCredentialProvider);\r\n    return builder.build();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "doHttpClientRequest",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void doHttpClientRequest(HttpClient httpClient, HttpUriRequest request) throws Exception\n{\r\n    HttpResponse response = null;\r\n    try {\r\n        response = httpClient.execute(request);\r\n        final int httpStatus = response.getStatusLine().getStatusCode();\r\n        Assert.assertEquals(HttpURLConnection.HTTP_OK, httpStatus);\r\n    } finally {\r\n        if (response != null)\r\n            EntityUtils.consumeQuietly(response.getEntity());\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "_testAuthenticationHttpClient",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void _testAuthenticationHttpClient(Authenticator authenticator, boolean doPost) throws Exception\n{\r\n    start();\r\n    try {\r\n        HttpClient httpClient = getHttpClient();\r\n        doHttpClientRequest(httpClient, new HttpGet(getBaseURL()));\r\n        if (doPost) {\r\n            HttpPost post = new HttpPost(getBaseURL());\r\n            byte[] postBytes = POST.getBytes();\r\n            ByteArrayInputStream bis = new ByteArrayInputStream(postBytes);\r\n            InputStreamEntity entity = new InputStreamEntity(bis, postBytes.length);\r\n            Assert.assertFalse(entity.isRepeatable());\r\n            post.setEntity(entity);\r\n            doHttpClientRequest(httpClient, post);\r\n        }\r\n    } finally {\r\n        stop();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testAnonymous",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void testAnonymous()\n{\r\n    Assert.assertNotNull(AuthenticationToken.ANONYMOUS);\r\n    Assert.assertEquals(null, AuthenticationToken.ANONYMOUS.getUserName());\r\n    Assert.assertEquals(null, AuthenticationToken.ANONYMOUS.getName());\r\n    Assert.assertEquals(null, AuthenticationToken.ANONYMOUS.getType());\r\n    Assert.assertEquals(-1, AuthenticationToken.ANONYMOUS.getExpires());\r\n    Assert.assertFalse(AuthenticationToken.ANONYMOUS.isExpired());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testNullAndEmptyString",
  "errType" : [ "IllegalArgumentException", "Throwable", "IllegalArgumentException", "Throwable" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void testNullAndEmptyString() throws Exception\n{\r\n    Signer signer = new Signer(createStringSignerSecretProvider());\r\n    try {\r\n        signer.sign(null);\r\n        Assert.fail();\r\n    } catch (IllegalArgumentException ex) {\r\n    } catch (Throwable ex) {\r\n        Assert.fail();\r\n    }\r\n    try {\r\n        signer.sign(\"\");\r\n        Assert.fail();\r\n    } catch (IllegalArgumentException ex) {\r\n    } catch (Throwable ex) {\r\n        Assert.fail();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testSignature",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void testSignature() throws Exception\n{\r\n    Signer signer = new Signer(createStringSignerSecretProvider());\r\n    String s1 = signer.sign(\"ok\");\r\n    String s2 = signer.sign(\"ok\");\r\n    String s3 = signer.sign(\"wrong\");\r\n    Assert.assertEquals(s1, s2);\r\n    Assert.assertNotEquals(s1, s3);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testVerify",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void testVerify() throws Exception\n{\r\n    Signer signer = new Signer(createStringSignerSecretProvider());\r\n    String t = \"test\";\r\n    String s = signer.sign(t);\r\n    String e = signer.verifyAndExtract(s);\r\n    Assert.assertEquals(t, e);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testInvalidSignedText",
  "errType" : [ "SignerException", "Throwable" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void testInvalidSignedText() throws Exception\n{\r\n    Signer signer = new Signer(createStringSignerSecretProvider());\r\n    try {\r\n        signer.verifyAndExtract(\"test\");\r\n        Assert.fail();\r\n    } catch (SignerException ex) {\r\n    } catch (Throwable ex) {\r\n        Assert.fail();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testTampering",
  "errType" : [ "SignerException", "Throwable" ],
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void testTampering() throws Exception\n{\r\n    Signer signer = new Signer(createStringSignerSecretProvider());\r\n    String t = \"test\";\r\n    String s = signer.sign(t);\r\n    s += \"x\";\r\n    try {\r\n        signer.verifyAndExtract(s);\r\n        Assert.fail();\r\n    } catch (SignerException ex) {\r\n    } catch (Throwable ex) {\r\n        Assert.fail();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "createStringSignerSecretProvider",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "StringSignerSecretProvider createStringSignerSecretProvider() throws Exception\n{\r\n    StringSignerSecretProvider secretProvider = new StringSignerSecretProvider();\r\n    Properties secretProviderProps = new Properties();\r\n    secretProviderProps.setProperty(AuthenticationFilter.SIGNATURE_SECRET, \"secret\");\r\n    secretProvider.init(secretProviderProps, null, -1);\r\n    return secretProvider;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testMultipleSecrets",
  "errType" : [ "SignerException" ],
  "containingMethodsNum" : 21,
  "sourceCodeText" : "void testMultipleSecrets() throws Exception\n{\r\n    TestSignerSecretProvider secretProvider = new TestSignerSecretProvider();\r\n    Signer signer = new Signer(secretProvider);\r\n    secretProvider.setCurrentSecret(\"secretB\");\r\n    String t1 = \"test\";\r\n    String s1 = signer.sign(t1);\r\n    String e1 = signer.verifyAndExtract(s1);\r\n    Assert.assertEquals(t1, e1);\r\n    secretProvider.setPreviousSecret(\"secretA\");\r\n    String t2 = \"test\";\r\n    String s2 = signer.sign(t2);\r\n    String e2 = signer.verifyAndExtract(s2);\r\n    Assert.assertEquals(t2, e2);\r\n    Assert.assertEquals(s1, s2);\r\n    secretProvider.setCurrentSecret(\"secretC\");\r\n    secretProvider.setPreviousSecret(\"secretB\");\r\n    String t3 = \"test\";\r\n    String s3 = signer.sign(t3);\r\n    String e3 = signer.verifyAndExtract(s3);\r\n    Assert.assertEquals(t3, e3);\r\n    Assert.assertNotEquals(s1, s3);\r\n    String e1b = signer.verifyAndExtract(s1);\r\n    Assert.assertEquals(t1, e1b);\r\n    secretProvider.setCurrentSecret(\"secretD\");\r\n    secretProvider.setPreviousSecret(\"secretC\");\r\n    try {\r\n        signer.verifyAndExtract(s1);\r\n        Assert.fail();\r\n    } catch (SignerException ex) {\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "getAuthenticationHandlerConfiguration",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "Properties getAuthenticationHandlerConfiguration(boolean anonymousAllowed)\n{\r\n    Properties props = new Properties();\r\n    props.setProperty(AuthenticationFilter.AUTH_TYPE, \"simple\");\r\n    props.setProperty(PseudoAuthenticationHandler.ANONYMOUS_ALLOWED, Boolean.toString(anonymousAllowed));\r\n    return props;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testGetUserName",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testGetUserName() throws Exception\n{\r\n    PseudoAuthenticator authenticator = new PseudoAuthenticator();\r\n    Assert.assertEquals(System.getProperty(\"user.name\"), authenticator.getUserName());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testAnonymousAllowed",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void testAnonymousAllowed() throws Exception\n{\r\n    AuthenticatorTestCase auth = new AuthenticatorTestCase();\r\n    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration(true));\r\n    auth.start();\r\n    try {\r\n        URL url = new URL(auth.getBaseURL());\r\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\r\n        conn.connect();\r\n        Assert.assertEquals(HttpURLConnection.HTTP_OK, conn.getResponseCode());\r\n    } finally {\r\n        auth.stop();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testAnonymousDisallowed",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void testAnonymousDisallowed() throws Exception\n{\r\n    AuthenticatorTestCase auth = new AuthenticatorTestCase();\r\n    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration(false));\r\n    auth.start();\r\n    try {\r\n        URL url = new URL(auth.getBaseURL());\r\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\r\n        conn.connect();\r\n        Assert.assertEquals(HttpURLConnection.HTTP_UNAUTHORIZED, conn.getResponseCode());\r\n        Assert.assertTrue(conn.getHeaderFields().containsKey(\"WWW-Authenticate\"));\r\n        Assert.assertEquals(\"Authentication required\", conn.getResponseMessage());\r\n    } finally {\r\n        auth.stop();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testAuthenticationAnonymousAllowed",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void testAuthenticationAnonymousAllowed() throws Exception\n{\r\n    AuthenticatorTestCase auth = new AuthenticatorTestCase();\r\n    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration(true));\r\n    auth._testAuthentication(new PseudoAuthenticator(), false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testAuthenticationAnonymousDisallowed",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void testAuthenticationAnonymousDisallowed() throws Exception\n{\r\n    AuthenticatorTestCase auth = new AuthenticatorTestCase();\r\n    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration(false));\r\n    auth._testAuthentication(new PseudoAuthenticator(), false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testAuthenticationAnonymousAllowedWithPost",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void testAuthenticationAnonymousAllowedWithPost() throws Exception\n{\r\n    AuthenticatorTestCase auth = new AuthenticatorTestCase();\r\n    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration(true));\r\n    auth._testAuthentication(new PseudoAuthenticator(), true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\client",
  "methodName" : "testAuthenticationAnonymousDisallowedWithPost",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void testAuthenticationAnonymousDisallowedWithPost() throws Exception\n{\r\n    AuthenticatorTestCase auth = new AuthenticatorTestCase();\r\n    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration(false));\r\n    auth._testAuthentication(new PseudoAuthenticator(), true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "setup",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void setup() throws Exception\n{\r\n    zkServer = new TestingServer();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "teardown",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void teardown() throws Exception\n{\r\n    if (zkServer != null) {\r\n        zkServer.stop();\r\n        zkServer.close();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testOne",
  "errType" : null,
  "containingMethodsNum" : 33,
  "sourceCodeText" : "void testOne() throws Exception\n{\r\n    long seed = System.currentTimeMillis();\r\n    Random rand = new Random(seed);\r\n    byte[] secret2 = generateNewSecret(rand);\r\n    byte[] secret1 = generateNewSecret(rand);\r\n    byte[] secret3 = generateNewSecret(rand);\r\n    MockZKSignerSecretProvider secretProvider = spy(new MockZKSignerSecretProvider(seed));\r\n    Properties config = new Properties();\r\n    config.setProperty(ZKSignerSecretProvider.ZOOKEEPER_CONNECTION_STRING, zkServer.getConnectString());\r\n    config.setProperty(ZKSignerSecretProvider.ZOOKEEPER_PATH, \"/secret\");\r\n    try {\r\n        secretProvider.init(config, getDummyServletContext(), rolloverFrequency);\r\n        byte[] currentSecret = secretProvider.getCurrentSecret();\r\n        byte[][] allSecrets = secretProvider.getAllSecrets();\r\n        Assert.assertArrayEquals(secret1, currentSecret);\r\n        Assert.assertEquals(2, allSecrets.length);\r\n        Assert.assertArrayEquals(secret1, allSecrets[0]);\r\n        Assert.assertNull(allSecrets[1]);\r\n        verify(secretProvider, timeout(timeout).atLeastOnce()).rollSecret();\r\n        secretProvider.realRollSecret();\r\n        currentSecret = secretProvider.getCurrentSecret();\r\n        allSecrets = secretProvider.getAllSecrets();\r\n        Assert.assertArrayEquals(secret2, currentSecret);\r\n        Assert.assertEquals(2, allSecrets.length);\r\n        Assert.assertArrayEquals(secret2, allSecrets[0]);\r\n        Assert.assertArrayEquals(secret1, allSecrets[1]);\r\n        verify(secretProvider, timeout(timeout).atLeast(2)).rollSecret();\r\n        secretProvider.realRollSecret();\r\n        currentSecret = secretProvider.getCurrentSecret();\r\n        allSecrets = secretProvider.getAllSecrets();\r\n        Assert.assertArrayEquals(secret3, currentSecret);\r\n        Assert.assertEquals(2, allSecrets.length);\r\n        Assert.assertArrayEquals(secret3, allSecrets[0]);\r\n        Assert.assertArrayEquals(secret2, allSecrets[1]);\r\n        verify(secretProvider, timeout(timeout).atLeast(3)).rollSecret();\r\n        secretProvider.realRollSecret();\r\n    } finally {\r\n        secretProvider.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testUpgradeChangeSecretLength",
  "errType" : null,
  "containingMethodsNum" : 56,
  "sourceCodeText" : "void testUpgradeChangeSecretLength() throws Exception\n{\r\n    long seed = System.currentTimeMillis();\r\n    Random rand = new Random(seed);\r\n    byte[] secret2 = Long.toString(rand.nextLong()).getBytes(Charset.forName(\"UTF-8\"));\r\n    byte[] secret1 = Long.toString(rand.nextLong()).getBytes(Charset.forName(\"UTF-8\"));\r\n    byte[] secret3 = Long.toString(rand.nextLong()).getBytes(Charset.forName(\"UTF-8\"));\r\n    rand = new Random(seed);\r\n    byte[] secret4 = generateNewSecret(rand);\r\n    byte[] secret5 = generateNewSecret(rand);\r\n    byte[] secret6 = generateNewSecret(rand);\r\n    byte[] secret7 = generateNewSecret(rand);\r\n    MockZKSignerSecretProvider oldSecretProvider = spy(new OldMockZKSignerSecretProvider(seed));\r\n    Properties config = new Properties();\r\n    config.setProperty(ZKSignerSecretProvider.ZOOKEEPER_CONNECTION_STRING, zkServer.getConnectString());\r\n    config.setProperty(ZKSignerSecretProvider.ZOOKEEPER_PATH, \"/secret\");\r\n    try {\r\n        oldSecretProvider.init(config, getDummyServletContext(), rolloverFrequency);\r\n        byte[] currentSecret = oldSecretProvider.getCurrentSecret();\r\n        byte[][] allSecrets = oldSecretProvider.getAllSecrets();\r\n        Assert.assertArrayEquals(secret1, currentSecret);\r\n        Assert.assertEquals(2, allSecrets.length);\r\n        Assert.assertArrayEquals(secret1, allSecrets[0]);\r\n        Assert.assertNull(allSecrets[1]);\r\n        oldSecretProvider.realRollSecret();\r\n        currentSecret = oldSecretProvider.getCurrentSecret();\r\n        allSecrets = oldSecretProvider.getAllSecrets();\r\n        Assert.assertArrayEquals(secret2, currentSecret);\r\n        Assert.assertEquals(2, allSecrets.length);\r\n        Assert.assertArrayEquals(secret2, allSecrets[0]);\r\n        Assert.assertArrayEquals(secret1, allSecrets[1]);\r\n    } finally {\r\n        oldSecretProvider.destroy();\r\n    }\r\n    MockZKSignerSecretProvider newSecretProvider = spy(new MockZKSignerSecretProvider(seed));\r\n    try {\r\n        newSecretProvider.init(config, getDummyServletContext(), rolloverFrequency);\r\n        byte[] currentSecret = newSecretProvider.getCurrentSecret();\r\n        byte[][] allSecrets = newSecretProvider.getAllSecrets();\r\n        Assert.assertArrayEquals(secret2, currentSecret);\r\n        Assert.assertEquals(2, allSecrets.length);\r\n        Assert.assertArrayEquals(secret2, allSecrets[0]);\r\n        Assert.assertArrayEquals(secret1, allSecrets[1]);\r\n        newSecretProvider.realRollSecret();\r\n        currentSecret = newSecretProvider.getCurrentSecret();\r\n        allSecrets = newSecretProvider.getAllSecrets();\r\n        Assert.assertArrayEquals(secret3, currentSecret);\r\n        Assert.assertEquals(2, allSecrets.length);\r\n        Assert.assertArrayEquals(secret3, allSecrets[0]);\r\n        Assert.assertArrayEquals(secret2, allSecrets[1]);\r\n        newSecretProvider.realRollSecret();\r\n        currentSecret = newSecretProvider.getCurrentSecret();\r\n        allSecrets = newSecretProvider.getAllSecrets();\r\n        Assert.assertArrayEquals(secret6, currentSecret);\r\n        Assert.assertEquals(2, allSecrets.length);\r\n        Assert.assertArrayEquals(secret6, allSecrets[0]);\r\n        Assert.assertArrayEquals(secret3, allSecrets[1]);\r\n        newSecretProvider.realRollSecret();\r\n        currentSecret = newSecretProvider.getCurrentSecret();\r\n        allSecrets = newSecretProvider.getAllSecrets();\r\n        Assert.assertArrayEquals(secret7, currentSecret);\r\n        Assert.assertEquals(2, allSecrets.length);\r\n        Assert.assertArrayEquals(secret7, allSecrets[0]);\r\n        Assert.assertArrayEquals(secret6, allSecrets[1]);\r\n    } finally {\r\n        newSecretProvider.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testMultiple1",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testMultiple1() throws Exception\n{\r\n    testMultiple(1);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testMultiple2",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testMultiple2() throws Exception\n{\r\n    testMultiple(2);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testMultiple",
  "errType" : null,
  "containingMethodsNum" : 68,
  "sourceCodeText" : "void testMultiple(int order) throws Exception\n{\r\n    long seedA = System.currentTimeMillis();\r\n    Random rand = new Random(seedA);\r\n    byte[] secretA2 = generateNewSecret(rand);\r\n    byte[] secretA1 = generateNewSecret(rand);\r\n    byte[] secretA3 = generateNewSecret(rand);\r\n    byte[] secretA4 = generateNewSecret(rand);\r\n    long seedB = System.currentTimeMillis() + rand.nextLong();\r\n    rand = new Random(seedB);\r\n    byte[] secretB2 = generateNewSecret(rand);\r\n    byte[] secretB1 = generateNewSecret(rand);\r\n    byte[] secretB3 = generateNewSecret(rand);\r\n    byte[] secretB4 = generateNewSecret(rand);\r\n    MockZKSignerSecretProvider secretProviderA = spy(new MockZKSignerSecretProvider(seedA));\r\n    MockZKSignerSecretProvider secretProviderB = spy(new MockZKSignerSecretProvider(seedB));\r\n    Properties config = new Properties();\r\n    config.setProperty(ZKSignerSecretProvider.ZOOKEEPER_CONNECTION_STRING, zkServer.getConnectString());\r\n    config.setProperty(ZKSignerSecretProvider.ZOOKEEPER_PATH, \"/secret\");\r\n    try {\r\n        secretProviderA.init(config, getDummyServletContext(), rolloverFrequency);\r\n        secretProviderB.init(config, getDummyServletContext(), rolloverFrequency);\r\n        byte[] currentSecretA = secretProviderA.getCurrentSecret();\r\n        byte[][] allSecretsA = secretProviderA.getAllSecrets();\r\n        byte[] currentSecretB = secretProviderB.getCurrentSecret();\r\n        byte[][] allSecretsB = secretProviderB.getAllSecrets();\r\n        Assert.assertArrayEquals(secretA1, currentSecretA);\r\n        Assert.assertArrayEquals(secretA1, currentSecretB);\r\n        Assert.assertEquals(2, allSecretsA.length);\r\n        Assert.assertEquals(2, allSecretsB.length);\r\n        Assert.assertArrayEquals(secretA1, allSecretsA[0]);\r\n        Assert.assertArrayEquals(secretA1, allSecretsB[0]);\r\n        Assert.assertNull(allSecretsA[1]);\r\n        Assert.assertNull(allSecretsB[1]);\r\n        verify(secretProviderA, timeout(timeout).atLeastOnce()).rollSecret();\r\n        verify(secretProviderB, timeout(timeout).atLeastOnce()).rollSecret();\r\n        secretProviderA.realRollSecret();\r\n        secretProviderB.realRollSecret();\r\n        currentSecretA = secretProviderA.getCurrentSecret();\r\n        allSecretsA = secretProviderA.getAllSecrets();\r\n        Assert.assertArrayEquals(secretA2, currentSecretA);\r\n        Assert.assertEquals(2, allSecretsA.length);\r\n        Assert.assertArrayEquals(secretA2, allSecretsA[0]);\r\n        Assert.assertArrayEquals(secretA1, allSecretsA[1]);\r\n        currentSecretB = secretProviderB.getCurrentSecret();\r\n        allSecretsB = secretProviderB.getAllSecrets();\r\n        Assert.assertArrayEquals(secretA2, currentSecretB);\r\n        Assert.assertEquals(2, allSecretsA.length);\r\n        Assert.assertArrayEquals(secretA2, allSecretsB[0]);\r\n        Assert.assertArrayEquals(secretA1, allSecretsB[1]);\r\n        verify(secretProviderA, timeout(timeout).atLeast(2)).rollSecret();\r\n        verify(secretProviderB, timeout(timeout).atLeastOnce()).rollSecret();\r\n        switch(order) {\r\n            case 1:\r\n                secretProviderA.realRollSecret();\r\n                secretProviderB.realRollSecret();\r\n                secretProviderA.realRollSecret();\r\n                secretProviderB.realRollSecret();\r\n                break;\r\n            case 2:\r\n                secretProviderB.realRollSecret();\r\n                secretProviderA.realRollSecret();\r\n                secretProviderB.realRollSecret();\r\n                secretProviderA.realRollSecret();\r\n                break;\r\n            default:\r\n                throw new Exception(\"Invalid order selected\");\r\n        }\r\n        currentSecretA = secretProviderA.getCurrentSecret();\r\n        allSecretsA = secretProviderA.getAllSecrets();\r\n        currentSecretB = secretProviderB.getCurrentSecret();\r\n        allSecretsB = secretProviderB.getAllSecrets();\r\n        Assert.assertArrayEquals(currentSecretA, currentSecretB);\r\n        Assert.assertEquals(2, allSecretsA.length);\r\n        Assert.assertEquals(2, allSecretsB.length);\r\n        Assert.assertArrayEquals(allSecretsA[0], allSecretsB[0]);\r\n        Assert.assertArrayEquals(allSecretsA[1], allSecretsB[1]);\r\n        switch(order) {\r\n            case 1:\r\n                Assert.assertArrayEquals(secretA4, allSecretsA[0]);\r\n                break;\r\n            case 2:\r\n                Assert.assertArrayEquals(secretB4, allSecretsA[0]);\r\n                break;\r\n        }\r\n    } finally {\r\n        secretProviderB.destroy();\r\n        secretProviderA.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getDummyServletContext",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "ServletContext getDummyServletContext()\n{\r\n    ServletContext servletContext = mock(ServletContext.class);\r\n    when(servletContext.getAttribute(ZKSignerSecretProvider.ZOOKEEPER_SIGNER_SECRET_PROVIDER_CURATOR_CLIENT_ATTRIBUTE)).thenReturn(null);\r\n    return servletContext;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "generateNewSecret",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "byte[] generateNewSecret(Random rand)\n{\r\n    byte[] secret = new byte[32];\r\n    rand.nextBytes(secret);\r\n    return secret;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "setup",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void setup() throws Exception\n{\r\n    handler = new LdapAuthenticationHandler();\r\n    try {\r\n        handler.init(getDefaultProperties());\r\n    } catch (Exception e) {\r\n        handler = null;\r\n        throw e;\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getDefaultProperties",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "Properties getDefaultProperties()\n{\r\n    Properties p = new Properties();\r\n    p.setProperty(BASE_DN, LDAP_BASE_DN);\r\n    p.setProperty(PROVIDER_URL, String.format(\"ldap://%s:%s\", LDAP_SERVER_ADDR, getLdapServer().getPort()));\r\n    return p;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testRequestWithoutAuthorization",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void testRequestWithoutAuthorization() throws Exception\n{\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    Assert.assertNull(handler.authenticate(request, response));\r\n    Mockito.verify(response).setHeader(WWW_AUTHENTICATE, HttpConstants.BASIC);\r\n    Mockito.verify(response).setStatus(HttpServletResponse.SC_UNAUTHORIZED);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testRequestWithInvalidAuthorization",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void testRequestWithInvalidAuthorization() throws Exception\n{\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    final Base64 base64 = new Base64(0);\r\n    String credentials = \"bjones:invalidpassword\";\r\n    Mockito.when(request.getHeader(HttpConstants.AUTHORIZATION_HEADER)).thenReturn(base64.encodeToString(credentials.getBytes()));\r\n    Assert.assertNull(handler.authenticate(request, response));\r\n    Mockito.verify(response).setHeader(WWW_AUTHENTICATE, HttpConstants.BASIC);\r\n    Mockito.verify(response).setStatus(HttpServletResponse.SC_UNAUTHORIZED);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testRequestWithIncompleteAuthorization",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void testRequestWithIncompleteAuthorization() throws Exception\n{\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    Mockito.when(request.getHeader(HttpConstants.AUTHORIZATION_HEADER)).thenReturn(HttpConstants.BASIC);\r\n    Assert.assertNull(handler.authenticate(request, response));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testRequestWithAuthorization",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void testRequestWithAuthorization() throws Exception\n{\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    final Base64 base64 = new Base64(0);\r\n    String credentials = base64.encodeToString(\"bjones:p@ssw0rd\".getBytes());\r\n    String authHeader = HttpConstants.BASIC + \" \" + credentials;\r\n    Mockito.when(request.getHeader(HttpConstants.AUTHORIZATION_HEADER)).thenReturn(authHeader);\r\n    AuthenticationToken token = handler.authenticate(request, response);\r\n    Assert.assertNotNull(token);\r\n    Mockito.verify(response).setStatus(HttpServletResponse.SC_OK);\r\n    Assert.assertEquals(TYPE, token.getType());\r\n    Assert.assertEquals(\"bjones\", token.getUserName());\r\n    Assert.assertEquals(\"bjones\", token.getName());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testRequestWithWrongCredentials",
  "errType" : [ "AuthenticationException", "Exception" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void testRequestWithWrongCredentials() throws Exception\n{\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    final Base64 base64 = new Base64(0);\r\n    String credentials = base64.encodeToString(\"bjones:foo123\".getBytes());\r\n    String authHeader = HttpConstants.BASIC + \" \" + credentials;\r\n    Mockito.when(request.getHeader(HttpConstants.AUTHORIZATION_HEADER)).thenReturn(authHeader);\r\n    try {\r\n        handler.authenticate(request, response);\r\n        Assert.fail();\r\n    } catch (AuthenticationException ex) {\r\n    } catch (Exception ex) {\r\n        Assert.fail();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testGetAndRollSecrets",
  "errType" : null,
  "containingMethodsNum" : 31,
  "sourceCodeText" : "void testGetAndRollSecrets() throws Exception\n{\r\n    long seed = System.currentTimeMillis();\r\n    Random rand = new Random(seed);\r\n    byte[] secret1 = generateNewSecret(rand);\r\n    byte[] secret2 = generateNewSecret(rand);\r\n    byte[] secret3 = generateNewSecret(rand);\r\n    MockRandomSignerSecretProvider secretProvider = spy(new MockRandomSignerSecretProvider(seed));\r\n    try {\r\n        secretProvider.init(null, null, rolloverFrequency);\r\n        byte[] currentSecret = secretProvider.getCurrentSecret();\r\n        byte[][] allSecrets = secretProvider.getAllSecrets();\r\n        Assert.assertArrayEquals(secret1, currentSecret);\r\n        Assert.assertEquals(2, allSecrets.length);\r\n        Assert.assertArrayEquals(secret1, allSecrets[0]);\r\n        Assert.assertNull(allSecrets[1]);\r\n        verify(secretProvider, timeout(timeout).atLeastOnce()).rollSecret();\r\n        secretProvider.realRollSecret();\r\n        currentSecret = secretProvider.getCurrentSecret();\r\n        allSecrets = secretProvider.getAllSecrets();\r\n        Assert.assertArrayEquals(secret2, currentSecret);\r\n        Assert.assertEquals(2, allSecrets.length);\r\n        Assert.assertArrayEquals(secret2, allSecrets[0]);\r\n        Assert.assertArrayEquals(secret1, allSecrets[1]);\r\n        verify(secretProvider, timeout(timeout).atLeast(2)).rollSecret();\r\n        secretProvider.realRollSecret();\r\n        currentSecret = secretProvider.getCurrentSecret();\r\n        allSecrets = secretProvider.getAllSecrets();\r\n        Assert.assertArrayEquals(secret3, currentSecret);\r\n        Assert.assertEquals(2, allSecrets.length);\r\n        Assert.assertArrayEquals(secret3, allSecrets[0]);\r\n        Assert.assertArrayEquals(secret2, allSecrets[1]);\r\n        verify(secretProvider, timeout(timeout).atLeast(3)).rollSecret();\r\n        secretProvider.realRollSecret();\r\n    } finally {\r\n        secretProvider.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "generateNewSecret",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "byte[] generateNewSecret(Random rand)\n{\r\n    byte[] secret = new byte[32];\r\n    rand.nextBytes(secret);\r\n    return secret;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getNewAuthenticationHandler",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "KerberosAuthenticationHandler getNewAuthenticationHandler()\n{\r\n    return new KerberosAuthenticationHandler();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getExpectedType",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getExpectedType()\n{\r\n    return KerberosAuthenticationHandler.TYPE;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getDefaultProperties",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "Properties getDefaultProperties()\n{\r\n    Properties props = new Properties();\r\n    props.setProperty(KerberosAuthenticationHandler.PRINCIPAL, KerberosTestUtils.getServerPrincipal());\r\n    props.setProperty(KerberosAuthenticationHandler.KEYTAB, KerberosTestUtils.getKeytabFile());\r\n    props.setProperty(KerberosAuthenticationHandler.NAME_RULES, \"RULE:[1:$1@$0](.*@\" + KerberosTestUtils.getRealm() + \")s/@.*//\\n\");\r\n    props.setProperty(KerberosAuthenticationHandler.RULE_MECHANISM, KerberosName.MECHANISM_HADOOP);\r\n    return props;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "setup",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void setup() throws Exception\n{\r\n    File keytabFile = new File(KerberosTestUtils.getKeytabFile());\r\n    String clientPrincipal = KerberosTestUtils.getClientPrincipal();\r\n    String serverPrincipal = KerberosTestUtils.getServerPrincipal();\r\n    clientPrincipal = clientPrincipal.substring(0, clientPrincipal.lastIndexOf(\"@\"));\r\n    serverPrincipal = serverPrincipal.substring(0, serverPrincipal.lastIndexOf(\"@\"));\r\n    getKdc().createPrincipal(keytabFile, clientPrincipal, serverPrincipal);\r\n    handler = getNewAuthenticationHandler();\r\n    Properties props = getDefaultProperties();\r\n    props.setProperty(KerberosAuthenticationHandler.ENDPOINT_WHITELIST, \"/white,/white2,/white3\");\r\n    try {\r\n        handler.init(props);\r\n    } catch (Exception ex) {\r\n        handler = null;\r\n        throw ex;\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testNameRulesHadoop",
  "errType" : [ "Exception", "Exception" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void testNameRulesHadoop() throws Exception\n{\r\n    KerberosName kn = new KerberosName(KerberosTestUtils.getServerPrincipal());\r\n    Assert.assertEquals(KerberosTestUtils.getRealm(), kn.getRealm());\r\n    handler.destroy();\r\n    handler = getNewAuthenticationHandler();\r\n    Properties props = getDefaultProperties();\r\n    props.setProperty(KerberosAuthenticationHandler.NAME_RULES, \"RULE:[1:$1@$0](.*@BAR)s/@.*//\\nDEFAULT\");\r\n    try {\r\n        handler.init(props);\r\n    } catch (Exception ex) {\r\n    }\r\n    kn = new KerberosName(\"bar@BAR\");\r\n    Assert.assertEquals(\"bar\", kn.getShortName());\r\n    kn = new KerberosName(\"bar@FOO\");\r\n    try {\r\n        kn.getShortName();\r\n        Assert.fail();\r\n    } catch (Exception ex) {\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testNameRulesCompat",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void testNameRulesCompat() throws Exception\n{\r\n    KerberosName kn = new KerberosName(KerberosTestUtils.getServerPrincipal());\r\n    Assert.assertEquals(KerberosTestUtils.getRealm(), kn.getRealm());\r\n    handler.destroy();\r\n    handler = getNewAuthenticationHandler();\r\n    Properties props = getDefaultProperties();\r\n    props.setProperty(KerberosAuthenticationHandler.NAME_RULES, \"RULE:[1:$1@$0](.*@BAR)s/@.*//\\nDEFAULT\");\r\n    props.setProperty(KerberosAuthenticationHandler.RULE_MECHANISM, KerberosName.MECHANISM_MIT);\r\n    try {\r\n        handler.init(props);\r\n    } catch (Exception ex) {\r\n    }\r\n    kn = new KerberosName(\"bar@BAR\");\r\n    Assert.assertEquals(\"bar\", kn.getShortName());\r\n    kn = new KerberosName(\"bar@FOO\");\r\n    Assert.assertEquals(\"bar@FOO\", kn.getShortName());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testNullProperties",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 12,
  "sourceCodeText" : "void testNullProperties() throws Exception\n{\r\n    KerberosName kn = new KerberosName(KerberosTestUtils.getServerPrincipal());\r\n    Assert.assertEquals(KerberosTestUtils.getRealm(), kn.getRealm());\r\n    KerberosName.setRuleMechanism(\"MIT\");\r\n    KerberosName.setRules(\"DEFAULT\");\r\n    handler.destroy();\r\n    handler = getNewAuthenticationHandler();\r\n    Properties props = getDefaultProperties();\r\n    props.remove(KerberosAuthenticationHandler.NAME_RULES);\r\n    props.remove(KerberosAuthenticationHandler.RULE_MECHANISM);\r\n    try {\r\n        handler.init(props);\r\n    } catch (Exception ex) {\r\n    }\r\n    Assert.assertEquals(\"MIT\", KerberosName.getRuleMechanism());\r\n    Assert.assertEquals(\"DEFAULT\", KerberosName.getRules());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testInit",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void testInit() throws Exception\n{\r\n    Assert.assertEquals(KerberosTestUtils.getKeytabFile(), handler.getKeytab());\r\n    Set<KerberosPrincipal> principals = handler.getPrincipals();\r\n    Principal expectedPrincipal = new KerberosPrincipal(KerberosTestUtils.getServerPrincipal());\r\n    Assert.assertTrue(principals.contains(expectedPrincipal));\r\n    Assert.assertEquals(1, principals.size());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testDynamicPrincipalDiscovery",
  "errType" : null,
  "containingMethodsNum" : 12,
  "sourceCodeText" : "void testDynamicPrincipalDiscovery() throws Exception\n{\r\n    String[] keytabUsers = new String[] { \"HTTP/host1\", \"HTTP/host2\", \"HTTP2/host1\", \"XHTTP/host\" };\r\n    String keytab = KerberosTestUtils.getKeytabFile();\r\n    getKdc().createPrincipal(new File(keytab), keytabUsers);\r\n    handler.destroy();\r\n    Properties props = new Properties();\r\n    props.setProperty(KerberosAuthenticationHandler.KEYTAB, keytab);\r\n    props.setProperty(KerberosAuthenticationHandler.PRINCIPAL, \"*\");\r\n    handler = getNewAuthenticationHandler();\r\n    handler.init(props);\r\n    Assert.assertEquals(KerberosTestUtils.getKeytabFile(), handler.getKeytab());\r\n    Set<KerberosPrincipal> loginPrincipals = handler.getPrincipals();\r\n    for (String user : keytabUsers) {\r\n        Principal principal = new KerberosPrincipal(user + \"@\" + KerberosTestUtils.getRealm());\r\n        boolean expected = user.startsWith(\"HTTP/\");\r\n        Assert.assertEquals(\"checking for \" + user, expected, loginPrincipals.contains(principal));\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testDynamicPrincipalDiscoveryMissingPrincipals",
  "errType" : [ "ServletException", "Throwable" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void testDynamicPrincipalDiscoveryMissingPrincipals() throws Exception\n{\r\n    String[] keytabUsers = new String[] { \"hdfs/localhost\" };\r\n    String keytab = KerberosTestUtils.getKeytabFile();\r\n    getKdc().createPrincipal(new File(keytab), keytabUsers);\r\n    handler.destroy();\r\n    Properties props = new Properties();\r\n    props.setProperty(KerberosAuthenticationHandler.KEYTAB, keytab);\r\n    props.setProperty(KerberosAuthenticationHandler.PRINCIPAL, \"*\");\r\n    handler = getNewAuthenticationHandler();\r\n    try {\r\n        handler.init(props);\r\n        Assert.fail(\"init should have failed\");\r\n    } catch (ServletException ex) {\r\n        Assert.assertEquals(\"Principals do not exist in the keytab\", ex.getCause().getMessage());\r\n    } catch (Throwable t) {\r\n        Assert.fail(\"wrong exception: \" + t);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testType",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testType()\n{\r\n    Assert.assertEquals(getExpectedType(), handler.getType());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testRequestWithoutAuthorization",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void testRequestWithoutAuthorization() throws Exception\n{\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    Assert.assertNull(handler.authenticate(request, response));\r\n    Mockito.verify(response).setHeader(KerberosAuthenticator.WWW_AUTHENTICATE, KerberosAuthenticator.NEGOTIATE);\r\n    Mockito.verify(response).setStatus(HttpServletResponse.SC_UNAUTHORIZED);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testRequestWithInvalidAuthorization",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void testRequestWithInvalidAuthorization() throws Exception\n{\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    Mockito.when(request.getHeader(KerberosAuthenticator.AUTHORIZATION)).thenReturn(\"invalid\");\r\n    Assert.assertNull(handler.authenticate(request, response));\r\n    Mockito.verify(response).setHeader(KerberosAuthenticator.WWW_AUTHENTICATE, KerberosAuthenticator.NEGOTIATE);\r\n    Mockito.verify(response).setStatus(HttpServletResponse.SC_UNAUTHORIZED);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testRequestWithIncompleteAuthorization",
  "errType" : [ "AuthenticationException", "Exception" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void testRequestWithIncompleteAuthorization()\n{\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    Mockito.when(request.getHeader(KerberosAuthenticator.AUTHORIZATION)).thenReturn(KerberosAuthenticator.NEGOTIATE);\r\n    try {\r\n        handler.authenticate(request, response);\r\n        Assert.fail();\r\n    } catch (AuthenticationException ex) {\r\n    } catch (Exception ex) {\r\n        Assert.fail();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testRequestWithAuthorization",
  "errType" : null,
  "containingMethodsNum" : 13,
  "sourceCodeText" : "void testRequestWithAuthorization() throws Exception\n{\r\n    String token = KerberosTestUtils.doAsClient(new Callable<String>() {\r\n\r\n        @Override\r\n        public String call() throws Exception {\r\n            GSSManager gssManager = GSSManager.getInstance();\r\n            GSSContext gssContext = null;\r\n            try {\r\n                String servicePrincipal = KerberosTestUtils.getServerPrincipal();\r\n                Oid oid = KerberosUtil.NT_GSS_KRB5_PRINCIPAL_OID;\r\n                GSSName serviceName = gssManager.createName(servicePrincipal, oid);\r\n                oid = KerberosUtil.GSS_KRB5_MECH_OID;\r\n                gssContext = gssManager.createContext(serviceName, oid, null, GSSContext.DEFAULT_LIFETIME);\r\n                gssContext.requestCredDeleg(true);\r\n                gssContext.requestMutualAuth(true);\r\n                byte[] inToken = new byte[0];\r\n                byte[] outToken = gssContext.initSecContext(inToken, 0, inToken.length);\r\n                Base64 base64 = new Base64(0);\r\n                return base64.encodeToString(outToken);\r\n            } finally {\r\n                if (gssContext != null) {\r\n                    gssContext.dispose();\r\n                }\r\n            }\r\n        }\r\n    });\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    Mockito.when(request.getHeader(KerberosAuthenticator.AUTHORIZATION)).thenReturn(KerberosAuthenticator.NEGOTIATE + \" \" + token);\r\n    Mockito.when(request.getServerName()).thenReturn(\"localhost\");\r\n    AuthenticationToken authToken = handler.authenticate(request, response);\r\n    if (authToken != null) {\r\n        Mockito.verify(response).setHeader(Mockito.eq(KerberosAuthenticator.WWW_AUTHENTICATE), Mockito.matches(KerberosAuthenticator.NEGOTIATE + \" .*\"));\r\n        Mockito.verify(response).setStatus(HttpServletResponse.SC_OK);\r\n        Assert.assertEquals(KerberosTestUtils.getClientPrincipal(), authToken.getName());\r\n        Assert.assertTrue(KerberosTestUtils.getClientPrincipal().startsWith(authToken.getUserName()));\r\n        Assert.assertEquals(getExpectedType(), authToken.getType());\r\n    } else {\r\n        Mockito.verify(response).setHeader(Mockito.eq(KerberosAuthenticator.WWW_AUTHENTICATE), Mockito.matches(KerberosAuthenticator.NEGOTIATE + \" .*\"));\r\n        Mockito.verify(response).setStatus(HttpServletResponse.SC_UNAUTHORIZED);\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testRequestWithInvalidKerberosAuthorization",
  "errType" : [ "AuthenticationException", "Exception" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void testRequestWithInvalidKerberosAuthorization()\n{\r\n    String token = new Base64(0).encodeToString(new byte[] { 0, 1, 2 });\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    Mockito.when(request.getHeader(KerberosAuthenticator.AUTHORIZATION)).thenReturn(KerberosAuthenticator.NEGOTIATE + token);\r\n    try {\r\n        handler.authenticate(request, response);\r\n        Assert.fail();\r\n    } catch (AuthenticationException ex) {\r\n    } catch (Exception ex) {\r\n        Assert.fail();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testRequestToWhitelist",
  "errType" : [ "AuthenticationException", "Exception" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void testRequestToWhitelist() throws Exception\n{\r\n    final String token = new Base64(0).encodeToString(new byte[] { 0, 1, 2 });\r\n    final HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    final HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    Mockito.when(request.getHeader(KerberosAuthenticator.AUTHORIZATION)).thenReturn(KerberosAuthenticator.NEGOTIATE + token);\r\n    Mockito.when(request.getServletPath()).thenReturn(\"/white\");\r\n    handler.authenticate(request, response);\r\n    Mockito.when(request.getServletPath()).thenReturn(\"/white4\");\r\n    try {\r\n        handler.authenticate(request, response);\r\n        Assert.fail();\r\n    } catch (AuthenticationException ex) {\r\n    } catch (Exception ex) {\r\n        Assert.fail();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "tearDown",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void tearDown() throws Exception\n{\r\n    if (handler != null) {\r\n        handler.destroy();\r\n        handler = null;\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testInvalidPEMWithHeaderAndFooter",
  "errType" : [ "ServletException" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void testInvalidPEMWithHeaderAndFooter() throws Exception\n{\r\n    String pem = \"-----BEGIN CERTIFICATE-----\\n\" + \"MIICOjCCAaOgAwIBAgIJANXi/oWxvJNzMA0GCSqGSIb3DQEBBQUAMF8xCzAJBgNVBAYTAlVTMQ0w\" + \"CwYDVQQIEwRUZXN0MQ0wCwYDVQQHEwRUZXN0MQ8wDQYDVQQKEwZIYWRvb3AxDTALBgNVBAsTBFRl\" + \"c3QxEjAQBgNVBAMTCWxvY2FsaG9zdDAeFw0xNTAxMDIyMTE5MjRaFw0xNjAxMDIyMTE5MjRaMF8x\" + \"CzAJBgNVBAYTAlVTMQ0wCwYDVQQIEwRUZXN0MQ0wCwYDVQQHEwRUZXN0MQ8wDQYDVQQKEwZIYWRv\" + \"b3AxDTALBgNVBAsTBFRlc3QxEjAQBgNVBAMTCWxvY2FsaG9zdDCBnzANBgkqhkiG9w0BAQEFAAOB\" + \"jQAwgYkCgYEAwpfpLdi7dWTHNzETt+L7618/dWUQFb/C7o1jIxFgbKOVIB6d5YmvUbJck5PYxFkz\" + \"C25fmU5H71WGOI1Kle5TFDmIo+hqh5xqu1YNRZz9i6D94g+2AyYr9BpvH4ZfdHs7r9AU7c3kq68V\" + \"7OPuuaHb25J8isiOyA3RiWuJGQlXTdkCAwEAATANBgkqhkiG9w0BAQUFAAOBgQAdRUyCUqE9sdim\" + \"Fbll9BuZDKV16WXeWGq+kTd7ETe7l0fqXjq5EnrifOai0L/pXwVvS2jrFkKQRlRxRGUNaeEBZ2Wy\" + \"9aTyR+HGHCfvwoCegc9rAVw/DLaRriSO/jnEXzYK6XLVKH+hx5UXrJ7Oyc7JjZUc3g9kCWORThCX\" + \"Mzc1xA==\" + \"\\n-----END CERTIFICATE-----\";\r\n    try {\r\n        CertificateUtil.parseRSAPublicKey(pem);\r\n        fail(\"Should not have thrown ServletException\");\r\n    } catch (ServletException se) {\r\n        assertTrue(se.getMessage().contains(\"PEM header\"));\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testCorruptPEM",
  "errType" : [ "ServletException" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void testCorruptPEM() throws Exception\n{\r\n    String pem = \"MIICOjCCAaOgAwIBAgIJANXi/oWxvJNzMA0GCSqGSIb3DQEBBQUAMF8xCzAJBgNVBAYTAlVTMQ0w\" + \"CwYDVQQIEwRUZXN0MQ0wCwYDVQQHEwRUZXN0MQ8wDQYDVQQKEwZIYWRvb3AxDTALBgNVBAsTBFRl\" + \"c3QxEjAQBgNVBAMTCWxvY2FsaG9zdDAeFw0xNTAxMDIyMTE5MjRaFw0xNjAxMDIyMTE5MjRaMF8x\" + \"CzAJBgNVBAYTAlVTMQ0wCwYDVQQIEwRUZXN0MQ0wCwYDVQQHEwRUZXN0MQ8wDQYDVQQKEwZIYWRv\" + \"b3AxDTALBgNVBAsTBFRlc3QxEjAQBgNVBAMTCWxvY2FsaG9zdDCBnzANBgkqhkiG9w0BAQEFAAOB\" + \"jQAwgYkCgYEAwpfpLdi7dWTHNzETt+L7618/dWUQFb/C7o1jIxFgbKOVIB6d5YmvUbJck5PYxFkz\" + \"C25fmU5H71WGOI1Kle5TFDmIo+hqh5xqu1YNRZz9i6D94g+2AyYr9BpvH4ZfdHs7r9AU7c3kq68V\" + \"7OPuuaHb25J8isiOyA3RiWuJGQlXTdkCAwEAATANBgkqhkiG9w0BAQUFAAOBgQAdRUyCUqE9sdim\" + \"Fbll9BuZDKV16WXeWGq+kTd7ETe7l0fqXjq5EnrifOai0L/pXwVvS2jrFkKQRlRxRGUNaeEBZ2Wy\" + \"9aTyR+HGHCfvwoCegc9rAVw/DLaRriSO/jnEXzYK6XLVKH+hx5UXrJ7Oyc7JjZUc3g9kCWORThCX\" + \"Mzc1xA++\";\r\n    try {\r\n        CertificateUtil.parseRSAPublicKey(pem);\r\n        fail(\"Should not have thrown ServletException\");\r\n    } catch (ServletException se) {\r\n        assertTrue(se.getMessage().contains(\"corrupt\"));\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testValidPEM",
  "errType" : [ "ServletException" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void testValidPEM() throws Exception\n{\r\n    String pem = \"MIICOjCCAaOgAwIBAgIJANXi/oWxvJNzMA0GCSqGSIb3DQEBBQUAMF8xCzAJBgNVBAYTAlVTMQ0w\" + \"CwYDVQQIEwRUZXN0MQ0wCwYDVQQHEwRUZXN0MQ8wDQYDVQQKEwZIYWRvb3AxDTALBgNVBAsTBFRl\" + \"c3QxEjAQBgNVBAMTCWxvY2FsaG9zdDAeFw0xNTAxMDIyMTE5MjRaFw0xNjAxMDIyMTE5MjRaMF8x\" + \"CzAJBgNVBAYTAlVTMQ0wCwYDVQQIEwRUZXN0MQ0wCwYDVQQHEwRUZXN0MQ8wDQYDVQQKEwZIYWRv\" + \"b3AxDTALBgNVBAsTBFRlc3QxEjAQBgNVBAMTCWxvY2FsaG9zdDCBnzANBgkqhkiG9w0BAQEFAAOB\" + \"jQAwgYkCgYEAwpfpLdi7dWTHNzETt+L7618/dWUQFb/C7o1jIxFgbKOVIB6d5YmvUbJck5PYxFkz\" + \"C25fmU5H71WGOI1Kle5TFDmIo+hqh5xqu1YNRZz9i6D94g+2AyYr9BpvH4ZfdHs7r9AU7c3kq68V\" + \"7OPuuaHb25J8isiOyA3RiWuJGQlXTdkCAwEAATANBgkqhkiG9w0BAQUFAAOBgQAdRUyCUqE9sdim\" + \"Fbll9BuZDKV16WXeWGq+kTd7ETe7l0fqXjq5EnrifOai0L/pXwVvS2jrFkKQRlRxRGUNaeEBZ2Wy\" + \"9aTyR+HGHCfvwoCegc9rAVw/DLaRriSO/jnEXzYK6XLVKH+hx5UXrJ7Oyc7JjZUc3g9kCWORThCX\" + \"Mzc1xA==\";\r\n    try {\r\n        RSAPublicKey pk = CertificateUtil.parseRSAPublicKey(pem);\r\n        assertNotNull(pk);\r\n        assertEquals(\"RSA\", pk.getAlgorithm());\r\n    } catch (ServletException se) {\r\n        fail(\"Should not have thrown ServletException\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testNoPublicKeyJWT",
  "errType" : [ "ServletException", "AuthenticationException" ],
  "containingMethodsNum" : 13,
  "sourceCodeText" : "void testNoPublicKeyJWT() throws Exception\n{\r\n    try {\r\n        Properties props = getProperties();\r\n        handler.init(props);\r\n        SignedJWT jwt = getJWT(\"bob\", new Date(new Date().getTime() + 5000), privateKey);\r\n        Cookie cookie = new Cookie(\"hadoop-jwt\", jwt.serialize());\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(SERVICE_URL));\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        Mockito.when(response.encodeRedirectURL(SERVICE_URL)).thenReturn(SERVICE_URL);\r\n        AuthenticationToken token = handler.alternateAuthenticate(request, response);\r\n        fail(\"alternateAuthentication should have thrown a ServletException\");\r\n    } catch (ServletException se) {\r\n        assertTrue(se.getMessage().contains(\"Public key for signature validation must be provisioned\"));\r\n    } catch (AuthenticationException ae) {\r\n        fail(\"alternateAuthentication should NOT have thrown a AuthenticationException\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testCustomCookieNameJWT",
  "errType" : [ "ServletException", "AuthenticationException" ],
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void testCustomCookieNameJWT() throws Exception\n{\r\n    try {\r\n        handler.setPublicKey(publicKey);\r\n        Properties props = getProperties();\r\n        props.put(JWTRedirectAuthenticationHandler.JWT_COOKIE_NAME, \"jowt\");\r\n        handler.init(props);\r\n        SignedJWT jwt = getJWT(\"bob\", new Date(new Date().getTime() + 5000), privateKey);\r\n        Cookie cookie = new Cookie(\"jowt\", jwt.serialize());\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(SERVICE_URL));\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        Mockito.when(response.encodeRedirectURL(SERVICE_URL)).thenReturn(SERVICE_URL);\r\n        AuthenticationToken token = handler.alternateAuthenticate(request, response);\r\n        Assert.assertEquals(\"bob\", token.getUserName());\r\n    } catch (ServletException se) {\r\n        fail(\"alternateAuthentication should NOT have thrown a ServletException: \" + se.getMessage());\r\n    } catch (AuthenticationException ae) {\r\n        fail(\"alternateAuthentication should NOT have thrown a AuthenticationException\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testNoProviderURLJWT",
  "errType" : [ "ServletException", "AuthenticationException" ],
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void testNoProviderURLJWT() throws Exception\n{\r\n    try {\r\n        handler.setPublicKey(publicKey);\r\n        Properties props = getProperties();\r\n        props.remove(JWTRedirectAuthenticationHandler.AUTHENTICATION_PROVIDER_URL);\r\n        handler.init(props);\r\n        SignedJWT jwt = getJWT(\"bob\", new Date(new Date().getTime() + 5000), privateKey);\r\n        Cookie cookie = new Cookie(\"hadoop-jwt\", jwt.serialize());\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(SERVICE_URL));\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        Mockito.when(response.encodeRedirectURL(SERVICE_URL)).thenReturn(SERVICE_URL);\r\n        AuthenticationToken token = handler.alternateAuthenticate(request, response);\r\n        fail(\"alternateAuthentication should have thrown an AuthenticationException\");\r\n    } catch (ServletException se) {\r\n        assertTrue(se.getMessage().contains(\"Authentication provider URL must not be null\"));\r\n    } catch (AuthenticationException ae) {\r\n        fail(\"alternateAuthentication should NOT have thrown a AuthenticationException\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testUnableToParseJWT",
  "errType" : [ "ServletException", "AuthenticationException" ],
  "containingMethodsNum" : 18,
  "sourceCodeText" : "void testUnableToParseJWT() throws Exception\n{\r\n    try {\r\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\r\n        kpg.initialize(2048);\r\n        KeyPair kp = kpg.genKeyPair();\r\n        RSAPublicKey publicKey = (RSAPublicKey) kp.getPublic();\r\n        handler.setPublicKey(publicKey);\r\n        Properties props = getProperties();\r\n        handler.init(props);\r\n        SignedJWT jwt = getJWT(\"bob\", new Date(new Date().getTime() + 5000), privateKey);\r\n        Cookie cookie = new Cookie(\"hadoop-jwt\", \"ljm\" + jwt.serialize());\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(SERVICE_URL));\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        Mockito.when(response.encodeRedirectURL(SERVICE_URL)).thenReturn(SERVICE_URL);\r\n        AuthenticationToken token = handler.alternateAuthenticate(request, response);\r\n        Mockito.verify(response).sendRedirect(REDIRECT_LOCATION);\r\n    } catch (ServletException se) {\r\n        fail(\"alternateAuthentication should NOT have thrown a ServletException\");\r\n    } catch (AuthenticationException ae) {\r\n        fail(\"alternateAuthentication should NOT have thrown a AuthenticationException\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testFailedSignatureValidationJWT",
  "errType" : [ "ServletException", "AuthenticationException" ],
  "containingMethodsNum" : 18,
  "sourceCodeText" : "void testFailedSignatureValidationJWT() throws Exception\n{\r\n    try {\r\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\r\n        kpg.initialize(2048);\r\n        KeyPair kp = kpg.genKeyPair();\r\n        RSAPublicKey publicKey = (RSAPublicKey) kp.getPublic();\r\n        handler.setPublicKey(publicKey);\r\n        Properties props = getProperties();\r\n        handler.init(props);\r\n        SignedJWT jwt = getJWT(\"bob\", new Date(new Date().getTime() + 5000), privateKey);\r\n        Cookie cookie = new Cookie(\"hadoop-jwt\", jwt.serialize());\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(SERVICE_URL));\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        Mockito.when(response.encodeRedirectURL(SERVICE_URL)).thenReturn(SERVICE_URL);\r\n        AuthenticationToken token = handler.alternateAuthenticate(request, response);\r\n        Mockito.verify(response).sendRedirect(REDIRECT_LOCATION);\r\n    } catch (ServletException se) {\r\n        fail(\"alternateAuthentication should NOT have thrown a ServletException\");\r\n    } catch (AuthenticationException ae) {\r\n        fail(\"alternateAuthentication should NOT have thrown a AuthenticationException\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testExpiredJWT",
  "errType" : [ "ServletException", "AuthenticationException" ],
  "containingMethodsNum" : 14,
  "sourceCodeText" : "void testExpiredJWT() throws Exception\n{\r\n    try {\r\n        handler.setPublicKey(publicKey);\r\n        Properties props = getProperties();\r\n        handler.init(props);\r\n        SignedJWT jwt = getJWT(\"bob\", new Date(new Date().getTime() - 1000), privateKey);\r\n        Cookie cookie = new Cookie(\"hadoop-jwt\", jwt.serialize());\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(SERVICE_URL));\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        Mockito.when(response.encodeRedirectURL(SERVICE_URL)).thenReturn(SERVICE_URL);\r\n        AuthenticationToken token = handler.alternateAuthenticate(request, response);\r\n        Mockito.verify(response).sendRedirect(REDIRECT_LOCATION);\r\n    } catch (ServletException se) {\r\n        fail(\"alternateAuthentication should NOT have thrown a ServletException\");\r\n    } catch (AuthenticationException ae) {\r\n        fail(\"alternateAuthentication should NOT have thrown a AuthenticationException\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testNoExpirationJWT",
  "errType" : [ "ServletException", "AuthenticationException" ],
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void testNoExpirationJWT() throws Exception\n{\r\n    try {\r\n        handler.setPublicKey(publicKey);\r\n        Properties props = getProperties();\r\n        handler.init(props);\r\n        SignedJWT jwt = getJWT(\"bob\", null, privateKey);\r\n        Cookie cookie = new Cookie(\"hadoop-jwt\", jwt.serialize());\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(SERVICE_URL));\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        Mockito.when(response.encodeRedirectURL(SERVICE_URL)).thenReturn(SERVICE_URL);\r\n        AuthenticationToken token = handler.alternateAuthenticate(request, response);\r\n        Assert.assertNotNull(\"Token should not be null.\", token);\r\n        Assert.assertEquals(\"bob\", token.getUserName());\r\n    } catch (ServletException se) {\r\n        fail(\"alternateAuthentication should NOT have thrown a ServletException\");\r\n    } catch (AuthenticationException ae) {\r\n        fail(\"alternateAuthentication should NOT have thrown a AuthenticationException\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testInvalidAudienceJWT",
  "errType" : [ "ServletException", "AuthenticationException" ],
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void testInvalidAudienceJWT() throws Exception\n{\r\n    try {\r\n        handler.setPublicKey(publicKey);\r\n        Properties props = getProperties();\r\n        props.put(JWTRedirectAuthenticationHandler.EXPECTED_JWT_AUDIENCES, \"foo\");\r\n        handler.init(props);\r\n        SignedJWT jwt = getJWT(\"bob\", new Date(new Date().getTime() + 5000), privateKey);\r\n        Cookie cookie = new Cookie(\"hadoop-jwt\", jwt.serialize());\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(SERVICE_URL));\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        Mockito.when(response.encodeRedirectURL(SERVICE_URL)).thenReturn(SERVICE_URL);\r\n        AuthenticationToken token = handler.alternateAuthenticate(request, response);\r\n        Mockito.verify(response).sendRedirect(REDIRECT_LOCATION);\r\n    } catch (ServletException se) {\r\n        fail(\"alternateAuthentication should NOT have thrown a ServletException\");\r\n    } catch (AuthenticationException ae) {\r\n        fail(\"alternateAuthentication should NOT have thrown a AuthenticationException\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testValidAudienceJWT",
  "errType" : [ "ServletException", "AuthenticationException" ],
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void testValidAudienceJWT() throws Exception\n{\r\n    try {\r\n        handler.setPublicKey(publicKey);\r\n        Properties props = getProperties();\r\n        props.put(JWTRedirectAuthenticationHandler.EXPECTED_JWT_AUDIENCES, \"bar\");\r\n        handler.init(props);\r\n        SignedJWT jwt = getJWT(\"bob\", new Date(new Date().getTime() + 5000), privateKey);\r\n        Cookie cookie = new Cookie(\"hadoop-jwt\", jwt.serialize());\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(SERVICE_URL));\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        Mockito.when(response.encodeRedirectURL(SERVICE_URL)).thenReturn(SERVICE_URL);\r\n        AuthenticationToken token = handler.alternateAuthenticate(request, response);\r\n        Assert.assertEquals(\"bob\", token.getUserName());\r\n    } catch (ServletException se) {\r\n        fail(\"alternateAuthentication should NOT have thrown a ServletException\");\r\n    } catch (AuthenticationException ae) {\r\n        fail(\"alternateAuthentication should NOT have thrown an AuthenticationException\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testValidJWT",
  "errType" : [ "ServletException", "AuthenticationException" ],
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void testValidJWT() throws Exception\n{\r\n    try {\r\n        handler.setPublicKey(publicKey);\r\n        Properties props = getProperties();\r\n        handler.init(props);\r\n        SignedJWT jwt = getJWT(\"alice\", new Date(new Date().getTime() + 5000), privateKey);\r\n        Cookie cookie = new Cookie(\"hadoop-jwt\", jwt.serialize());\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(SERVICE_URL));\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        Mockito.when(response.encodeRedirectURL(SERVICE_URL)).thenReturn(SERVICE_URL);\r\n        AuthenticationToken token = handler.alternateAuthenticate(request, response);\r\n        Assert.assertNotNull(\"Token should not be null.\", token);\r\n        Assert.assertEquals(\"alice\", token.getUserName());\r\n    } catch (ServletException se) {\r\n        fail(\"alternateAuthentication should NOT have thrown a ServletException.\");\r\n    } catch (AuthenticationException ae) {\r\n        fail(\"alternateAuthentication should NOT have thrown an AuthenticationException\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testOrigURLWithQueryString",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void testOrigURLWithQueryString() throws Exception\n{\r\n    handler.setPublicKey(publicKey);\r\n    Properties props = getProperties();\r\n    handler.init(props);\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(SERVICE_URL));\r\n    Mockito.when(request.getQueryString()).thenReturn(\"name=value\");\r\n    String loginURL = handler.constructLoginURL(request);\r\n    Assert.assertNotNull(\"loginURL should not be null.\", loginURL);\r\n    Assert.assertEquals(\"https://localhost:8443/authserver?originalUrl=\" + SERVICE_URL + \"?name=value\", loginURL);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testOrigURLNoQueryString",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void testOrigURLNoQueryString() throws Exception\n{\r\n    handler.setPublicKey(publicKey);\r\n    Properties props = getProperties();\r\n    handler.init(props);\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(SERVICE_URL));\r\n    Mockito.when(request.getQueryString()).thenReturn(null);\r\n    String loginURL = handler.constructLoginURL(request);\r\n    Assert.assertNotNull(\"LoginURL should not be null.\", loginURL);\r\n    Assert.assertEquals(\"https://localhost:8443/authserver?originalUrl=\" + SERVICE_URL, loginURL);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "setup",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void setup() throws Exception, NoSuchAlgorithmException\n{\r\n    setupKerberosRequirements();\r\n    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\r\n    kpg.initialize(2048);\r\n    KeyPair kp = kpg.genKeyPair();\r\n    publicKey = (RSAPublicKey) kp.getPublic();\r\n    privateKey = (RSAPrivateKey) kp.getPrivate();\r\n    handler = new JWTRedirectAuthenticationHandler();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "setupKerberosRequirements",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void setupKerberosRequirements() throws Exception\n{\r\n    String[] keytabUsers = new String[] { \"HTTP/host1\", \"HTTP/host2\", \"HTTP2/host1\", \"XHTTP/host\" };\r\n    String keytab = KerberosTestUtils.getKeytabFile();\r\n    getKdc().createPrincipal(new File(keytab), keytabUsers);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "teardown",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void teardown() throws Exception\n{\r\n    handler.destroy();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getProperties",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "Properties getProperties()\n{\r\n    Properties props = new Properties();\r\n    props.setProperty(JWTRedirectAuthenticationHandler.AUTHENTICATION_PROVIDER_URL, \"https://localhost:8443/authserver\");\r\n    props.setProperty(\"kerberos.principal\", KerberosTestUtils.getServerPrincipal());\r\n    props.setProperty(\"kerberos.keytab\", KerberosTestUtils.getKeytabFile());\r\n    return props;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getJWT",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "SignedJWT getJWT(String sub, Date expires, RSAPrivateKey privateKey) throws Exception\n{\r\n    JWTClaimsSet claimsSet = new JWTClaimsSet.Builder().subject(sub).issueTime(new Date(new Date().getTime())).issuer(\"https://c2id.com\").claim(\"scope\", \"openid\").audience(\"bar\").expirationTime(expires).build();\r\n    List<String> aud = new ArrayList<String>();\r\n    aud.add(\"bar\");\r\n    JWSHeader header = new JWSHeader.Builder(JWSAlgorithm.RS256).build();\r\n    SignedJWT signedJWT = new SignedJWT(header, claimsSet);\r\n    JWSSigner signer = new RSASSASigner(privateKey);\r\n    signedJWT.sign(signer);\r\n    return signedJWT;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "deleteKeytab",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void deleteKeytab()\n{\r\n    File keytabFile = new File(testKeytab);\r\n    if (keytabFile.exists()) {\r\n        keytabFile.delete();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testGetServerPrincipal",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void testGetServerPrincipal() throws IOException, UnknownHostException\n{\r\n    String service = \"TestKerberosUtil\";\r\n    String localHostname = KerberosUtil.getLocalHostName();\r\n    String testHost = \"FooBar\";\r\n    String defaultRealm = KerberosUtil.getDefaultRealmProtected();\r\n    String atDefaultRealm;\r\n    if (defaultRealm == null || defaultRealm.equals(\"\")) {\r\n        atDefaultRealm = \"\";\r\n    } else {\r\n        atDefaultRealm = \"@\" + defaultRealm;\r\n    }\r\n    Assert.assertEquals(\"testGetServerPrincipal assumes localhost realm is default\", KerberosUtil.getDomainRealm(service + \"/\" + localHostname.toLowerCase(Locale.US)), defaultRealm);\r\n    Assert.assertEquals(\"testGetServerPrincipal assumes realm of testHost 'FooBar' is default\", KerberosUtil.getDomainRealm(service + \"/\" + testHost.toLowerCase(Locale.US)), defaultRealm);\r\n    Assert.assertEquals(\"When no hostname is sent\", service + \"/\" + localHostname.toLowerCase(Locale.US) + atDefaultRealm, KerberosUtil.getServicePrincipal(service, null));\r\n    Assert.assertEquals(\"When empty hostname is sent\", service + \"/\" + localHostname.toLowerCase(Locale.US) + atDefaultRealm, KerberosUtil.getServicePrincipal(service, \"\"));\r\n    Assert.assertEquals(\"When 0.0.0.0 hostname is sent\", service + \"/\" + localHostname.toLowerCase(Locale.US) + atDefaultRealm, KerberosUtil.getServicePrincipal(service, \"0.0.0.0\"));\r\n    Assert.assertEquals(\"When uppercase hostname is sent\", service + \"/\" + testHost.toLowerCase(Locale.US) + atDefaultRealm, KerberosUtil.getServicePrincipal(service, testHost));\r\n    Assert.assertEquals(\"When lowercase hostname is sent\", service + \"/\" + testHost.toLowerCase(Locale.US) + atDefaultRealm, KerberosUtil.getServicePrincipal(service, testHost.toLowerCase(Locale.US)));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testGetPrincipalNamesMissingKeytab",
  "errType" : [ "IllegalArgumentException", "IOException" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void testGetPrincipalNamesMissingKeytab()\n{\r\n    try {\r\n        KerberosUtil.getPrincipalNames(testKeytab);\r\n        Assert.fail(\"Exception should have been thrown\");\r\n    } catch (IllegalArgumentException e) {\r\n    } catch (IOException e) {\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testGetPrincipalNamesMissingPattern",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void testGetPrincipalNamesMissingPattern() throws IOException\n{\r\n    createKeyTab(testKeytab, new String[] { \"test/testhost@testRealm\" });\r\n    try {\r\n        KerberosUtil.getPrincipalNames(testKeytab, null);\r\n        Assert.fail(\"Exception should have been thrown\");\r\n    } catch (Exception e) {\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testGetPrincipalNamesFromKeytab",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void testGetPrincipalNamesFromKeytab() throws IOException\n{\r\n    createKeyTab(testKeytab, testPrincipals);\r\n    String[] principals = KerberosUtil.getPrincipalNames(testKeytab);\r\n    Assert.assertNotNull(\"principals cannot be null\", principals);\r\n    int expectedSize = 0;\r\n    List<String> principalList = Arrays.asList(principals);\r\n    for (String principal : testPrincipals) {\r\n        Assert.assertTrue(\"missing principal \" + principal, principalList.contains(principal));\r\n        expectedSize++;\r\n    }\r\n    Assert.assertEquals(expectedSize, principals.length);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testGetPrincipalNamesFromKeytabWithPattern",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void testGetPrincipalNamesFromKeytabWithPattern() throws IOException\n{\r\n    createKeyTab(testKeytab, testPrincipals);\r\n    Pattern httpPattern = Pattern.compile(\"HTTP/.*\");\r\n    String[] httpPrincipals = KerberosUtil.getPrincipalNames(testKeytab, httpPattern);\r\n    Assert.assertNotNull(\"principals cannot be null\", httpPrincipals);\r\n    int expectedSize = 0;\r\n    List<String> httpPrincipalList = Arrays.asList(httpPrincipals);\r\n    for (String principal : testPrincipals) {\r\n        if (httpPattern.matcher(principal).matches()) {\r\n            Assert.assertTrue(\"missing principal \" + principal, httpPrincipalList.contains(principal));\r\n            expectedSize++;\r\n        }\r\n    }\r\n    Assert.assertEquals(expectedSize, httpPrincipals.length);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "createKeyTab",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void createKeyTab(String fileName, String[] principalNames) throws IOException\n{\r\n    List<KeytabEntry> lstEntries = new ArrayList<KeytabEntry>();\r\n    for (String principal : principalNames) {\r\n        for (int kvno = 1; kvno <= 3; kvno++) {\r\n            EncryptionKey key = new EncryptionKey(EncryptionType.NONE, \"samplekey1\".getBytes(), kvno);\r\n            KeytabEntry keytabEntry = new KeytabEntry(new PrincipalName(principal), new KerberosTime(), (byte) 1, key);\r\n            lstEntries.add(keytabEntry);\r\n        }\r\n    }\r\n    Keytab keytab = new Keytab();\r\n    keytab.addKeytabEntries(lstEntries);\r\n    keytab.store(new File(testKeytab));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testServicePrincipalDecode",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void testServicePrincipalDecode() throws Exception\n{\r\n    String krb5Default = \"YIIB2AYJKoZIhvcSAQICAQBuggHHMIIBw6ADAgEFoQMCAQ6iBwMFACAAAACj\" + \"gethgegwgeWgAwIBBaENGwtFWEFNUExFLkNPTaIcMBqgAwIBAKETMBEbBEhU\" + \"VFAbCWxvY2FsaG9zdKOBsDCBraADAgERoQMCAQGigaAEgZ23QsT1+16T23ni\" + \"JI1uFRU0FN13hhPSLAl4+oAqpV5s1Z6E+G2VKGx2+rUF21utOdlwUK/J5CKF\" + \"HxM4zfNsmzRFhdk5moJW6AWHuRqGJ9hrZgTxA2vOBIn/tju+n/vJVEcUvW0f\" + \"DiPfjPIPFOlc7V9GlWvZFyr5NMJSFwspKJXYh/FSNpSVTecfGskjded9TZzR\" + \"2tOVzgpjFvAu/DETpIG/MIG8oAMCARGigbQEgbGWnbKlV1oo7/gzT4hi/Q41\" + \"ff2luDnSxADEmo6M8LC42scsYMLNgU4iLJhuf4YLb7ueh790HrbB6Kdes71/\" + \"gSBiLI2/mn3BqNE43gt94dQ8VFBix4nJCsYnuORYxLJjRSJE+3ImJNsSjqaf\" + \"GRI0sp9w3hc4IVm8afb3Ggm6PgRIyyGNdTzK/p03v+zA01MJh3htuOgLKUOV\" + \"z002pHnGzu/purZ5mOyaQT12vHxJ2T+Cwi8=\";\r\n    String krb5Other = \"YIIB2AYJKoZIhvcSAQICAQBuggHHMIIBw6ADAgEFoQMCAQ6iBwMFACAAAACj\" + \"gethgegwgeWgAwIBBaENGwtBQkNERUZHLk9SR6IcMBqgAwIBAKETMBEbBEhU\" + \"VFAbCW90aGVyaG9zdKOBsDCBraADAgERoQMCAQGigaAEgZ23QsT1+16T23ni\" + \"JI1uFRU0FN13hhPSLAl4+oAqpV5s1Z6E+G2VKGx2+rUF21utOdlwUK/J5CKF\" + \"HxM4zfNsmzRFhdk5moJW6AWHuRqGJ9hrZgTxA2vOBIn/tju+n/vJVEcUvW0f\" + \"DiPfjPIPFOlc7V9GlWvZFyr5NMJSFwspKJXYh/FSNpSVTecfGskjded9TZzR\" + \"2tOVzgpjFvAu/DETpIG/MIG8oAMCARGigbQEgbGWnbKlV1oo7/gzT4hi/Q41\" + \"ff2luDnSxADEmo6M8LC42scsYMLNgU4iLJhuf4YLb7ueh790HrbB6Kdes71/\" + \"gSBiLI2/mn3BqNE43gt94dQ8VFBix4nJCsYnuORYxLJjRSJE+3ImJNsSjqaf\" + \"GRI0sp9w3hc4IVm8afb3Ggm6PgRIyyGNdTzK/p03v+zA01MJh3htuOgLKUOV\" + \"z002pHnGzu/purZ5mOyaQT12vHxJ2T+Cwi8K\";\r\n    String spnegoDefault = \"YIICCQYGKwYBBQUCoIIB/TCCAfmgDTALBgkqhkiG9xIBAgKhBAMCAXaiggHg\" + \"BIIB3GCCAdgGCSqGSIb3EgECAgEAboIBxzCCAcOgAwIBBaEDAgEOogcDBQAg\" + \"AAAAo4HrYYHoMIHloAMCAQWhDRsLRVhBTVBMRS5DT02iHDAaoAMCAQChEzAR\" + \"GwRIVFRQGwlsb2NhbGhvc3SjgbAwga2gAwIBEaEDAgEBooGgBIGdBWbzvV1R\" + \"Iqb7WuPIW3RTkFtwjU9P/oFAbujGPd8h/qkCszroNdvHhUkPntuOqhFBntMo\" + \"bilgTqNEdDUGvBbfkJaRklNGqT/IAOUV6tlGpBUCXquR5UdPzPpUvGZiVRUu\" + \"FGH5DGGHvYF1CwXPp2l1Jq373vSLQ1kBl6TXl+aKLsZYhVUjKvE7Auippclb\" + \"hv/GGGex/TcjNH48k47OQaSBvzCBvKADAgERooG0BIGxeChp3TMVtWbCdFGo\" + \"YL+35r2762j+OEwZRfcj4xCK7j0mUTcxLtyVGxyY9Ax+ljl5gTwzRhXcJq0T\" + \"TjiQwKJckeZ837mXQAURbfJpFc3VLAXGfNkMFCR7ZkWpGA1Vzc3PeUNczn2D\" + \"Lpu8sme55HFFQDi/0akW6Lwv/iCrpwIkZPyZPjaEmwLVALu4E8m0Ka3fJkPV\" + \"GAhamg9OQpuREIK0pCk3ZSHhJz8qMwduzRZHc4vN\";\r\n    String spnegoOther = \"YIICCQYGKwYBBQUCoIIB/TCCAfmgDTALBgkqhkiG9xIBAgKhBAMCAXaiggHg\" + \"BIIB3GCCAdgGCSqGSIb3EgECAgEAboIBxzCCAcOgAwIBBaEDAgEOogcDBQAg\" + \"AAAAo4HrYYHoMIHloAMCAQWhDRsLQUJDREVGRy5PUkeiHDAaoAMCAQChEzAR\" + \"GwRIVFRQGwlvdGhlcmhvc3SjgbAwga2gAwIBEaEDAgEBooGgBIGdBWbzvV1R\" + \"Iqb7WuPIW3RTkFtwjU9P/oFAbujGPd8h/qkCszroNdvHhUkPntuOqhFBntMo\" + \"bilgTqNEdDUGvBbfkJaRklNGqT/IAOUV6tlGpBUCXquR5UdPzPpUvGZiVRUu\" + \"FGH5DGGHvYF1CwXPp2l1Jq373vSLQ1kBl6TXl+aKLsZYhVUjKvE7Auippclb\" + \"hv/GGGex/TcjNH48k47OQaSBvzCBvKADAgERooG0BIGxeChp3TMVtWbCdFGo\" + \"YL+35r2762j+OEwZRfcj4xCK7j0mUTcxLtyVGxyY9Ax+ljl5gTwzRhXcJq0T\" + \"TjiQwKJckeZ837mXQAURbfJpFc3VLAXGfNkMFCR7ZkWpGA1Vzc3PeUNczn2D\" + \"Lpu8sme55HFFQDi/0akW6Lwv/iCrpwIkZPyZPjaEmwLVALu4E8m0Ka3fJkPV\" + \"GAhamg9OQpuREIK0pCk3ZSHhJz8qMwduzRZHc4vNCg==\";\r\n    assertEquals(\"HTTP/localhost@EXAMPLE.COM\", getPrincipal(krb5Default));\r\n    assertEquals(\"HTTP/otherhost@ABCDEFG.ORG\", getPrincipal(krb5Other));\r\n    assertEquals(\"HTTP/localhost@EXAMPLE.COM\", getPrincipal(spnegoDefault));\r\n    assertEquals(\"HTTP/otherhost@ABCDEFG.ORG\", getPrincipal(spnegoOther));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "getPrincipal",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String getPrincipal(String token)\n{\r\n    return KerberosUtil.getTokenServerName(Base64.getDecoder().decode(token));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "setUp",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void setUp() throws Exception\n{\r\n    System.setProperty(\"java.security.krb5.realm\", KerberosTestUtils.getRealm());\r\n    System.setProperty(\"java.security.krb5.kdc\", \"localhost:88\");\r\n    String rules = \"RULE:[1:$1@$0](.*@YAHOO\\\\.COM)s/@.*//\\n\" + \"RULE:[2:$1](johndoe)s/^.*$/guest/\\n\" + \"RULE:[2:$1;$2](^.*;admin$)s/;admin$//\\n\" + \"RULE:[2:$2](root)\\n\" + \"DEFAULT\";\r\n    KerberosName.setRuleMechanism(KerberosName.MECHANISM_HADOOP);\r\n    KerberosName.setRules(rules);\r\n    KerberosName.printRules();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "checkTranslation",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void checkTranslation(String from, String to) throws Exception\n{\r\n    System.out.println(\"Translate \" + from);\r\n    KerberosName nm = new KerberosName(from);\r\n    String simple = nm.getShortName();\r\n    System.out.println(\"to \" + simple);\r\n    Assert.assertEquals(\"short name incorrect\", to, simple);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testRules",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void testRules() throws Exception\n{\r\n    checkTranslation(\"omalley@\" + KerberosTestUtils.getRealm(), \"omalley\");\r\n    checkTranslation(\"hdfs/10.0.0.1@\" + KerberosTestUtils.getRealm(), \"hdfs\");\r\n    checkTranslation(\"oom@YAHOO.COM\", \"oom\");\r\n    checkTranslation(\"johndoe/zoo@FOO.COM\", \"guest\");\r\n    checkTranslation(\"joe/admin@FOO.COM\", \"joe\");\r\n    checkTranslation(\"joe/root@FOO.COM\", \"root\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "checkBadName",
  "errType" : [ "IllegalArgumentException" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void checkBadName(String name)\n{\r\n    System.out.println(\"Checking \" + name + \" to ensure it is bad.\");\r\n    try {\r\n        new KerberosName(name);\r\n        Assert.fail(\"didn't get exception for \" + name);\r\n    } catch (IllegalArgumentException iae) {\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "checkBadTranslation",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void checkBadTranslation(String from)\n{\r\n    System.out.println(\"Checking bad translation for \" + from);\r\n    KerberosName nm = new KerberosName(from);\r\n    try {\r\n        nm.getShortName();\r\n        Assert.fail(\"didn't get exception for \" + from);\r\n    } catch (IOException ie) {\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testAntiPatterns",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void testAntiPatterns() throws Exception\n{\r\n    KerberosName.setRuleMechanism(KerberosName.MECHANISM_HADOOP);\r\n    checkBadName(\"owen/owen/owen@FOO.COM\");\r\n    checkBadName(\"owen@foo/bar.com\");\r\n    checkBadTranslation(\"foo@ACME.COM\");\r\n    checkBadTranslation(\"root/joe@FOO.COM\");\r\n    KerberosName.setRuleMechanism(KerberosName.MECHANISM_MIT);\r\n    checkTranslation(\"foo@ACME.COM\", \"foo@ACME.COM\");\r\n    checkTranslation(\"root/joe@FOO.COM\", \"root/joe@FOO.COM\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testParsing",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void testParsing() throws Exception\n{\r\n    final String principalNameFull = \"HTTP/abc.com@EXAMPLE.COM\";\r\n    final String principalNameWoRealm = \"HTTP/abc.com\";\r\n    final String principalNameWoHost = \"HTTP@EXAMPLE.COM\";\r\n    final KerberosName kerbNameFull = new KerberosName(principalNameFull);\r\n    Assert.assertEquals(\"HTTP\", kerbNameFull.getServiceName());\r\n    Assert.assertEquals(\"abc.com\", kerbNameFull.getHostName());\r\n    Assert.assertEquals(\"EXAMPLE.COM\", kerbNameFull.getRealm());\r\n    final KerberosName kerbNamewoRealm = new KerberosName(principalNameWoRealm);\r\n    Assert.assertEquals(\"HTTP\", kerbNamewoRealm.getServiceName());\r\n    Assert.assertEquals(\"abc.com\", kerbNamewoRealm.getHostName());\r\n    Assert.assertEquals(null, kerbNamewoRealm.getRealm());\r\n    final KerberosName kerbNameWoHost = new KerberosName(principalNameWoHost);\r\n    Assert.assertEquals(\"HTTP\", kerbNameWoHost.getServiceName());\r\n    Assert.assertEquals(null, kerbNameWoHost.getHostName());\r\n    Assert.assertEquals(\"EXAMPLE.COM\", kerbNameWoHost.getRealm());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testToLowerCase",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void testToLowerCase() throws Exception\n{\r\n    String rules = \"RULE:[1:$1]/L\\n\" + \"RULE:[2:$1]/L\\n\" + \"RULE:[2:$1;$2](^.*;admin$)s/;admin$///L\\n\" + \"RULE:[2:$1;$2](^.*;guest$)s/;guest$//g/L\\n\" + \"DEFAULT\";\r\n    KerberosName.setRules(rules);\r\n    KerberosName.printRules();\r\n    checkTranslation(\"Joe@FOO.COM\", \"joe\");\r\n    checkTranslation(\"Joe/root@FOO.COM\", \"joe\");\r\n    checkTranslation(\"Joe/admin@FOO.COM\", \"joe\");\r\n    checkTranslation(\"Joe/guestguest@FOO.COM\", \"joe\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testInvalidRuleMechanism",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testInvalidRuleMechanism() throws Exception\n{\r\n    KerberosName.setRuleMechanism(\"INVALID_MECHANISM\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "clear",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void clear()\n{\r\n    System.clearProperty(\"java.security.krb5.realm\");\r\n    System.clearProperty(\"java.security.krb5.kdc\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication",
  "methodName" : "getRealm",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getRealm()\n{\r\n    return \"EXAMPLE.COM\";\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication",
  "methodName" : "getClientPrincipal",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getClientPrincipal()\n{\r\n    return \"client@EXAMPLE.COM\";\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication",
  "methodName" : "getServerPrincipal",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getServerPrincipal()\n{\r\n    return \"HTTP/localhost@EXAMPLE.COM\";\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication",
  "methodName" : "getKeytabFile",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getKeytabFile()\n{\r\n    return keytabFile;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication",
  "methodName" : "doAs",
  "errType" : [ "PrivilegedActionException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "T doAs(String principal, final Callable<T> callable) throws Exception\n{\r\n    LoginContext loginContext = null;\r\n    try {\r\n        Set<Principal> principals = new HashSet<Principal>();\r\n        principals.add(new KerberosPrincipal(KerberosTestUtils.getClientPrincipal()));\r\n        Subject subject = new Subject(false, principals, new HashSet<Object>(), new HashSet<Object>());\r\n        loginContext = new LoginContext(\"\", subject, null, new KerberosConfiguration(principal));\r\n        loginContext.login();\r\n        subject = loginContext.getSubject();\r\n        return Subject.doAs(subject, new PrivilegedExceptionAction<T>() {\r\n\r\n            @Override\r\n            public T run() throws Exception {\r\n                return callable.call();\r\n            }\r\n        });\r\n    } catch (PrivilegedActionException ex) {\r\n        throw ex.getException();\r\n    } finally {\r\n        if (loginContext != null) {\r\n            loginContext.logout();\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication",
  "methodName" : "doAsClient",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "T doAsClient(Callable<T> callable) throws Exception\n{\r\n    return doAs(getClientPrincipal(), callable);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication",
  "methodName" : "doAsServer",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "T doAsServer(Callable<T> callable) throws Exception\n{\r\n    return doAs(getServerPrincipal(), callable);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "test",
  "errType" : null,
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void test() throws Exception\n{\r\n    String krb5LoginModuleName;\r\n    if (System.getProperty(\"java.vendor\").contains(\"IBM\")) {\r\n        krb5LoginModuleName = \"com.ibm.security.auth.module.Krb5LoginModule\";\r\n    } else {\r\n        krb5LoginModuleName = \"com.sun.security.auth.module.Krb5LoginModule\";\r\n    }\r\n    ZKSignerSecretProvider.JaasConfiguration jConf = new ZKSignerSecretProvider.JaasConfiguration(\"foo\", \"foo/localhost\", \"/some/location/foo.keytab\");\r\n    AppConfigurationEntry[] entries = jConf.getAppConfigurationEntry(\"bar\");\r\n    Assert.assertNull(entries);\r\n    entries = jConf.getAppConfigurationEntry(\"foo\");\r\n    Assert.assertEquals(1, entries.length);\r\n    AppConfigurationEntry entry = entries[0];\r\n    Assert.assertEquals(AppConfigurationEntry.LoginModuleControlFlag.REQUIRED, entry.getControlFlag());\r\n    Assert.assertEquals(krb5LoginModuleName, entry.getLoginModuleName());\r\n    Map<String, ?> options = entry.getOptions();\r\n    Assert.assertEquals(\"/some/location/foo.keytab\", options.get(\"keyTab\"));\r\n    Assert.assertEquals(\"foo/localhost\", options.get(\"principal\"));\r\n    Assert.assertEquals(\"true\", options.get(\"useKeyTab\"));\r\n    Assert.assertEquals(\"true\", options.get(\"storeKey\"));\r\n    Assert.assertEquals(\"false\", options.get(\"useTicketCache\"));\r\n    Assert.assertEquals(\"true\", options.get(\"refreshKrb5Config\"));\r\n    Assert.assertEquals(6, options.size());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testGetSecrets",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void testGetSecrets() throws Exception\n{\r\n    String secretStr = \"secret\";\r\n    StringSignerSecretProvider secretProvider = new StringSignerSecretProvider();\r\n    Properties secretProviderProps = new Properties();\r\n    secretProviderProps.setProperty(AuthenticationFilter.SIGNATURE_SECRET, \"secret\");\r\n    secretProvider.init(secretProviderProps, null, -1);\r\n    byte[] secretBytes = secretStr.getBytes();\r\n    Assert.assertArrayEquals(secretBytes, secretProvider.getCurrentSecret());\r\n    byte[][] allSecrets = secretProvider.getAllSecrets();\r\n    Assert.assertEquals(1, allSecrets.length);\r\n    Assert.assertArrayEquals(secretBytes, allSecrets[0]);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testGetConfiguration",
  "errType" : null,
  "containingMethodsNum" : 12,
  "sourceCodeText" : "void testGetConfiguration() throws Exception\n{\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    FilterConfig config = Mockito.mock(FilterConfig.class);\r\n    Mockito.when(config.getInitParameter(AuthenticationFilter.CONFIG_PREFIX)).thenReturn(\"\");\r\n    Mockito.when(config.getInitParameter(\"a\")).thenReturn(\"A\");\r\n    Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(\"a\")).elements());\r\n    Properties props = filter.getConfiguration(\"\", config);\r\n    Assert.assertEquals(\"A\", props.getProperty(\"a\"));\r\n    config = Mockito.mock(FilterConfig.class);\r\n    Mockito.when(config.getInitParameter(AuthenticationFilter.CONFIG_PREFIX)).thenReturn(\"foo\");\r\n    Mockito.when(config.getInitParameter(\"foo.a\")).thenReturn(\"A\");\r\n    Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(\"foo.a\")).elements());\r\n    props = filter.getConfiguration(\"foo.\", config);\r\n    Assert.assertEquals(\"A\", props.getProperty(\"a\"));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testInitEmpty",
  "errType" : [ "ServletException", "Exception" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void testInitEmpty() throws Exception\n{\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>().elements());\r\n        filter.init(config);\r\n        Assert.fail();\r\n    } catch (ServletException ex) {\r\n        Assert.assertEquals(\"Authentication type must be specified: simple|kerberos|<class>\", ex.getMessage());\r\n    } catch (Exception ex) {\r\n        Assert.fail();\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testFallbackToRandomSecretProvider",
  "errType" : null,
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void testFallbackToRandomSecretProvider() throws Exception\n{\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(\"simple\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TOKEN_VALIDITY)).thenReturn((new Long(TOKEN_VALIDITY_SEC)).toString());\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, AuthenticationFilter.AUTH_TOKEN_VALIDITY)).elements());\r\n        ServletContext context = Mockito.mock(ServletContext.class);\r\n        Mockito.when(context.getAttribute(AuthenticationFilter.SIGNER_SECRET_PROVIDER_ATTRIBUTE)).thenReturn(null);\r\n        Mockito.when(config.getServletContext()).thenReturn(context);\r\n        filter.init(config);\r\n        Assert.assertEquals(PseudoAuthenticationHandler.class, filter.getAuthenticationHandler().getClass());\r\n        Assert.assertTrue(filter.isRandomSecret());\r\n        Assert.assertFalse(filter.isCustomSignerSecretProvider());\r\n        Assert.assertNull(filter.getCookieDomain());\r\n        Assert.assertNull(filter.getCookiePath());\r\n        Assert.assertEquals(TOKEN_VALIDITY_SEC, filter.getValidity());\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testInit",
  "errType" : [ "ServletException" ],
  "containingMethodsNum" : 53,
  "sourceCodeText" : "void testInit() throws Exception\n{\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(\"simple\");\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<>(Arrays.asList(AuthenticationFilter.AUTH_TYPE)).elements());\r\n        ServletContext context = Mockito.mock(ServletContext.class);\r\n        Mockito.when(context.getAttribute(AuthenticationFilter.SIGNER_SECRET_PROVIDER_ATTRIBUTE)).thenReturn(new SignerSecretProvider() {\r\n\r\n            @Override\r\n            public void init(Properties config, ServletContext servletContext, long tokenValidity) {\r\n            }\r\n\r\n            @Override\r\n            public byte[] getCurrentSecret() {\r\n                return null;\r\n            }\r\n\r\n            @Override\r\n            public byte[][] getAllSecrets() {\r\n                return null;\r\n            }\r\n        });\r\n        Mockito.when(config.getServletContext()).thenReturn(context);\r\n        filter.init(config);\r\n        Assert.assertFalse(filter.isRandomSecret());\r\n        Assert.assertTrue(filter.isCustomSignerSecretProvider());\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n    File testDir = new File(System.getProperty(\"test.build.data\", \"target/test-dir\"));\r\n    testDir.mkdirs();\r\n    String secretValue = \"hadoop\";\r\n    File secretFile = new File(testDir, \"http-secret.txt\");\r\n    Writer writer = new FileWriter(secretFile);\r\n    writer.write(secretValue);\r\n    writer.close();\r\n    filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(\"simple\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.SIGNATURE_SECRET_FILE)).thenReturn(secretFile.getAbsolutePath());\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, AuthenticationFilter.SIGNATURE_SECRET_FILE)).elements());\r\n        ServletContext context = Mockito.mock(ServletContext.class);\r\n        Mockito.when(context.getAttribute(AuthenticationFilter.SIGNER_SECRET_PROVIDER_ATTRIBUTE)).thenReturn(null);\r\n        Mockito.when(config.getServletContext()).thenReturn(context);\r\n        filter.init(config);\r\n        Assert.assertFalse(filter.isRandomSecret());\r\n        Assert.assertFalse(filter.isCustomSignerSecretProvider());\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n    filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(\"simple\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.COOKIE_DOMAIN)).thenReturn(\".foo.com\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.COOKIE_PATH)).thenReturn(\"/bar\");\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, AuthenticationFilter.COOKIE_DOMAIN, AuthenticationFilter.COOKIE_PATH)).elements());\r\n        getMockedServletContextWithStringSigner(config);\r\n        filter.init(config);\r\n        Assert.assertEquals(\".foo.com\", filter.getCookieDomain());\r\n        Assert.assertEquals(\"/bar\", filter.getCookiePath());\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n    DummyAuthenticationHandler.reset();\r\n    filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(\"management.operation.return\")).thenReturn(\"true\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(DummyAuthenticationHandler.class.getName());\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, \"management.operation.return\")).elements());\r\n        getMockedServletContextWithStringSigner(config);\r\n        filter.init(config);\r\n        Assert.assertTrue(DummyAuthenticationHandler.init);\r\n    } finally {\r\n        filter.destroy();\r\n        Assert.assertTrue(DummyAuthenticationHandler.destroy);\r\n    }\r\n    filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        ServletContext sc = Mockito.mock(ServletContext.class);\r\n        Mockito.when(config.getServletContext()).thenReturn(sc);\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(\"kerberos\");\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE)).elements());\r\n        filter.init(config);\r\n    } catch (ServletException ex) {\r\n    } finally {\r\n        Assert.assertEquals(KerberosAuthenticationHandler.class, filter.getAuthenticationHandler().getClass());\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 5,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testEmptySecretFileFallbacksToRandomSecret",
  "errType" : null,
  "containingMethodsNum" : 13,
  "sourceCodeText" : "void testEmptySecretFileFallbacksToRandomSecret() throws Exception\n{\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(\"simple\");\r\n        File secretFile = File.createTempFile(\"test_empty_secret\", \".txt\");\r\n        secretFile.deleteOnExit();\r\n        Assert.assertTrue(secretFile.exists());\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.SIGNATURE_SECRET_FILE)).thenReturn(secretFile.getAbsolutePath());\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, AuthenticationFilter.SIGNATURE_SECRET_FILE)).elements());\r\n        ServletContext context = Mockito.mock(ServletContext.class);\r\n        Mockito.when(context.getAttribute(AuthenticationFilter.SIGNER_SECRET_PROVIDER_ATTRIBUTE)).thenReturn(null);\r\n        Mockito.when(config.getServletContext()).thenReturn(context);\r\n        filter.init(config);\r\n        Assert.assertTrue(filter.isRandomSecret());\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testInitCaseSensitivity",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void testInitCaseSensitivity() throws Exception\n{\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(\"SimPle\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TOKEN_VALIDITY)).thenReturn((new Long(TOKEN_VALIDITY_SEC)).toString());\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, AuthenticationFilter.AUTH_TOKEN_VALIDITY)).elements());\r\n        getMockedServletContextWithStringSigner(config);\r\n        filter.init(config);\r\n        Assert.assertEquals(PseudoAuthenticationHandler.class, filter.getAuthenticationHandler().getClass());\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testGetRequestURL",
  "errType" : null,
  "containingMethodsNum" : 11,
  "sourceCodeText" : "void testGetRequestURL() throws Exception\n{\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(\"management.operation.return\")).thenReturn(\"true\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(DummyAuthenticationHandler.class.getName());\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, \"management.operation.return\")).elements());\r\n        getMockedServletContextWithStringSigner(config);\r\n        filter.init(config);\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(\"http://foo:8080/bar\"));\r\n        Mockito.when(request.getQueryString()).thenReturn(\"a=A&b=B\");\r\n        Assert.assertEquals(\"http://foo:8080/bar?a=A&b=B\", filter.getRequestURL(request));\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testGetToken",
  "errType" : null,
  "containingMethodsNum" : 14,
  "sourceCodeText" : "void testGetToken() throws Exception\n{\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(\"management.operation.return\")).thenReturn(\"true\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(DummyAuthenticationHandler.class.getName());\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.SIGNATURE_SECRET)).thenReturn(\"secret\");\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, AuthenticationFilter.SIGNATURE_SECRET, \"management.operation.return\")).elements());\r\n        SignerSecretProvider secretProvider = getMockedServletContextWithStringSigner(config);\r\n        filter.init(config);\r\n        AuthenticationToken token = new AuthenticationToken(\"u\", \"p\", DummyAuthenticationHandler.TYPE);\r\n        token.setExpires(System.currentTimeMillis() + TOKEN_VALIDITY_SEC);\r\n        Signer signer = new Signer(secretProvider);\r\n        String tokenSigned = signer.sign(token.toString());\r\n        Cookie cookie = new Cookie(AuthenticatedURL.AUTH_COOKIE, tokenSigned);\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        AuthenticationToken newToken = filter.getToken(request);\r\n        Assert.assertEquals(token.toString(), newToken.toString());\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testGetTokenExpired",
  "errType" : [ "AuthenticationException" ],
  "containingMethodsNum" : 18,
  "sourceCodeText" : "void testGetTokenExpired() throws Exception\n{\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(\"management.operation.return\")).thenReturn(\"true\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(DummyAuthenticationHandler.class.getName());\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.SIGNATURE_SECRET)).thenReturn(\"secret\");\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, AuthenticationFilter.SIGNATURE_SECRET, \"management.operation.return\")).elements());\r\n        getMockedServletContextWithStringSigner(config);\r\n        filter.init(config);\r\n        AuthenticationToken token = new AuthenticationToken(\"u\", \"p\", DummyAuthenticationHandler.TYPE);\r\n        token.setExpires(System.currentTimeMillis() - TOKEN_VALIDITY_SEC);\r\n        SignerSecretProvider secretProvider = StringSignerSecretProviderCreator.newStringSignerSecretProvider();\r\n        Properties secretProviderProps = new Properties();\r\n        secretProviderProps.setProperty(AuthenticationFilter.SIGNATURE_SECRET, \"secret\");\r\n        secretProvider.init(secretProviderProps, null, TOKEN_VALIDITY_SEC);\r\n        Signer signer = new Signer(secretProvider);\r\n        String tokenSigned = signer.sign(token.toString());\r\n        Cookie cookie = new Cookie(AuthenticatedURL.AUTH_COOKIE, tokenSigned);\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        boolean failed = false;\r\n        try {\r\n            filter.getToken(request);\r\n        } catch (AuthenticationException ex) {\r\n            Assert.assertEquals(\"AuthenticationToken expired\", ex.getMessage());\r\n            failed = true;\r\n        } finally {\r\n            Assert.assertTrue(\"token not expired\", failed);\r\n        }\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testGetTokenInvalidType",
  "errType" : [ "AuthenticationException" ],
  "containingMethodsNum" : 18,
  "sourceCodeText" : "void testGetTokenInvalidType() throws Exception\n{\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(\"management.operation.return\")).thenReturn(\"true\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(DummyAuthenticationHandler.class.getName());\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.SIGNATURE_SECRET)).thenReturn(\"secret\");\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, AuthenticationFilter.SIGNATURE_SECRET, \"management.operation.return\")).elements());\r\n        getMockedServletContextWithStringSigner(config);\r\n        filter.init(config);\r\n        AuthenticationToken token = new AuthenticationToken(\"u\", \"p\", \"invalidtype\");\r\n        token.setExpires(System.currentTimeMillis() + TOKEN_VALIDITY_SEC);\r\n        SignerSecretProvider secretProvider = StringSignerSecretProviderCreator.newStringSignerSecretProvider();\r\n        Properties secretProviderProps = new Properties();\r\n        secretProviderProps.setProperty(AuthenticationFilter.SIGNATURE_SECRET, \"secret\");\r\n        secretProvider.init(secretProviderProps, null, TOKEN_VALIDITY_SEC);\r\n        Signer signer = new Signer(secretProvider);\r\n        String tokenSigned = signer.sign(token.toString());\r\n        Cookie cookie = new Cookie(AuthenticatedURL.AUTH_COOKIE, tokenSigned);\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        boolean failed = false;\r\n        try {\r\n            filter.getToken(request);\r\n        } catch (AuthenticationException ex) {\r\n            Assert.assertEquals(\"Invalid AuthenticationToken type\", ex.getMessage());\r\n            failed = true;\r\n        } finally {\r\n            Assert.assertTrue(\"token not invalid type\", failed);\r\n        }\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "getMockedServletContextWithStringSigner",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "SignerSecretProvider getMockedServletContextWithStringSigner(FilterConfig config) throws Exception\n{\r\n    Properties secretProviderProps = new Properties();\r\n    secretProviderProps.setProperty(AuthenticationFilter.SIGNATURE_SECRET, \"secret\");\r\n    SignerSecretProvider secretProvider = StringSignerSecretProviderCreator.newStringSignerSecretProvider();\r\n    secretProvider.init(secretProviderProps, null, TOKEN_VALIDITY_SEC);\r\n    ServletContext context = Mockito.mock(ServletContext.class);\r\n    Mockito.when(context.getAttribute(AuthenticationFilter.SIGNER_SECRET_PROVIDER_ATTRIBUTE)).thenReturn(secretProvider);\r\n    Mockito.when(config.getServletContext()).thenReturn(context);\r\n    return secretProvider;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testDoFilterNotAuthenticated",
  "errType" : null,
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void testDoFilterNotAuthenticated() throws Exception\n{\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(\"management.operation.return\")).thenReturn(\"true\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(DummyAuthenticationHandler.class.getName());\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, \"management.operation.return\")).elements());\r\n        getMockedServletContextWithStringSigner(config);\r\n        filter.init(config);\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(\"http://foo:8080/bar\"));\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        FilterChain chain = Mockito.mock(FilterChain.class);\r\n        Mockito.doAnswer(new Answer<Object>() {\r\n\r\n            @Override\r\n            public Object answer(InvocationOnMock invocation) throws Throwable {\r\n                Assert.fail();\r\n                return null;\r\n            }\r\n        }).when(chain).doFilter(any(), any());\r\n        Mockito.when(response.containsHeader(\"WWW-Authenticate\")).thenReturn(true);\r\n        filter.doFilter(request, response, chain);\r\n        Mockito.verify(response).sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Authentication required\");\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "_testDoFilterAuthentication",
  "errType" : null,
  "containingMethodsNum" : 37,
  "sourceCodeText" : "void _testDoFilterAuthentication(boolean withDomainPath, boolean invalidToken, boolean expired) throws Exception\n{\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    FilterConfig config = Mockito.mock(FilterConfig.class);\r\n    Mockito.when(config.getInitParameter(\"management.operation.return\")).thenReturn(\"true\");\r\n    Mockito.when(config.getInitParameter(\"expired.token\")).thenReturn(Boolean.toString(expired));\r\n    Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(DummyAuthenticationHandler.class.getName());\r\n    Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TOKEN_VALIDITY)).thenReturn(new Long(TOKEN_VALIDITY_SEC).toString());\r\n    Mockito.when(config.getInitParameter(AuthenticationFilter.SIGNATURE_SECRET)).thenReturn(\"secret\");\r\n    Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, AuthenticationFilter.AUTH_TOKEN_VALIDITY, AuthenticationFilter.SIGNATURE_SECRET, \"management.operation\" + \".return\", \"expired.token\")).elements());\r\n    getMockedServletContextWithStringSigner(config);\r\n    if (withDomainPath) {\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.COOKIE_DOMAIN)).thenReturn(\".foo.com\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.COOKIE_PATH)).thenReturn(\"/bar\");\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, AuthenticationFilter.AUTH_TOKEN_VALIDITY, AuthenticationFilter.SIGNATURE_SECRET, AuthenticationFilter.COOKIE_DOMAIN, AuthenticationFilter.COOKIE_PATH, \"management.operation.return\")).elements());\r\n    }\r\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n    Mockito.when(request.getParameter(\"authenticated\")).thenReturn(\"true\");\r\n    Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(\"http://foo:8080/bar\"));\r\n    Mockito.when(request.getQueryString()).thenReturn(\"authenticated=true\");\r\n    if (invalidToken) {\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { new Cookie(AuthenticatedURL.AUTH_COOKIE, \"foo\") });\r\n    }\r\n    HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n    FilterChain chain = Mockito.mock(FilterChain.class);\r\n    final Map<String, String> cookieMap = new HashMap<String, String>();\r\n    Mockito.doAnswer(new Answer<Object>() {\r\n\r\n        @Override\r\n        public Object answer(InvocationOnMock invocation) throws Throwable {\r\n            String cookieHeader = (String) invocation.getArguments()[1];\r\n            parseCookieMap(cookieHeader, cookieMap);\r\n            return null;\r\n        }\r\n    }).when(response).addHeader(Mockito.eq(\"Set-Cookie\"), Mockito.anyString());\r\n    try {\r\n        filter.init(config);\r\n        filter.doFilter(request, response, chain);\r\n        if (expired) {\r\n            Mockito.verify(response, Mockito.never()).addHeader(Mockito.eq(\"Set-Cookie\"), Mockito.anyString());\r\n        } else {\r\n            String v = cookieMap.get(AuthenticatedURL.AUTH_COOKIE);\r\n            Assert.assertNotNull(\"cookie missing\", v);\r\n            Assert.assertTrue(v.contains(\"u=\") && v.contains(\"p=\") && v.contains(\"t=\") && v.contains(\"e=\") && v.contains(\"s=\"));\r\n            Mockito.verify(chain).doFilter(any(ServletRequest.class), any(ServletResponse.class));\r\n            SignerSecretProvider secretProvider = StringSignerSecretProviderCreator.newStringSignerSecretProvider();\r\n            Properties secretProviderProps = new Properties();\r\n            secretProviderProps.setProperty(AuthenticationFilter.SIGNATURE_SECRET, \"secret\");\r\n            secretProvider.init(secretProviderProps, null, TOKEN_VALIDITY_SEC);\r\n            Signer signer = new Signer(secretProvider);\r\n            String value = signer.verifyAndExtract(v);\r\n            AuthenticationToken token = AuthenticationToken.parse(value);\r\n            assertThat(token.getExpires(), not(0L));\r\n            if (withDomainPath) {\r\n                Assert.assertEquals(\".foo.com\", cookieMap.get(\"Domain\"));\r\n                Assert.assertEquals(\"/bar\", cookieMap.get(\"Path\"));\r\n            } else {\r\n                Assert.assertFalse(cookieMap.containsKey(\"Domain\"));\r\n                Assert.assertFalse(cookieMap.containsKey(\"Path\"));\r\n            }\r\n        }\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "parseCookieMap",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void parseCookieMap(String cookieHeader, Map<String, String> cookieMap)\n{\r\n    List<HttpCookie> cookies = HttpCookie.parse(cookieHeader);\r\n    for (HttpCookie cookie : cookies) {\r\n        if (AuthenticatedURL.AUTH_COOKIE.equals(cookie.getName())) {\r\n            cookieMap.put(cookie.getName(), cookie.getValue());\r\n            if (cookie.getPath() != null) {\r\n                cookieMap.put(\"Path\", cookie.getPath());\r\n            }\r\n            if (cookie.getDomain() != null) {\r\n                cookieMap.put(\"Domain\", cookie.getDomain());\r\n            }\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testDoFilterAuthentication",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testDoFilterAuthentication() throws Exception\n{\r\n    _testDoFilterAuthentication(false, false, false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testDoFilterAuthenticationImmediateExpiration",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testDoFilterAuthenticationImmediateExpiration() throws Exception\n{\r\n    _testDoFilterAuthentication(false, false, true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testDoFilterAuthenticationWithInvalidToken",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testDoFilterAuthenticationWithInvalidToken() throws Exception\n{\r\n    _testDoFilterAuthentication(false, true, false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testDoFilterAuthenticationWithDomainPath",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testDoFilterAuthenticationWithDomainPath() throws Exception\n{\r\n    _testDoFilterAuthentication(true, false, false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testDoFilterAuthenticated",
  "errType" : null,
  "containingMethodsNum" : 19,
  "sourceCodeText" : "void testDoFilterAuthenticated() throws Exception\n{\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(\"management.operation.return\")).thenReturn(\"true\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(DummyAuthenticationHandler.class.getName());\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, \"management.operation.return\")).elements());\r\n        getMockedServletContextWithStringSigner(config);\r\n        filter.init(config);\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(\"http://foo:8080/bar\"));\r\n        AuthenticationToken token = new AuthenticationToken(\"u\", \"p\", \"t\");\r\n        token.setExpires(System.currentTimeMillis() + TOKEN_VALIDITY_SEC);\r\n        SignerSecretProvider secretProvider = StringSignerSecretProviderCreator.newStringSignerSecretProvider();\r\n        Properties secretProviderProps = new Properties();\r\n        secretProviderProps.setProperty(AuthenticationFilter.SIGNATURE_SECRET, \"secret\");\r\n        secretProvider.init(secretProviderProps, null, TOKEN_VALIDITY_SEC);\r\n        Signer signer = new Signer(secretProvider);\r\n        String tokenSigned = signer.sign(token.toString());\r\n        Cookie cookie = new Cookie(AuthenticatedURL.AUTH_COOKIE, tokenSigned);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        FilterChain chain = Mockito.mock(FilterChain.class);\r\n        Mockito.doAnswer(new Answer<Object>() {\r\n\r\n            @Override\r\n            public Object answer(InvocationOnMock invocation) throws Throwable {\r\n                Object[] args = invocation.getArguments();\r\n                HttpServletRequest request = (HttpServletRequest) args[0];\r\n                Assert.assertEquals(\"u\", request.getRemoteUser());\r\n                Assert.assertEquals(\"p\", request.getUserPrincipal().getName());\r\n                return null;\r\n            }\r\n        }).when(chain).doFilter(any(), any());\r\n        filter.doFilter(request, response, chain);\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testDoFilterAuthenticationFailure",
  "errType" : null,
  "containingMethodsNum" : 21,
  "sourceCodeText" : "void testDoFilterAuthenticationFailure() throws Exception\n{\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(\"management.operation.return\")).thenReturn(\"true\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(DummyAuthenticationHandler.class.getName());\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, \"management.operation.return\")).elements());\r\n        getMockedServletContextWithStringSigner(config);\r\n        filter.init(config);\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(\"http://foo:8080/bar\"));\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] {});\r\n        Mockito.when(request.getHeader(\"WWW-Authenticate\")).thenReturn(\"dummyauth\");\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        FilterChain chain = Mockito.mock(FilterChain.class);\r\n        final Map<String, String> cookieMap = new HashMap<String, String>();\r\n        Mockito.doAnswer(new Answer<Object>() {\r\n\r\n            @Override\r\n            public Object answer(InvocationOnMock invocation) throws Throwable {\r\n                Object[] args = invocation.getArguments();\r\n                parseCookieMap((String) args[1], cookieMap);\r\n                return null;\r\n            }\r\n        }).when(response).addHeader(Mockito.eq(\"Set-Cookie\"), Mockito.anyString());\r\n        Mockito.doAnswer(new Answer<Object>() {\r\n\r\n            @Override\r\n            public Object answer(InvocationOnMock invocation) throws Throwable {\r\n                Assert.fail(\"shouldn't get here\");\r\n                return null;\r\n            }\r\n        }).when(chain).doFilter(any(), any());\r\n        filter.doFilter(request, response, chain);\r\n        Mockito.verify(response).sendError(HttpServletResponse.SC_FORBIDDEN, \"AUTH FAILED\");\r\n        Mockito.verify(response, Mockito.never()).setHeader(Mockito.eq(\"WWW-Authenticate\"), Mockito.anyString());\r\n        String value = cookieMap.get(AuthenticatedURL.AUTH_COOKIE);\r\n        Assert.assertNotNull(\"cookie missing\", value);\r\n        Assert.assertEquals(\"\", value);\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testDoFilterAuthenticatedExpired",
  "errType" : null,
  "containingMethodsNum" : 20,
  "sourceCodeText" : "void testDoFilterAuthenticatedExpired() throws Exception\n{\r\n    String secret = \"secret\";\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(\"management.operation.return\")).thenReturn(\"true\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(DummyAuthenticationHandler.class.getName());\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.SIGNATURE_SECRET)).thenReturn(secret);\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, AuthenticationFilter.SIGNATURE_SECRET, \"management.operation.return\")).elements());\r\n        getMockedServletContextWithStringSigner(config);\r\n        filter.init(config);\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(\"http://foo:8080/bar\"));\r\n        AuthenticationToken token = new AuthenticationToken(\"u\", \"p\", DummyAuthenticationHandler.TYPE);\r\n        token.setExpires(System.currentTimeMillis() - TOKEN_VALIDITY_SEC);\r\n        SignerSecretProvider secretProvider = StringSignerSecretProviderCreator.newStringSignerSecretProvider();\r\n        Properties secretProviderProps = new Properties();\r\n        secretProviderProps.setProperty(AuthenticationFilter.SIGNATURE_SECRET, secret);\r\n        secretProvider.init(secretProviderProps, null, TOKEN_VALIDITY_SEC);\r\n        Signer signer = new Signer(secretProvider);\r\n        String tokenSigned = signer.sign(token.toString());\r\n        Cookie cookie = new Cookie(AuthenticatedURL.AUTH_COOKIE, tokenSigned);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        Mockito.when(response.containsHeader(\"WWW-Authenticate\")).thenReturn(true);\r\n        FilterChain chain = Mockito.mock(FilterChain.class);\r\n        verifyUnauthorized(filter, request, response, chain);\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testDoFilterAuthenticationAuthorized",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void testDoFilterAuthenticationAuthorized() throws Exception\n{\r\n    long maxInactives = System.currentTimeMillis() + TOKEN_MAX_INACTIVE_INTERVAL;\r\n    long expires = System.currentTimeMillis() + TOKEN_VALIDITY_SEC;\r\n    boolean authorized = true;\r\n    _testDoFilterAuthenticationMaxInactiveInterval(maxInactives, expires, authorized);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testDoFilterAuthenticationUnauthorizedExpired",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void testDoFilterAuthenticationUnauthorizedExpired() throws Exception\n{\r\n    long maxInactives = System.currentTimeMillis() + TOKEN_MAX_INACTIVE_INTERVAL;\r\n    long expires = System.currentTimeMillis() - TOKEN_VALIDITY_SEC;\r\n    boolean authorized = false;\r\n    _testDoFilterAuthenticationMaxInactiveInterval(maxInactives, expires, authorized);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testDoFilterAuthenticationUnauthorizedInactived",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void testDoFilterAuthenticationUnauthorizedInactived() throws Exception\n{\r\n    long maxInactives = System.currentTimeMillis() - TOKEN_MAX_INACTIVE_INTERVAL;\r\n    long expires = System.currentTimeMillis() + TOKEN_VALIDITY_SEC;\r\n    boolean authorized = false;\r\n    _testDoFilterAuthenticationMaxInactiveInterval(maxInactives, expires, authorized);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testDoFilterAuthenticationUnauthorizedInactivedExpired",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void testDoFilterAuthenticationUnauthorizedInactivedExpired() throws Exception\n{\r\n    long maxInactives = System.currentTimeMillis() - TOKEN_MAX_INACTIVE_INTERVAL;\r\n    long expires = System.currentTimeMillis() - TOKEN_VALIDITY_SEC;\r\n    boolean authorized = false;\r\n    _testDoFilterAuthenticationMaxInactiveInterval(maxInactives, expires, authorized);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testTokenWithValidActivityInterval",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void testTokenWithValidActivityInterval() throws Exception\n{\r\n    long maxInactives = System.currentTimeMillis() + TOKEN_MAX_INACTIVE_INTERVAL;\r\n    long expires = System.currentTimeMillis() + TOKEN_VALIDITY_SEC;\r\n    _testDoFilterAuthenticationMaxInactiveInterval(maxInactives, -1, expires, true, false);\r\n    maxInactives = System.currentTimeMillis() + TOKEN_MAX_INACTIVE_INTERVAL;\r\n    expires = System.currentTimeMillis() + TOKEN_VALIDITY_SEC;\r\n    _testDoFilterAuthenticationMaxInactiveInterval(maxInactives, TOKEN_MAX_INACTIVE_INTERVAL, expires, true, true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testTokenWithExpiredActivityIntervaln",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void testTokenWithExpiredActivityIntervaln() throws Exception\n{\r\n    long maxInactives = System.currentTimeMillis() - TOKEN_MAX_INACTIVE_INTERVAL;\r\n    long expires = System.currentTimeMillis() + TOKEN_VALIDITY_SEC;\r\n    _testDoFilterAuthenticationMaxInactiveInterval(maxInactives, -1, expires, false, false);\r\n    maxInactives = System.currentTimeMillis() + TOKEN_MAX_INACTIVE_INTERVAL;\r\n    expires = System.currentTimeMillis() + TOKEN_VALIDITY_SEC;\r\n    _testDoFilterAuthenticationMaxInactiveInterval(maxInactives, -1, expires, true, false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testTokenWithNoActivityIntervals",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void testTokenWithNoActivityIntervals() throws Exception\n{\r\n    long expires = System.currentTimeMillis() + TOKEN_VALIDITY_SEC;\r\n    _testDoFilterAuthenticationMaxInactiveInterval(-1, -1, expires, true, false);\r\n    expires = System.currentTimeMillis() + TOKEN_VALIDITY_SEC;\r\n    _testDoFilterAuthenticationMaxInactiveInterval(-1, TOKEN_MAX_INACTIVE_INTERVAL, expires, true, true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "_testDoFilterAuthenticationMaxInactiveInterval",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void _testDoFilterAuthenticationMaxInactiveInterval(long maxInactivesInToken, long expires, boolean authorized) throws Exception\n{\r\n    _testDoFilterAuthenticationMaxInactiveInterval(maxInactivesInToken, TOKEN_MAX_INACTIVE_INTERVAL, expires, authorized, true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "_testDoFilterAuthenticationMaxInactiveInterval",
  "errType" : null,
  "containingMethodsNum" : 23,
  "sourceCodeText" : "void _testDoFilterAuthenticationMaxInactiveInterval(long maxInactivesInToken, long maxInactivesOnServer, long expires, boolean authorized, boolean newCookie) throws Exception\n{\r\n    String secret = \"secret\";\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(\"management.operation.return\")).thenReturn(\"true\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(DummyAuthenticationHandler.class.getName());\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.SIGNATURE_SECRET)).thenReturn(secret);\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TOKEN_MAX_INACTIVE_INTERVAL)).thenReturn(Long.toString(maxInactivesOnServer));\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, AuthenticationFilter.SIGNATURE_SECRET, AuthenticationFilter.AUTH_TOKEN_MAX_INACTIVE_INTERVAL, \"management.operation.return\")).elements());\r\n        getMockedServletContextWithStringSigner(config);\r\n        filter.init(config);\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(\"http://foo:8080/bar\"));\r\n        AuthenticationToken token = new AuthenticationToken(\"u\", \"p\", DummyAuthenticationHandler.TYPE);\r\n        token.setMaxInactives(maxInactivesInToken);\r\n        token.setExpires(expires);\r\n        SignerSecretProvider secretProvider = StringSignerSecretProviderCreator.newStringSignerSecretProvider();\r\n        Properties secretProviderProps = new Properties();\r\n        secretProviderProps.setProperty(AuthenticationFilter.SIGNATURE_SECRET, secret);\r\n        secretProvider.init(secretProviderProps, null, TOKEN_VALIDITY_SEC);\r\n        Signer signer = new Signer(secretProvider);\r\n        String tokenSigned = signer.sign(token.toString());\r\n        Cookie cookie = new Cookie(AuthenticatedURL.AUTH_COOKIE, tokenSigned);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        Mockito.when(response.containsHeader(\"WWW-Authenticate\")).thenReturn(true);\r\n        FilterChain chain = Mockito.mock(FilterChain.class);\r\n        if (authorized) {\r\n            verifyAuthorized(filter, request, response, chain, newCookie);\r\n        } else {\r\n            verifyUnauthorized(filter, request, response, chain);\r\n        }\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "verifyAuthorized",
  "errType" : null,
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void verifyAuthorized(AuthenticationFilter filter, HttpServletRequest request, HttpServletResponse response, FilterChain chain, boolean newCookie) throws Exception\n{\r\n    final Map<String, String> cookieMap = new HashMap<>();\r\n    Mockito.doAnswer(new Answer<Object>() {\r\n\r\n        @Override\r\n        public Object answer(InvocationOnMock invocation) throws Throwable {\r\n            String cookieHeader = (String) invocation.getArguments()[1];\r\n            parseCookieMap(cookieHeader, cookieMap);\r\n            return null;\r\n        }\r\n    }).when(response).addHeader(Mockito.eq(\"Set-Cookie\"), Mockito.anyString());\r\n    filter.doFilter(request, response, chain);\r\n    if (newCookie) {\r\n        String v = cookieMap.get(AuthenticatedURL.AUTH_COOKIE);\r\n        Assert.assertNotNull(\"cookie missing\", v);\r\n        Assert.assertTrue(v.contains(\"u=\") && v.contains(\"p=\") && v.contains(\"t=\") && v.contains(\"i=\") && v.contains(\"e=\") && v.contains(\"s=\"));\r\n        Mockito.verify(chain).doFilter(any(ServletRequest.class), any(ServletResponse.class));\r\n        SignerSecretProvider secretProvider = StringSignerSecretProviderCreator.newStringSignerSecretProvider();\r\n        Properties secretProviderProps = new Properties();\r\n        secretProviderProps.setProperty(AuthenticationFilter.SIGNATURE_SECRET, \"secret\");\r\n        secretProvider.init(secretProviderProps, null, TOKEN_VALIDITY_SEC);\r\n        Signer signer = new Signer(secretProvider);\r\n        String value = signer.verifyAndExtract(v);\r\n        AuthenticationToken token = AuthenticationToken.parse(value);\r\n        assertThat(token.getMaxInactives(), not(0L));\r\n        assertThat(token.getExpires(), not(0L));\r\n        Assert.assertFalse(\"Token is expired.\", token.isExpired());\r\n    } else {\r\n        Assert.assertTrue(\"cookie is present\", !cookieMap.containsKey(AuthenticatedURL.AUTH_COOKIE));\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "verifyUnauthorized",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void verifyUnauthorized(AuthenticationFilter filter, HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException\n{\r\n    final Map<String, String> cookieMap = new HashMap<String, String>();\r\n    Mockito.doAnswer(new Answer<Object>() {\r\n\r\n        @Override\r\n        public Object answer(InvocationOnMock invocation) throws Throwable {\r\n            String cookieHeader = (String) invocation.getArguments()[1];\r\n            parseCookieMap(cookieHeader, cookieMap);\r\n            return null;\r\n        }\r\n    }).when(response).addHeader(Mockito.eq(\"Set-Cookie\"), Mockito.anyString());\r\n    filter.doFilter(request, response, chain);\r\n    Mockito.verify(response).sendError(Mockito.eq(HttpServletResponse.SC_UNAUTHORIZED), Mockito.anyString());\r\n    Mockito.verify(chain, Mockito.never()).doFilter(any(ServletRequest.class), any(ServletResponse.class));\r\n    Assert.assertTrue(\"cookie is missing\", cookieMap.containsKey(AuthenticatedURL.AUTH_COOKIE));\r\n    Assert.assertEquals(\"\", cookieMap.get(AuthenticatedURL.AUTH_COOKIE));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testDoFilterAuthenticatedInvalidType",
  "errType" : null,
  "containingMethodsNum" : 20,
  "sourceCodeText" : "void testDoFilterAuthenticatedInvalidType() throws Exception\n{\r\n    String secret = \"secret\";\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(\"management.operation.return\")).thenReturn(\"true\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(DummyAuthenticationHandler.class.getName());\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.SIGNATURE_SECRET)).thenReturn(secret);\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, AuthenticationFilter.SIGNATURE_SECRET, \"management.operation.return\")).elements());\r\n        getMockedServletContextWithStringSigner(config);\r\n        filter.init(config);\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(\"http://foo:8080/bar\"));\r\n        AuthenticationToken token = new AuthenticationToken(\"u\", \"p\", \"invalidtype\");\r\n        token.setExpires(System.currentTimeMillis() + TOKEN_VALIDITY_SEC);\r\n        SignerSecretProvider secretProvider = StringSignerSecretProviderCreator.newStringSignerSecretProvider();\r\n        Properties secretProviderProps = new Properties();\r\n        secretProviderProps.setProperty(AuthenticationFilter.SIGNATURE_SECRET, secret);\r\n        secretProvider.init(secretProviderProps, null, TOKEN_VALIDITY_SEC);\r\n        Signer signer = new Signer(secretProvider);\r\n        String tokenSigned = signer.sign(token.toString());\r\n        Cookie cookie = new Cookie(AuthenticatedURL.AUTH_COOKIE, tokenSigned);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        Mockito.when(response.containsHeader(\"WWW-Authenticate\")).thenReturn(true);\r\n        FilterChain chain = Mockito.mock(FilterChain.class);\r\n        verifyUnauthorized(filter, request, response, chain);\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\server",
  "methodName" : "testManagementOperation",
  "errType" : null,
  "containingMethodsNum" : 26,
  "sourceCodeText" : "void testManagementOperation() throws Exception\n{\r\n    AuthenticationFilter filter = new AuthenticationFilter();\r\n    try {\r\n        FilterConfig config = Mockito.mock(FilterConfig.class);\r\n        Mockito.when(config.getInitParameter(\"management.operation.return\")).thenReturn(\"false\");\r\n        Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(DummyAuthenticationHandler.class.getName());\r\n        Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE, \"management.operation.return\")).elements());\r\n        getMockedServletContextWithStringSigner(config);\r\n        filter.init(config);\r\n        HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer(\"http://foo:8080/bar\"));\r\n        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\r\n        FilterChain chain = Mockito.mock(FilterChain.class);\r\n        filter.doFilter(request, response, chain);\r\n        Mockito.verify(response).setStatus(HttpServletResponse.SC_ACCEPTED);\r\n        Mockito.verifyNoMoreInteractions(response);\r\n        Mockito.reset(request);\r\n        Mockito.reset(response);\r\n        AuthenticationToken token = new AuthenticationToken(\"u\", \"p\", \"t\");\r\n        token.setExpires(System.currentTimeMillis() + TOKEN_VALIDITY_SEC);\r\n        SignerSecretProvider secretProvider = StringSignerSecretProviderCreator.newStringSignerSecretProvider();\r\n        Properties secretProviderProps = new Properties();\r\n        secretProviderProps.setProperty(AuthenticationFilter.SIGNATURE_SECRET, \"secret\");\r\n        secretProvider.init(secretProviderProps, null, TOKEN_VALIDITY_SEC);\r\n        Signer signer = new Signer(secretProvider);\r\n        String tokenSigned = signer.sign(token.toString());\r\n        Cookie cookie = new Cookie(AuthenticatedURL.AUTH_COOKIE, tokenSigned);\r\n        Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie });\r\n        Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer());\r\n        filter.doFilter(request, response, chain);\r\n        Mockito.verify(response).setStatus(HttpServletResponse.SC_ACCEPTED);\r\n        Mockito.verifyNoMoreInteractions(response);\r\n    } finally {\r\n        filter.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testGetAndRollSecrets",
  "errType" : null,
  "containingMethodsNum" : 26,
  "sourceCodeText" : "void testGetAndRollSecrets() throws Exception\n{\r\n    long rolloverFrequency = 15 * 1000;\r\n    byte[] secret1 = \"doctor\".getBytes();\r\n    byte[] secret2 = \"who\".getBytes();\r\n    byte[] secret3 = \"tardis\".getBytes();\r\n    TRolloverSignerSecretProvider secretProvider = new TRolloverSignerSecretProvider(new byte[][] { secret1, secret2, secret3 });\r\n    try {\r\n        secretProvider.init(null, null, rolloverFrequency);\r\n        byte[] currentSecret = secretProvider.getCurrentSecret();\r\n        byte[][] allSecrets = secretProvider.getAllSecrets();\r\n        Assert.assertArrayEquals(secret1, currentSecret);\r\n        Assert.assertEquals(2, allSecrets.length);\r\n        Assert.assertArrayEquals(secret1, allSecrets[0]);\r\n        Assert.assertNull(allSecrets[1]);\r\n        Thread.sleep(rolloverFrequency + 2000);\r\n        currentSecret = secretProvider.getCurrentSecret();\r\n        allSecrets = secretProvider.getAllSecrets();\r\n        Assert.assertArrayEquals(secret2, currentSecret);\r\n        Assert.assertEquals(2, allSecrets.length);\r\n        Assert.assertArrayEquals(secret2, allSecrets[0]);\r\n        Assert.assertArrayEquals(secret1, allSecrets[1]);\r\n        Thread.sleep(rolloverFrequency + 2000);\r\n        currentSecret = secretProvider.getCurrentSecret();\r\n        allSecrets = secretProvider.getAllSecrets();\r\n        Assert.assertArrayEquals(secret3, currentSecret);\r\n        Assert.assertEquals(2, allSecrets.length);\r\n        Assert.assertArrayEquals(secret3, allSecrets[0]);\r\n        Assert.assertArrayEquals(secret2, allSecrets[1]);\r\n        Thread.sleep(rolloverFrequency + 2000);\r\n    } finally {\r\n        secretProvider.destroy();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testConstructor",
  "errType" : [ "IllegalArgumentException", "Throwable", "IllegalArgumentException", "Throwable", "IllegalArgumentException", "Throwable", "IllegalArgumentException", "Throwable", "IllegalArgumentException", "Throwable", "IllegalArgumentException", "Throwable" ],
  "containingMethodsNum" : 12,
  "sourceCodeText" : "void testConstructor() throws Exception\n{\r\n    try {\r\n        new AuthToken(null, \"p\", \"t\");\r\n        Assert.fail();\r\n    } catch (IllegalArgumentException ex) {\r\n    } catch (Throwable ex) {\r\n        Assert.fail();\r\n    }\r\n    try {\r\n        new AuthToken(\"\", \"p\", \"t\");\r\n        Assert.fail();\r\n    } catch (IllegalArgumentException ex) {\r\n    } catch (Throwable ex) {\r\n        Assert.fail();\r\n    }\r\n    try {\r\n        new AuthToken(\"u\", null, \"t\");\r\n        Assert.fail();\r\n    } catch (IllegalArgumentException ex) {\r\n    } catch (Throwable ex) {\r\n        Assert.fail();\r\n    }\r\n    try {\r\n        new AuthToken(\"u\", \"\", \"t\");\r\n        Assert.fail();\r\n    } catch (IllegalArgumentException ex) {\r\n    } catch (Throwable ex) {\r\n        Assert.fail();\r\n    }\r\n    try {\r\n        new AuthToken(\"u\", \"p\", null);\r\n        Assert.fail();\r\n    } catch (IllegalArgumentException ex) {\r\n    } catch (Throwable ex) {\r\n        Assert.fail();\r\n    }\r\n    try {\r\n        new AuthToken(\"u\", \"p\", \"\");\r\n        Assert.fail();\r\n    } catch (IllegalArgumentException ex) {\r\n    } catch (Throwable ex) {\r\n        Assert.fail();\r\n    }\r\n    new AuthToken(\"u\", \"p\", \"t\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 6,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testGetters",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void testGetters() throws Exception\n{\r\n    long expires = System.currentTimeMillis() + 50;\r\n    AuthToken token = new AuthToken(\"u\", \"p\", \"t\");\r\n    token.setExpires(expires);\r\n    Assert.assertEquals(\"u\", token.getUserName());\r\n    Assert.assertEquals(\"p\", token.getName());\r\n    Assert.assertEquals(\"t\", token.getType());\r\n    Assert.assertEquals(expires, token.getExpires());\r\n    Assert.assertFalse(token.isExpired());\r\n    Thread.sleep(70);\r\n    Assert.assertTrue(token.isExpired());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testToStringAndParse",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void testToStringAndParse() throws Exception\n{\r\n    long expires = System.currentTimeMillis() + 50;\r\n    AuthToken token = new AuthToken(\"u\", \"p\", \"t\");\r\n    token.setExpires(expires);\r\n    String str = token.toString();\r\n    token = AuthToken.parse(str);\r\n    Assert.assertEquals(\"p\", token.getName());\r\n    Assert.assertEquals(\"t\", token.getType());\r\n    Assert.assertEquals(expires, token.getExpires());\r\n    Assert.assertFalse(token.isExpired());\r\n    Thread.sleep(70);\r\n    Assert.assertTrue(token.isExpired());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-auth\\src\\test\\java\\org\\apache\\hadoop\\security\\authentication\\util",
  "methodName" : "testParseValidAndInvalid",
  "errType" : [ "AuthenticationException", "Exception" ],
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void testParseValidAndInvalid() throws Exception\n{\r\n    long expires = System.currentTimeMillis() + 50;\r\n    AuthToken token = new AuthToken(\"u\", \"p\", \"t\");\r\n    token.setExpires(expires);\r\n    String ostr = token.toString();\r\n    String str1 = \"\\\"\" + ostr + \"\\\"\";\r\n    AuthToken.parse(str1);\r\n    String str2 = ostr + \"&s=1234\";\r\n    AuthToken.parse(str2);\r\n    String str = ostr.substring(0, ostr.indexOf(\"e=\"));\r\n    try {\r\n        AuthToken.parse(str);\r\n        Assert.fail();\r\n    } catch (AuthenticationException ex) {\r\n    } catch (Exception ex) {\r\n        Assert.fail();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
} ]