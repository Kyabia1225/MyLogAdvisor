[ {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "setup",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void setup(Mapper.Context context)\n{\r\n    Configuration conf = context.getConfiguration();\r\n    numDataNodes = conf.getInt(GenerateBlockImagesDriver.NUM_DATANODES_KEY, -1);\r\n    parser = new XMLParser();\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "map",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void map(LongWritable lineNum, Text line, Mapper<LongWritable, Text, IntWritable, BlockInfo>.Context context) throws IOException, InterruptedException\n{\r\n    List<BlockInfo> blockInfos = parser.parseLine(line.toString());\r\n    for (BlockInfo blockInfo : blockInfos) {\r\n        for (short i = 0; i < blockInfo.getReplication(); i++) {\r\n            context.write(new IntWritable((blockIndex + i) % numDataNodes), blockInfo);\r\n        }\r\n        blockIndex++;\r\n        if (blockIndex % 1000000 == 0) {\r\n            LOG.info(\"Processed \" + blockIndex + \" blocks\");\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "parseLine",
  "errType" : null,
  "containingMethodsNum" : 23,
  "sourceCodeText" : "List<BlockInfo> parseLine(String line) throws IOException\n{\r\n    if (currentState == State.DEFAULT) {\r\n        if (line.contains(\"<INodeSection>\")) {\r\n            transitionTo(State.INODE_SECTION);\r\n        } else {\r\n            return Collections.emptyList();\r\n        }\r\n    }\r\n    if (line.contains(\"<inode>\")) {\r\n        transitionTo(State.INODE);\r\n    }\r\n    if (line.contains(\"<type>FILE</type>\")) {\r\n        transitionTo(State.FILE);\r\n    }\r\n    List<String> replicationStrings = valuesFromXMLString(line, \"replication\");\r\n    if (!replicationStrings.isEmpty()) {\r\n        if (replicationStrings.size() > 1) {\r\n            throw new IOException(String.format(\"Found %s replication strings\", replicationStrings.size()));\r\n        }\r\n        transitionTo(State.FILE_WITH_REPLICATION);\r\n        currentReplication = Short.parseShort(replicationStrings.get(0));\r\n    }\r\n    Matcher blockMatcher = BLOCK_PATTERN.matcher(line);\r\n    List<BlockInfo> blockInfos = new ArrayList<>();\r\n    while (blockMatcher.find()) {\r\n        if (currentState != State.FILE_WITH_REPLICATION) {\r\n            throw new IOException(\"Found a block string when in state: \" + currentState);\r\n        }\r\n        long id = Long.parseLong(blockMatcher.group(1));\r\n        long gs = Long.parseLong(blockMatcher.group(2));\r\n        long size = Long.parseLong(blockMatcher.group(3));\r\n        blockInfos.add(new BlockInfo(id, gs, size, currentReplication));\r\n    }\r\n    if (line.contains(\"</inode>\")) {\r\n        transitionTo(State.INODE_SECTION);\r\n    }\r\n    if (line.contains(\"</INodeSection>\")) {\r\n        transitionTo(State.DEFAULT);\r\n    }\r\n    return blockInfos;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "transitionTo",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void transitionTo(State nextState) throws IOException\n{\r\n    if (currentState.transitionAllowed(nextState)) {\r\n        currentState = nextState;\r\n    } else {\r\n        throw new IOException(\"State transition not allowed; from \" + currentState + \" to \" + nextState);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "valuesFromXMLString",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "List<String> valuesFromXMLString(String xml, String field)\n{\r\n    Matcher m = Pattern.compile(\"<\" + field + \">(.+?)</\" + field + \">\").matcher(xml);\r\n    List<String> found = new ArrayList<>();\r\n    while (m.find()) {\r\n        found.add(m.group(1));\r\n    }\r\n    return found;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "run",
  "errType" : null,
  "containingMethodsNum" : 29,
  "sourceCodeText" : "int run(String[] args) throws Exception\n{\r\n    Options options = new Options();\r\n    options.addOption(\"h\", \"help\", false, \"Shows this message\");\r\n    options.addOption(OptionBuilder.withArgName(\"Input path of the XML fsImage\").hasArg().isRequired(true).withDescription(\"Input path to the Hadoop fsImage XML file (required)\").create(FSIMAGE_INPUT_PATH_ARG));\r\n    options.addOption(OptionBuilder.withArgName(\"BlockImage output directory\").hasArg().isRequired(true).withDescription(\"Directory where the generated files containing the \" + \"block listing for each DataNode should be stored (required)\").create(BLOCK_IMAGE_OUTPUT_ARG));\r\n    options.addOption(OptionBuilder.withArgName(\"Number of reducers\").hasArg().isRequired(false).withDescription(\"Number of reducers for this job (defaults to number of datanodes)\").create(NUM_REDUCERS_ARG));\r\n    options.addOption(OptionBuilder.withArgName(\"Number of datanodes\").hasArg().isRequired(true).withDescription(\"Number of DataNodes to create blocks for (required)\").create(NUM_DATANODES_ARG));\r\n    CommandLineParser parser = new PosixParser();\r\n    CommandLine cli = parser.parse(options, args);\r\n    if (cli.hasOption(\"h\")) {\r\n        HelpFormatter formatter = new HelpFormatter();\r\n        formatter.printHelp(200, \"hadoop jar dynamometer-*.jar \" + \"org.apache.hadoop.tools.dynamometer.blockgenerator.\" + \"GenerateBlockImagesDriver [options]\", null, options, null);\r\n        return 0;\r\n    }\r\n    String fsImageInputPath = cli.getOptionValue(FSIMAGE_INPUT_PATH_ARG);\r\n    String blockImageOutputDir = cli.getOptionValue(BLOCK_IMAGE_OUTPUT_ARG);\r\n    int numDataNodes = Integer.parseInt(cli.getOptionValue(NUM_DATANODES_ARG));\r\n    int numReducers = Integer.parseInt(cli.getOptionValue(NUM_REDUCERS_ARG, String.valueOf(numDataNodes)));\r\n    FileSystem fs = FileSystem.get(new URI(blockImageOutputDir), getConf());\r\n    Job job = Job.getInstance(getConf(), \"Create blocksImages for Dynamometer\");\r\n    FileInputFormat.setInputPaths(job, new Path(fsImageInputPath));\r\n    Path blockImagesDir = new Path(blockImageOutputDir);\r\n    fs.delete(blockImagesDir, true);\r\n    FileOutputFormat.setOutputPath(job, blockImagesDir);\r\n    job.getConfiguration().setInt(NUM_DATANODES_KEY, numDataNodes);\r\n    job.setJarByClass(GenerateBlockImagesDriver.class);\r\n    job.setInputFormatClass(NoSplitTextInputFormat.class);\r\n    job.setNumReduceTasks(numReducers);\r\n    LazyOutputFormat.setOutputFormatClass(job, TextOutputFormat.class);\r\n    job.setMapperClass(XMLParserMapper.class);\r\n    job.setReducerClass(GenerateDNBlockInfosReducer.class);\r\n    job.setMapOutputKeyClass(IntWritable.class);\r\n    job.setMapOutputValueClass(BlockInfo.class);\r\n    job.setOutputKeyClass(NullWritable.class);\r\n    job.setOutputValueClass(Text.class);\r\n    boolean success = job.waitForCompletion(true);\r\n    return success ? 0 : 1;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "main",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void main(String[] args) throws Exception\n{\r\n    GenerateBlockImagesDriver driver = new GenerateBlockImagesDriver(new Configuration());\r\n    System.exit(ToolRunner.run(driver, args));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "setup",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void setup(Reducer<IntWritable, BlockInfo, NullWritable, Text>.Context context)\n{\r\n    multiOutputs = new MultipleOutputs<>(context);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "cleanup",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void cleanup(Context context) throws IOException, InterruptedException\n{\r\n    multiOutputs.close();\r\n    multiOutputs = null;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "reduce",
  "errType" : null,
  "containingMethodsNum" : 17,
  "sourceCodeText" : "void reduce(IntWritable key, Iterable<BlockInfo> values, Context context) throws IOException, InterruptedException\n{\r\n    long blockIndex = 0;\r\n    int datanodeId = key.get();\r\n    String dnFile = \"dn\" + datanodeId + \"-a-\" + context.getTaskAttemptID().getId();\r\n    Iterator<BlockInfo> it = values.iterator();\r\n    long startTimestamp = System.currentTimeMillis();\r\n    long endTimestamp;\r\n    Path baseOutputPath = FileOutputFormat.getOutputPath(context);\r\n    String fullPath = new Path(baseOutputPath, dnFile).toString();\r\n    Text out = new Text();\r\n    while (it.hasNext()) {\r\n        BlockInfo blockInfo = it.next();\r\n        String blockLine = blockInfo.getBlockId() + \",\" + blockInfo.getBlockGenerationStamp() + \",\" + blockInfo.getSize();\r\n        out.set(blockLine);\r\n        multiOutputs.write(NullWritable.get(), out, fullPath);\r\n        blockIndex++;\r\n        if (blockIndex % 1000 == 0) {\r\n            context.progress();\r\n            endTimestamp = System.currentTimeMillis();\r\n            System.out.println(\"Time taken to process 1000 records in ms:\" + (endTimestamp - startTimestamp));\r\n            startTimestamp = endTimestamp;\r\n        }\r\n    }\r\n    LOG.info(\"Number of blocks processed:\" + blockIndex);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "getBlockId",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "LongWritable getBlockId()\n{\r\n    return blockId;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "getBlockGenerationStamp",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "LongWritable getBlockGenerationStamp()\n{\r\n    return blockGenerationStamp;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "getSize",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "LongWritable getSize()\n{\r\n    return size;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "getReplication",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "short getReplication()\n{\r\n    return replication;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "write",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void write(DataOutput dataOutput) throws IOException\n{\r\n    blockId.write(dataOutput);\r\n    blockGenerationStamp.write(dataOutput);\r\n    size.write(dataOutput);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "readFields",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void readFields(DataInput dataInput) throws IOException\n{\r\n    blockId.readFields(dataInput);\r\n    blockGenerationStamp.readFields(dataInput);\r\n    size.readFields(dataInput);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "equals",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "boolean equals(Object o)\n{\r\n    if (!(o instanceof BlockInfo)) {\r\n        return false;\r\n    }\r\n    BlockInfo blkInfo = (BlockInfo) o;\r\n    return blkInfo.getBlockId().equals(this.getBlockId()) && blkInfo.getBlockGenerationStamp().equals(this.getBlockGenerationStamp()) && blkInfo.getSize().equals(this.getSize());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-tools\\hadoop-dynamometer\\hadoop-dynamometer-blockgen\\src\\main\\java\\org\\apache\\hadoop\\tools\\dynamometer\\blockgenerator",
  "methodName" : "hashCode",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "int hashCode()\n{\r\n    return blockId.hashCode() + 357 * blockGenerationStamp.hashCode() + 9357 * size.hashCode();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
} ]