[ {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "setUp",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void setUp() throws IOException\n{\r\n    originalOut = System.err;\r\n    memOut = new ByteArrayOutputStream();\r\n    filterOut = new FilterOut(memOut);\r\n    capturedOut = new PrintStream(filterOut);\r\n    System.setErr(capturedOut);\r\n    InputStream is = ThreadUtil.getResourceAsStream(\"log4j-kmsaudit.properties\");\r\n    PropertyConfigurator.configure(is);\r\n    IOUtils.closeStream(is);\r\n    Configuration conf = new Configuration();\r\n    this.kmsAudit = new KMSAudit(conf);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "cleanUp",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void cleanUp()\n{\r\n    System.setErr(originalOut);\r\n    LogManager.resetConfiguration();\r\n    kmsAudit.shutdown();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "getAndResetLogOutput",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "String getAndResetLogOutput()\n{\r\n    capturedOut.flush();\r\n    String logOutput = new String(memOut.toByteArray());\r\n    memOut = new ByteArrayOutputStream();\r\n    filterOut.setOutputStream(memOut);\r\n    return logOutput;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testAggregation",
  "errType" : null,
  "containingMethodsNum" : 23,
  "sourceCodeText" : "void testAggregation() throws Exception\n{\r\n    kmsAudit.ok(luser, KMSOp.DECRYPT_EEK, \"k1\", \"testmsg\");\r\n    kmsAudit.ok(luser, KMSOp.DECRYPT_EEK, \"k1\", \"testmsg\");\r\n    kmsAudit.ok(luser, KMSOp.DECRYPT_EEK, \"k1\", \"testmsg\");\r\n    kmsAudit.ok(luser, KMSOp.DELETE_KEY, \"k1\", \"testmsg\");\r\n    kmsAudit.ok(luser, KMSOp.ROLL_NEW_VERSION, \"k1\", \"testmsg\");\r\n    kmsAudit.ok(luser, KMSOp.INVALIDATE_CACHE, \"k1\", \"testmsg\");\r\n    kmsAudit.ok(luser, KMSOp.DECRYPT_EEK, \"k1\", \"testmsg\");\r\n    kmsAudit.ok(luser, KMSOp.DECRYPT_EEK, \"k1\", \"testmsg\");\r\n    kmsAudit.ok(luser, KMSOp.DECRYPT_EEK, \"k1\", \"testmsg\");\r\n    kmsAudit.evictCacheForTesting();\r\n    kmsAudit.ok(luser, KMSOp.DECRYPT_EEK, \"k1\", \"testmsg\");\r\n    kmsAudit.evictCacheForTesting();\r\n    kmsAudit.ok(luser, KMSOp.REENCRYPT_EEK, \"k1\", \"testmsg\");\r\n    kmsAudit.ok(luser, KMSOp.REENCRYPT_EEK, \"k1\", \"testmsg\");\r\n    kmsAudit.ok(luser, KMSOp.REENCRYPT_EEK, \"k1\", \"testmsg\");\r\n    kmsAudit.evictCacheForTesting();\r\n    kmsAudit.ok(luser, KMSOp.REENCRYPT_EEK_BATCH, \"k1\", \"testmsg\");\r\n    kmsAudit.ok(luser, KMSOp.REENCRYPT_EEK_BATCH, \"k1\", \"testmsg\");\r\n    kmsAudit.evictCacheForTesting();\r\n    String out = getAndResetLogOutput();\r\n    System.out.println(out);\r\n    boolean doesMatch = out.matches(\"OK\\\\[op=DECRYPT_EEK, key=k1, user=luser@REALM, accessCount=1, \" + \"interval=[^m]{1,4}ms\\\\] testmsg\" + \"OK\\\\[op=DELETE_KEY, key=k1, user=luser@REALM\\\\] testmsg\" + \"OK\\\\[op=ROLL_NEW_VERSION, key=k1, user=luser@REALM\\\\] testmsg\" + \"OK\\\\[op=INVALIDATE_CACHE, key=k1, user=luser@REALM\\\\] testmsg\" + \"OK\\\\[op=DECRYPT_EEK, key=k1, user=luser@REALM, accessCount=6, \" + \"interval=[^m]{1,4}ms\\\\] testmsg\" + \"OK\\\\[op=DECRYPT_EEK, key=k1, user=luser@REALM, accessCount=1, \" + \"interval=[^m]{1,4}ms\\\\] testmsg\" + \"OK\\\\[op=REENCRYPT_EEK, key=k1, user=luser@REALM, \" + \"accessCount=1, interval=[^m]{1,4}ms\\\\] testmsg\" + \"OK\\\\[op=REENCRYPT_EEK, key=k1, user=luser@REALM, \" + \"accessCount=3, interval=[^m]{1,4}ms\\\\] testmsg\" + \"OK\\\\[op=REENCRYPT_EEK_BATCH, key=k1, user=luser@REALM\\\\] testmsg\" + \"OK\\\\[op=REENCRYPT_EEK_BATCH, key=k1, user=luser@REALM\\\\] \" + \"testmsg\");\r\n    Assert.assertTrue(doesMatch);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testAggregationUnauth",
  "errType" : null,
  "containingMethodsNum" : 16,
  "sourceCodeText" : "void testAggregationUnauth() throws Exception\n{\r\n    kmsAudit.unauthorized(luser, KMSOp.GENERATE_EEK, \"k2\");\r\n    kmsAudit.evictCacheForTesting();\r\n    kmsAudit.ok(luser, KMSOp.GENERATE_EEK, \"k3\", \"testmsg\");\r\n    kmsAudit.ok(luser, KMSOp.GENERATE_EEK, \"k3\", \"testmsg\");\r\n    kmsAudit.ok(luser, KMSOp.GENERATE_EEK, \"k3\", \"testmsg\");\r\n    kmsAudit.ok(luser, KMSOp.GENERATE_EEK, \"k3\", \"testmsg\");\r\n    kmsAudit.ok(luser, KMSOp.GENERATE_EEK, \"k3\", \"testmsg\");\r\n    kmsAudit.unauthorized(luser, KMSOp.GENERATE_EEK, \"k3\");\r\n    Thread.sleep(1000);\r\n    kmsAudit.ok(luser, KMSOp.GENERATE_EEK, \"k3\", \"testmsg\");\r\n    kmsAudit.evictCacheForTesting();\r\n    String out = getAndResetLogOutput();\r\n    System.out.println(out);\r\n    boolean doesMatch = out.matches(\"UNAUTHORIZED\\\\[op=GENERATE_EEK, key=k2, user=luser@REALM\\\\] \" + \"OK\\\\[op=GENERATE_EEK, key=k3, user=luser@REALM, accessCount=1,\" + \" interval=[^m]{1,4}ms\\\\] testmsg\" + \"OK\\\\[op=GENERATE_EEK, key=k3, user=luser@REALM, accessCount=5,\" + \" interval=[^m]{1,4}ms\\\\] testmsg\" + \"UNAUTHORIZED\\\\[op=GENERATE_EEK, key=k3, user=luser@REALM\\\\] \" + \"OK\\\\[op=GENERATE_EEK, key=k3, user=luser@REALM, accessCount=1,\" + \" interval=[^m]{1,4}ms\\\\] testmsg\");\r\n    doesMatch = doesMatch || out.matches(\"UNAUTHORIZED\\\\[op=GENERATE_EEK, key=k2, user=luser@REALM\\\\] \" + \"OK\\\\[op=GENERATE_EEK, key=k3, user=luser@REALM, accessCount=1,\" + \" interval=[^m]{1,4}ms\\\\] testmsg\" + \"UNAUTHORIZED\\\\[op=GENERATE_EEK, key=k3, user=luser@REALM\\\\] \" + \"OK\\\\[op=GENERATE_EEK, key=k3, user=luser@REALM, accessCount=5,\" + \" interval=[^m]{1,4}ms\\\\] testmsg\" + \"OK\\\\[op=GENERATE_EEK, key=k3, user=luser@REALM, accessCount=1,\" + \" interval=[^m]{1,4}ms\\\\] testmsg\");\r\n    Assert.assertTrue(doesMatch);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testAuditLogFormat",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void testAuditLogFormat() throws Exception\n{\r\n    kmsAudit.ok(luser, KMSOp.GENERATE_EEK, \"k4\", \"testmsg\");\r\n    kmsAudit.ok(luser, KMSOp.GENERATE_EEK, \"testmsg\");\r\n    kmsAudit.evictCacheForTesting();\r\n    kmsAudit.unauthorized(luser, KMSOp.DECRYPT_EEK, \"k4\");\r\n    kmsAudit.error(luser, \"method\", \"url\", \"testmsg\");\r\n    kmsAudit.unauthenticated(\"remotehost\", \"method\", \"url\", \"testmsg\");\r\n    String out = getAndResetLogOutput();\r\n    System.out.println(out);\r\n    Assert.assertTrue(out.matches(\"OK\\\\[op=GENERATE_EEK, key=k4, user=luser@REALM, accessCount=1, \" + \"interval=[^m]{1,4}ms\\\\] testmsg\" + \"OK\\\\[op=GENERATE_EEK, user=luser@REALM\\\\] testmsg\" + \"OK\\\\[op=GENERATE_EEK, key=k4, user=luser@REALM, accessCount=1,\" + \" interval=[^m]{1,4}ms\\\\] testmsg\" + \"UNAUTHORIZED\\\\[op=DECRYPT_EEK, key=k4, user=luser@REALM\\\\] \" + \"ERROR\\\\[user=luser@REALM\\\\] Method:'method' Exception:'testmsg'\" + \"UNAUTHENTICATED RemoteHost:remotehost Method:method URL:url \" + \"ErrorMsg:'testmsg'\"));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testInitAuditLoggers",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void testInitAuditLoggers() throws Exception\n{\r\n    List<KMSAuditLogger> loggers = (List<KMSAuditLogger>) Whitebox.getInternalState(kmsAudit, \"auditLoggers\");\r\n    Assert.assertEquals(1, loggers.size());\r\n    Assert.assertEquals(SimpleKMSAuditLogger.class, loggers.get(0).getClass());\r\n    final Configuration conf = new Configuration();\r\n    conf.set(KMSConfiguration.KMS_AUDIT_LOGGER_KEY, SimpleKMSAuditLogger.class.getName() + \", \" + SimpleKMSAuditLogger.class.getName());\r\n    final KMSAudit audit = new KMSAudit(conf);\r\n    loggers = (List<KMSAuditLogger>) Whitebox.getInternalState(audit, \"auditLoggers\");\r\n    Assert.assertEquals(1, loggers.size());\r\n    Assert.assertEquals(SimpleKMSAuditLogger.class, loggers.get(0).getClass());\r\n    conf.set(KMSConfiguration.KMS_AUDIT_LOGGER_KEY, SimpleKMSAuditLogger.class.getName() + \",unknown\");\r\n    try {\r\n        new KMSAudit(conf);\r\n        Assert.fail(\"loggers configured but invalid, init should fail.\");\r\n    } catch (Exception ex) {\r\n        GenericTestUtils.assertExceptionContains(KMSConfiguration.KMS_AUDIT_LOGGER_KEY, ex);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "setUp",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void setUp() throws Exception\n{\r\n    setUpMiniKdc();\r\n    Configuration conf = new Configuration();\r\n    UserGroupInformation.setConfiguration(conf);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "getTestDir",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "File getTestDir() throws Exception\n{\r\n    File file = new File(\"dummy\");\r\n    file = file.getAbsoluteFile();\r\n    file = file.getParentFile();\r\n    file = new File(file, \"target\");\r\n    file = new File(file, UUID.randomUUID().toString());\r\n    if (!file.mkdirs()) {\r\n        throw new RuntimeException(\"Could not create test directory: \" + file);\r\n    }\r\n    return file;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "createProvider",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "KeyProvider createProvider(URI uri, Configuration conf) throws IOException\n{\r\n    final KeyProvider ret = new LoadBalancingKMSClientProvider(uri, new KMSClientProvider[] { new KMSClientProvider(uri, conf) }, conf);\r\n    providersCreated.add(ret);\r\n    return ret;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "createHAProvider",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "LoadBalancingKMSClientProvider createHAProvider(URI lbUri, URI[] uris, Configuration conf) throws IOException\n{\r\n    KMSClientProvider[] providers = new KMSClientProvider[uris.length];\r\n    for (int i = 0; i < providers.length; i++) {\r\n        providers[i] = new KMSClientProvider(uris[i], conf);\r\n    }\r\n    final LoadBalancingKMSClientProvider ret = new LoadBalancingKMSClientProvider(lbUri, providers, conf);\r\n    providersCreated.add(ret);\r\n    return ret;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "createKMSClientProvider",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "KMSClientProvider createKMSClientProvider(URI uri, Configuration conf) throws IOException\n{\r\n    final KMSClientProvider ret = new KMSClientProvider(uri, conf);\r\n    providersCreated.add(ret);\r\n    return ret;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "runServer",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "T runServer(String keystore, String password, File confDir, KMSCallable<T> callable) throws Exception\n{\r\n    return runServer(-1, keystore, password, confDir, callable);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "runServer",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "T runServer(int port, String keystore, String password, File confDir, KMSCallable<T> callable) throws Exception\n{\r\n    return runServer(new int[] { port }, keystore, password, confDir, callable);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "runServer",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "T runServer(int[] ports, String keystore, String password, File confDir, KMSCallable<T> callable) throws Exception\n{\r\n    MiniKMS.Builder miniKMSBuilder = new MiniKMS.Builder().setKmsConfDir(confDir).setLog4jConfFile(\"log4j.properties\");\r\n    if (keystore != null) {\r\n        miniKMSBuilder.setSslConf(new File(keystore), password);\r\n    }\r\n    final List<MiniKMS> kmsList = new ArrayList<>();\r\n    for (int i = 0; i < ports.length; i++) {\r\n        if (ports[i] > 0) {\r\n            miniKMSBuilder.setPort(ports[i]);\r\n        }\r\n        MiniKMS miniKMS = miniKMSBuilder.build();\r\n        kmsList.add(miniKMS);\r\n        miniKMS.start();\r\n        LOG.info(\"Test KMS running at: \" + miniKMS.getKMSUrl());\r\n        callable.addKMSUrl(miniKMS.getKMSUrl());\r\n    }\r\n    try {\r\n        return callable.call();\r\n    } finally {\r\n        for (MiniKMS miniKMS : kmsList) {\r\n            miniKMS.stop();\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "createBaseKMSConf",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Configuration createBaseKMSConf(File keyStoreDir) throws Exception\n{\r\n    return createBaseKMSConf(keyStoreDir, null);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "createBaseKMSConf",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "Configuration createBaseKMSConf(File keyStoreDir, Configuration conf) throws Exception\n{\r\n    Configuration newConf;\r\n    if (conf == null) {\r\n        newConf = new Configuration(false);\r\n    } else {\r\n        newConf = new Configuration(conf);\r\n    }\r\n    newConf.set(KMSConfiguration.KEY_PROVIDER_URI, \"jceks://file@\" + new Path(keyStoreDir.getAbsolutePath(), \"kms.keystore\").toUri());\r\n    newConf.set(\"hadoop.kms.authentication.type\", \"simple\");\r\n    return newConf;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "writeConf",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void writeConf(File confDir, Configuration conf) throws Exception\n{\r\n    Writer writer = new FileWriter(new File(confDir, KMSConfiguration.KMS_SITE_XML));\r\n    conf.writeXml(writer);\r\n    writer.close();\r\n    writer = new FileWriter(new File(confDir, KMSConfiguration.KMS_ACLS_XML));\r\n    conf.writeXml(writer);\r\n    writer.close();\r\n    writer = new FileWriter(new File(confDir, \"core-site.xml\"));\r\n    new Configuration(false).writeXml(writer);\r\n    writer.close();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "createKMSUri",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "URI createKMSUri(URL kmsUrl) throws Exception\n{\r\n    String str = kmsUrl.toString();\r\n    str = str.replaceFirst(\"://\", \"@\");\r\n    return new URI(\"kms://\" + str);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "createKMSHAUri",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "URI[] createKMSHAUri(URL[] kmsUrls) throws Exception\n{\r\n    URI[] uris = new URI[kmsUrls.length];\r\n    for (int i = 0; i < kmsUrls.length; i++) {\r\n        uris[i] = createKMSUri(kmsUrls[i]);\r\n    }\r\n    return uris;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "setUpMiniKdc",
  "errType" : null,
  "containingMethodsNum" : 14,
  "sourceCodeText" : "void setUpMiniKdc(Properties kdcConf) throws Exception\n{\r\n    File kdcDir = getTestDir();\r\n    kdc = new MiniKdc(kdcConf, kdcDir);\r\n    kdc.start();\r\n    keytab = new File(kdcDir, \"keytab\");\r\n    List<String> principals = new ArrayList<String>();\r\n    principals.add(\"HTTP/localhost\");\r\n    principals.add(\"client\");\r\n    principals.add(\"hdfs\");\r\n    principals.add(\"otheradmin\");\r\n    principals.add(\"client/host\");\r\n    principals.add(\"client1\");\r\n    principals.add(\"foo\");\r\n    for (KMSACLs.Type type : KMSACLs.Type.values()) {\r\n        principals.add(type.toString());\r\n    }\r\n    principals.add(\"CREATE_MATERIAL\");\r\n    principals.add(\"ROLLOVER_MATERIAL\");\r\n    kdc.createPrincipal(keytab, principals.toArray(new String[principals.size()]));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "setUpMiniKdc",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void setUpMiniKdc() throws Exception\n{\r\n    Properties kdcConf = MiniKdc.createConf();\r\n    setUpMiniKdc(kdcConf);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "tearDown",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void tearDown() throws Exception\n{\r\n    if (kdc != null) {\r\n        kdc.stop();\r\n        kdc = null;\r\n    }\r\n    UserGroupInformation.setShouldRenewImmediatelyForTests(false);\r\n    UserGroupInformation.reset();\r\n    if (!providersCreated.isEmpty()) {\r\n        final MultipleIOException.Builder b = new MultipleIOException.Builder();\r\n        for (KeyProvider kp : providersCreated) {\r\n            try {\r\n                kp.close();\r\n            } catch (IOException e) {\r\n                LOG.error(\"Failed to close key provider.\", e);\r\n                b.add(e);\r\n            }\r\n        }\r\n        providersCreated.clear();\r\n        if (!b.isEmpty()) {\r\n            throw b.build();\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "doAs",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "T doAs(String user, final PrivilegedExceptionAction<T> action) throws Exception\n{\r\n    UserGroupInformation.loginUserFromKeytab(user, keytab.getAbsolutePath());\r\n    UserGroupInformation ugi = UserGroupInformation.getLoginUser();\r\n    try {\r\n        return ugi.doAs(action);\r\n    } finally {\r\n        ugi.logoutUserFromKeytab();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "readOutput",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "String readOutput(URLConnection conn) throws IOException\n{\r\n    StringBuilder out = new StringBuilder();\r\n    InputStream in = conn.getInputStream();\r\n    byte[] buffer = new byte[64 * 1024];\r\n    int len = in.read(buffer);\r\n    while (len > 0) {\r\n        out.append(new String(buffer, 0, len));\r\n        len = in.read(buffer);\r\n    }\r\n    return out.toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "assertReFind",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void assertReFind(String re, String value)\n{\r\n    Pattern p = Pattern.compile(re);\r\n    Matcher m = p.matcher(value);\r\n    Assert.assertTrue(\"'\" + p + \"' does not match \" + value, m.find());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "openJMXConnection",
  "errType" : [ "GeneralSecurityException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "URLConnection openJMXConnection(URL baseUrl, boolean kerberos) throws Exception\n{\r\n    URIBuilder b = new URIBuilder(baseUrl + \"/jmx\");\r\n    if (!kerberos) {\r\n        b.addParameter(\"user.name\", \"dr.who\");\r\n    }\r\n    URL url = b.build().toURL();\r\n    LOG.info(\"JMX URL \" + url);\r\n    URLConnection conn = url.openConnection();\r\n    if (sslFactory != null) {\r\n        HttpsURLConnection httpsConn = (HttpsURLConnection) conn;\r\n        try {\r\n            httpsConn.setSSLSocketFactory(sslFactory.createSSLSocketFactory());\r\n        } catch (GeneralSecurityException ex) {\r\n            throw new IOException(ex);\r\n        }\r\n        httpsConn.setHostnameVerifier(sslFactory.getHostnameVerifier());\r\n    }\r\n    return conn;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testJMXQuery",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void testJMXQuery(URL baseUrl, boolean kerberos) throws Exception\n{\r\n    LOG.info(\"Testing JMX\");\r\n    assertReFind(\"\\\"name\\\"\\\\s*:\\\\s*\\\"java.lang:type=Memory\\\"\", readOutput(openJMXConnection(baseUrl, kerberos)));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testStartStop",
  "errType" : [ "GeneralSecurityException" ],
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void testStartStop(final boolean ssl, final boolean kerberos) throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    if (kerberos) {\r\n        conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n    }\r\n    File testDir = getTestDir();\r\n    conf = createBaseKMSConf(testDir, conf);\r\n    final String keystore;\r\n    final String password;\r\n    if (ssl) {\r\n        String sslConfDir = KeyStoreTestUtil.getClasspathDir(TestKMS.class);\r\n        KeyStoreTestUtil.setupSSLConfig(testDir.getAbsolutePath(), sslConfDir, conf, false);\r\n        keystore = testDir.getAbsolutePath() + \"/serverKS.jks\";\r\n        password = \"serverP\";\r\n    } else {\r\n        keystore = null;\r\n        password = null;\r\n    }\r\n    conf.set(\"hadoop.kms.authentication.token.validity\", \"1\");\r\n    if (kerberos) {\r\n        conf.set(\"hadoop.kms.authentication.type\", \"kerberos\");\r\n        conf.set(\"hadoop.kms.authentication.kerberos.keytab\", keytab.getAbsolutePath());\r\n        conf.set(\"hadoop.kms.authentication.kerberos.principal\", \"HTTP/localhost\");\r\n        conf.set(\"hadoop.kms.authentication.kerberos.name.rules\", \"DEFAULT\");\r\n    }\r\n    writeConf(testDir, conf);\r\n    if (ssl) {\r\n        sslFactory = new SSLFactory(SSLFactory.Mode.CLIENT, conf);\r\n        try {\r\n            sslFactory.init();\r\n        } catch (GeneralSecurityException ex) {\r\n            throw new IOException(ex);\r\n        }\r\n    }\r\n    runServer(keystore, password, testDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            URL url = getKMSUrl();\r\n            Assert.assertEquals(keystore != null, url.getProtocol().equals(\"https\"));\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            if (kerberos) {\r\n                for (String user : new String[] { \"client\", \"client/host\" }) {\r\n                    doAs(user, new PrivilegedExceptionAction<Void>() {\r\n\r\n                        @Override\r\n                        public Void run() throws Exception {\r\n                            testJMXQuery(url, kerberos);\r\n                            final KeyProvider kp = createProvider(uri, conf);\r\n                            Assert.assertTrue(kp.getKeys().isEmpty());\r\n                            Thread.sleep(4000);\r\n                            Token<?>[] tokens = ((KeyProviderDelegationTokenExtension.DelegationTokenExtension) kp).addDelegationTokens(\"myuser\", new Credentials());\r\n                            Assert.assertEquals(1, tokens.length);\r\n                            Assert.assertEquals(\"kms-dt\", tokens[0].getKind().toString());\r\n                            return null;\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                testJMXQuery(url, kerberos);\r\n                KeyProvider kp = createProvider(uri, conf);\r\n                Assert.assertTrue(kp.getKeys().isEmpty());\r\n                Thread.sleep(4000);\r\n                Token<?>[] tokens = ((KeyProviderDelegationTokenExtension.DelegationTokenExtension) kp).addDelegationTokens(\"myuser\", new Credentials());\r\n                Assert.assertEquals(1, tokens.length);\r\n                Assert.assertEquals(\"kms-dt\", tokens[0].getKind().toString());\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n    if (sslFactory != null) {\r\n        sslFactory.destroy();\r\n        sslFactory = null;\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testStartStopHttpPseudo",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void testStartStopHttpPseudo() throws Exception\n{\r\n    GenericTestUtils.LogCapturer logs = GenericTestUtils.LogCapturer.captureLogs(LoggerFactory.getLogger(\"com.sun.jersey.server.wadl.generators.AbstractWadlGeneratorGrammarGenerator\"));\r\n    try {\r\n        testStartStop(false, false);\r\n    } finally {\r\n        logs.stopCapturing();\r\n    }\r\n    assertFalse(logs.getOutput().contains(\"Couldn't find grammar element for class\"));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testStartStopHttpsPseudo",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testStartStopHttpsPseudo() throws Exception\n{\r\n    testStartStop(true, false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testStartStopHttpKerberos",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testStartStopHttpKerberos() throws Exception\n{\r\n    testStartStop(false, true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testStartStopHttpsKerberos",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testStartStopHttpsKerberos() throws Exception\n{\r\n    testStartStop(true, true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testSpecialKeyNames",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void testSpecialKeyNames() throws Exception\n{\r\n    final String specialKey = \"key %^[\\n{]}|\\\"<>\\\\\";\r\n    Configuration conf = new Configuration();\r\n    conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n    File confDir = getTestDir();\r\n    conf = createBaseKMSConf(confDir, conf);\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + specialKey + \".ALL\", \"*\");\r\n    writeConf(confDir, conf);\r\n    runServer(null, null, confDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            Configuration conf = new Configuration();\r\n            URI uri = createKMSUri(getKMSUrl());\r\n            KeyProvider kp = createProvider(uri, conf);\r\n            Assert.assertTrue(kp.getKeys().isEmpty());\r\n            Assert.assertEquals(0, kp.getKeysMetadata().length);\r\n            KeyProvider.Options options = new KeyProvider.Options(conf);\r\n            options.setCipher(\"AES/CTR/NoPadding\");\r\n            options.setBitLength(128);\r\n            options.setDescription(\"l1\");\r\n            LOG.info(\"Creating key with name '{}'\", specialKey);\r\n            KeyProvider.KeyVersion kv0 = kp.createKey(specialKey, options);\r\n            Assert.assertNotNull(kv0);\r\n            Assert.assertEquals(specialKey, kv0.getName());\r\n            Assert.assertNotNull(kv0.getVersionName());\r\n            Assert.assertNotNull(kv0.getMaterial());\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testKMSProvider",
  "errType" : [ "Exception", "Exception" ],
  "containingMethodsNum" : 12,
  "sourceCodeText" : "void testKMSProvider() throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n    File confDir = getTestDir();\r\n    conf = createBaseKMSConf(confDir, conf);\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k1.ALL\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k2.MANAGEMENT\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k2.READ\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k3.ALL\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k4.ALL\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k5.ALL\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k6.ALL\", \"*\");\r\n    writeConf(confDir, conf);\r\n    runServer(null, null, confDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            Date started = new Date();\r\n            Configuration conf = new Configuration();\r\n            URI uri = createKMSUri(getKMSUrl());\r\n            KeyProvider kp = createProvider(uri, conf);\r\n            Assert.assertTrue(kp.getKeys().isEmpty());\r\n            Assert.assertEquals(0, kp.getKeysMetadata().length);\r\n            KeyProvider.Options options = new KeyProvider.Options(conf);\r\n            options.setCipher(\"AES/CTR/NoPadding\");\r\n            options.setBitLength(128);\r\n            options.setDescription(\"l1\");\r\n            KeyProvider.KeyVersion kv0 = kp.createKey(\"k1\", options);\r\n            Assert.assertNotNull(kv0);\r\n            Assert.assertNotNull(kv0.getVersionName());\r\n            Assert.assertNotNull(kv0.getMaterial());\r\n            KeyProvider.KeyVersion kv1 = kp.getKeyVersion(kv0.getVersionName());\r\n            Assert.assertEquals(kv0.getVersionName(), kv1.getVersionName());\r\n            Assert.assertNotNull(kv1.getMaterial());\r\n            KeyProvider.KeyVersion cv1 = kp.getCurrentKey(\"k1\");\r\n            Assert.assertEquals(kv0.getVersionName(), cv1.getVersionName());\r\n            Assert.assertNotNull(cv1.getMaterial());\r\n            KeyProvider.Metadata m1 = kp.getMetadata(\"k1\");\r\n            Assert.assertEquals(\"AES/CTR/NoPadding\", m1.getCipher());\r\n            Assert.assertEquals(\"AES\", m1.getAlgorithm());\r\n            Assert.assertEquals(128, m1.getBitLength());\r\n            Assert.assertEquals(1, m1.getVersions());\r\n            Assert.assertNotNull(m1.getCreated());\r\n            Assert.assertTrue(started.before(m1.getCreated()));\r\n            List<KeyProvider.KeyVersion> lkv1 = kp.getKeyVersions(\"k1\");\r\n            Assert.assertEquals(1, lkv1.size());\r\n            Assert.assertEquals(kv0.getVersionName(), lkv1.get(0).getVersionName());\r\n            Assert.assertNotNull(kv1.getMaterial());\r\n            KeyProvider.KeyVersion kv2 = kp.rollNewVersion(\"k1\");\r\n            Assert.assertNotSame(kv0.getVersionName(), kv2.getVersionName());\r\n            Assert.assertNotNull(kv2.getMaterial());\r\n            kv2 = kp.getKeyVersion(kv2.getVersionName());\r\n            boolean eq = true;\r\n            for (int i = 0; i < kv1.getMaterial().length; i++) {\r\n                eq = eq && kv1.getMaterial()[i] == kv2.getMaterial()[i];\r\n            }\r\n            Assert.assertFalse(eq);\r\n            KeyProvider.KeyVersion cv2 = kp.getCurrentKey(\"k1\");\r\n            Assert.assertEquals(kv2.getVersionName(), cv2.getVersionName());\r\n            Assert.assertNotNull(cv2.getMaterial());\r\n            eq = true;\r\n            for (int i = 0; i < kv1.getMaterial().length; i++) {\r\n                eq = eq && cv2.getMaterial()[i] == kv2.getMaterial()[i];\r\n            }\r\n            Assert.assertTrue(eq);\r\n            List<KeyProvider.KeyVersion> lkv2 = kp.getKeyVersions(\"k1\");\r\n            Assert.assertEquals(2, lkv2.size());\r\n            Assert.assertEquals(kv1.getVersionName(), lkv2.get(0).getVersionName());\r\n            Assert.assertNotNull(lkv2.get(0).getMaterial());\r\n            Assert.assertEquals(kv2.getVersionName(), lkv2.get(1).getVersionName());\r\n            Assert.assertNotNull(lkv2.get(1).getMaterial());\r\n            KeyProvider.Metadata m2 = kp.getMetadata(\"k1\");\r\n            Assert.assertEquals(\"AES/CTR/NoPadding\", m2.getCipher());\r\n            Assert.assertEquals(\"AES\", m2.getAlgorithm());\r\n            Assert.assertEquals(128, m2.getBitLength());\r\n            Assert.assertEquals(2, m2.getVersions());\r\n            Assert.assertNotNull(m2.getCreated());\r\n            Assert.assertTrue(started.before(m2.getCreated()));\r\n            List<String> ks1 = kp.getKeys();\r\n            Assert.assertEquals(1, ks1.size());\r\n            Assert.assertEquals(\"k1\", ks1.get(0));\r\n            KeyProvider.Metadata[] kms1 = kp.getKeysMetadata(\"k1\");\r\n            Assert.assertEquals(1, kms1.length);\r\n            Assert.assertEquals(\"AES/CTR/NoPadding\", kms1[0].getCipher());\r\n            Assert.assertEquals(\"AES\", kms1[0].getAlgorithm());\r\n            Assert.assertEquals(128, kms1[0].getBitLength());\r\n            Assert.assertEquals(2, kms1[0].getVersions());\r\n            Assert.assertNotNull(kms1[0].getCreated());\r\n            Assert.assertTrue(started.before(kms1[0].getCreated()));\r\n            KeyProvider.KeyVersion kv = kp.getCurrentKey(\"k1\");\r\n            KeyProviderCryptoExtension kpExt = KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);\r\n            EncryptedKeyVersion ek1 = kpExt.generateEncryptedKey(kv.getName());\r\n            Assert.assertEquals(KeyProviderCryptoExtension.EEK, ek1.getEncryptedKeyVersion().getVersionName());\r\n            Assert.assertNotNull(ek1.getEncryptedKeyVersion().getMaterial());\r\n            Assert.assertEquals(kv.getMaterial().length, ek1.getEncryptedKeyVersion().getMaterial().length);\r\n            KeyProvider.KeyVersion k1 = kpExt.decryptEncryptedKey(ek1);\r\n            Assert.assertEquals(KeyProviderCryptoExtension.EK, k1.getVersionName());\r\n            KeyProvider.KeyVersion k1a = kpExt.decryptEncryptedKey(ek1);\r\n            Assert.assertArrayEquals(k1.getMaterial(), k1a.getMaterial());\r\n            Assert.assertEquals(kv.getMaterial().length, k1.getMaterial().length);\r\n            EncryptedKeyVersion ek2 = kpExt.generateEncryptedKey(kv.getName());\r\n            KeyProvider.KeyVersion k2 = kpExt.decryptEncryptedKey(ek2);\r\n            boolean isEq = true;\r\n            for (int i = 0; isEq && i < ek2.getEncryptedKeyVersion().getMaterial().length; i++) {\r\n                isEq = k2.getMaterial()[i] == k1.getMaterial()[i];\r\n            }\r\n            Assert.assertFalse(isEq);\r\n            kpExt.rollNewVersion(ek1.getEncryptionKeyName());\r\n            EncryptedKeyVersion ek1r = kpExt.reencryptEncryptedKey(ek1);\r\n            assertEquals(KeyProviderCryptoExtension.EEK, ek1r.getEncryptedKeyVersion().getVersionName());\r\n            assertFalse(Arrays.equals(ek1.getEncryptedKeyVersion().getMaterial(), ek1r.getEncryptedKeyVersion().getMaterial()));\r\n            assertEquals(kv.getMaterial().length, ek1r.getEncryptedKeyVersion().getMaterial().length);\r\n            assertEquals(ek1.getEncryptionKeyName(), ek1r.getEncryptionKeyName());\r\n            assertArrayEquals(ek1.getEncryptedKeyIv(), ek1r.getEncryptedKeyIv());\r\n            assertNotEquals(ek1.getEncryptionKeyVersionName(), ek1r.getEncryptionKeyVersionName());\r\n            KeyProvider.KeyVersion k1r = kpExt.decryptEncryptedKey(ek1r);\r\n            assertEquals(KeyProviderCryptoExtension.EK, k1r.getVersionName());\r\n            assertArrayEquals(k1.getMaterial(), k1r.getMaterial());\r\n            assertEquals(kv.getMaterial().length, k1r.getMaterial().length);\r\n            EncryptedKeyVersion ek3 = kpExt.generateEncryptedKey(kv.getName());\r\n            KeyVersion latest = kpExt.rollNewVersion(kv.getName());\r\n            List<EncryptedKeyVersion> ekvs = new ArrayList<>(3);\r\n            ekvs.add(ek1);\r\n            ekvs.add(ek2);\r\n            ekvs.add(ek3);\r\n            ekvs.add(ek1);\r\n            ekvs.add(ek2);\r\n            ekvs.add(ek3);\r\n            kpExt.reencryptEncryptedKeys(ekvs);\r\n            for (EncryptedKeyVersion ekv : ekvs) {\r\n                assertEquals(latest.getVersionName(), ekv.getEncryptionKeyVersionName());\r\n            }\r\n            kp.deleteKey(\"k1\");\r\n            try {\r\n                kpExt.decryptEncryptedKey(ek1);\r\n                Assert.fail(\"Should not be allowed !!\");\r\n            } catch (Exception e) {\r\n                Assert.assertTrue(e.getMessage().contains(\"'k1@1' not found\"));\r\n            }\r\n            Assert.assertNull(kp.getKeyVersion(\"k1\"));\r\n            Assert.assertNull(kp.getKeyVersions(\"k1\"));\r\n            Assert.assertNull(kp.getMetadata(\"k1\"));\r\n            Assert.assertTrue(kp.getKeys().isEmpty());\r\n            Assert.assertEquals(0, kp.getKeysMetadata().length);\r\n            options = new KeyProvider.Options(conf);\r\n            options.setCipher(\"AES/CTR/NoPadding\");\r\n            options.setBitLength(128);\r\n            KeyVersion kVer2 = kp.createKey(\"k2\", options);\r\n            KeyProvider.Metadata meta = kp.getMetadata(\"k2\");\r\n            Assert.assertNull(meta.getDescription());\r\n            Assert.assertEquals(\"k2\", meta.getAttributes().get(\"key.acl.name\"));\r\n            try {\r\n                kpExt = KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);\r\n                kpExt.generateEncryptedKey(kVer2.getName());\r\n                Assert.fail(\"User should not be allowed to encrypt !!\");\r\n            } catch (Exception ex) {\r\n            }\r\n            options = new KeyProvider.Options(conf);\r\n            options.setCipher(\"AES/CTR/NoPadding\");\r\n            options.setBitLength(128);\r\n            options.setDescription(\"d\");\r\n            kp.createKey(\"k3\", options);\r\n            meta = kp.getMetadata(\"k3\");\r\n            Assert.assertEquals(\"d\", meta.getDescription());\r\n            Assert.assertEquals(\"k3\", meta.getAttributes().get(\"key.acl.name\"));\r\n            Map<String, String> attributes = new HashMap<String, String>();\r\n            attributes.put(\"a\", \"A\");\r\n            options = new KeyProvider.Options(conf);\r\n            options.setCipher(\"AES/CTR/NoPadding\");\r\n            options.setBitLength(128);\r\n            attributes.put(\"key.acl.name\", \"k4\");\r\n            options.setAttributes(attributes);\r\n            kp.createKey(\"k4\", options);\r\n            meta = kp.getMetadata(\"k4\");\r\n            Assert.assertNull(meta.getDescription());\r\n            Assert.assertEquals(attributes, meta.getAttributes());\r\n            options = new KeyProvider.Options(conf);\r\n            options.setCipher(\"AES/CTR/NoPadding\");\r\n            options.setBitLength(128);\r\n            options.setDescription(\"d\");\r\n            attributes.put(\"key.acl.name\", \"k5\");\r\n            options.setAttributes(attributes);\r\n            kp.createKey(\"k5\", options);\r\n            meta = kp.getMetadata(\"k5\");\r\n            Assert.assertEquals(\"d\", meta.getDescription());\r\n            Assert.assertEquals(attributes, meta.getAttributes());\r\n            KeyProviderCryptoExtension kpce = KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);\r\n            options = new KeyProvider.Options(conf);\r\n            options.setCipher(\"AES/CTR/NoPadding\");\r\n            options.setBitLength(128);\r\n            kpce.createKey(\"k6\", options);\r\n            EncryptedKeyVersion ekv1 = kpce.generateEncryptedKey(\"k6\");\r\n            kpce.rollNewVersion(\"k6\");\r\n            kpce.invalidateCache(\"k6\");\r\n            EncryptedKeyVersion ekv2 = kpce.generateEncryptedKey(\"k6\");\r\n            assertNotEquals(\"rollover did not generate a new key even after\" + \" queue is drained\", ekv1.getEncryptionKeyVersionName(), ekv2.getEncryptionKeyVersionName());\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testKMSProviderCaching",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void testKMSProviderCaching() throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    File confDir = getTestDir();\r\n    conf = createBaseKMSConf(confDir, conf);\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k1.ALL\", \"*\");\r\n    writeConf(confDir, conf);\r\n    runServer(null, null, confDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final String keyName = \"k1\";\r\n            final String mockVersionName = \"mock\";\r\n            final Configuration conf = new Configuration();\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            KMSClientProvider kmscp = createKMSClientProvider(uri, conf);\r\n            ValueQueue vq = (ValueQueue) Whitebox.getInternalState(kmscp, \"encKeyVersionQueue\");\r\n            LoadingCache<String, LinkedBlockingQueue<EncryptedKeyVersion>> kq = ((LoadingCache<String, LinkedBlockingQueue<EncryptedKeyVersion>>) Whitebox.getInternalState(vq, \"keyQueues\"));\r\n            EncryptedKeyVersion mockEKV = Mockito.mock(EncryptedKeyVersion.class);\r\n            when(mockEKV.getEncryptionKeyName()).thenReturn(keyName);\r\n            when(mockEKV.getEncryptionKeyVersionName()).thenReturn(mockVersionName);\r\n            KeyProvider.Options options = new KeyProvider.Options(conf);\r\n            options.setCipher(\"AES/CTR/NoPadding\");\r\n            options.setBitLength(128);\r\n            options.setDescription(\"l1\");\r\n            KeyProvider.KeyVersion kv0 = kmscp.createKey(keyName, options);\r\n            assertNotNull(kv0.getVersionName());\r\n            assertEquals(\"Default key version name is incorrect.\", \"k1@0\", kmscp.generateEncryptedKey(keyName).getEncryptionKeyVersionName());\r\n            kmscp.invalidateCache(keyName);\r\n            kq.get(keyName).put(mockEKV);\r\n            assertEquals(\"Key version incorrect after invalidating cache + putting\" + \" mock key.\", mockVersionName, kmscp.generateEncryptedKey(keyName).getEncryptionKeyVersionName());\r\n            for (int i = 0; i < 100; ++i) {\r\n                kq.get(keyName).put(mockEKV);\r\n                kmscp.invalidateCache(keyName);\r\n                assertEquals(\"Cache invalidation guarantee failed.\", \"k1@0\", kmscp.generateEncryptedKey(keyName).getEncryptionKeyVersionName());\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testKeyACLs",
  "errType" : [ "Exception", "Exception", "Exception", "Exception", "Exception", "Exception", "Exception", "Exception", "Exception", "Exception", "Exception", "Exception", "Exception", "Exception", "Exception" ],
  "containingMethodsNum" : 28,
  "sourceCodeText" : "void testKeyACLs() throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n    final File testDir = getTestDir();\r\n    conf = createBaseKMSConf(testDir, conf);\r\n    conf.set(\"hadoop.kms.authentication.type\", \"kerberos\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.keytab\", keytab.getAbsolutePath());\r\n    conf.set(\"hadoop.kms.authentication.kerberos.principal\", \"HTTP/localhost\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.name.rules\", \"DEFAULT\");\r\n    for (KMSACLs.Type type : KMSACLs.Type.values()) {\r\n        conf.set(type.getAclConfigKey(), type.toString());\r\n    }\r\n    conf.set(KMSACLs.Type.CREATE.getAclConfigKey(), \"CREATE,ROLLOVER,GET,SET_KEY_MATERIAL,GENERATE_EEK,DECRYPT_EEK\");\r\n    conf.set(KMSACLs.Type.ROLLOVER.getAclConfigKey(), \"CREATE,ROLLOVER,GET,SET_KEY_MATERIAL,GENERATE_EEK,DECRYPT_EEK\");\r\n    conf.set(KMSACLs.Type.GENERATE_EEK.getAclConfigKey(), \"CREATE,ROLLOVER,GET,SET_KEY_MATERIAL,GENERATE_EEK,DECRYPT_EEK\");\r\n    conf.set(KMSACLs.Type.DECRYPT_EEK.getAclConfigKey(), \"CREATE,ROLLOVER,GET,SET_KEY_MATERIAL,GENERATE_EEK\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"test_key.MANAGEMENT\", \"CREATE\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"some_key.MANAGEMENT\", \"ROLLOVER\");\r\n    conf.set(KMSConfiguration.WHITELIST_KEY_ACL_PREFIX + \"MANAGEMENT\", \"DECRYPT_EEK\");\r\n    conf.set(KMSConfiguration.WHITELIST_KEY_ACL_PREFIX + \"ALL\", \"DECRYPT_EEK\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"all_access.ALL\", \"GENERATE_EEK\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"all_access.DECRYPT_EEK\", \"ROLLOVER\");\r\n    conf.set(KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + \"MANAGEMENT\", \"ROLLOVER\");\r\n    conf.set(KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + \"GENERATE_EEK\", \"SOMEBODY\");\r\n    conf.set(KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + \"ALL\", \"ROLLOVER\");\r\n    writeConf(testDir, conf);\r\n    runServer(null, null, testDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME, 128);\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            doAs(\"CREATE\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        Options options = new KeyProvider.Options(conf);\r\n                        Map<String, String> attributes = options.getAttributes();\r\n                        HashMap<String, String> newAttribs = new HashMap<String, String>(attributes);\r\n                        newAttribs.put(\"key.acl.name\", \"test_key\");\r\n                        options.setAttributes(newAttribs);\r\n                        KeyProvider.KeyVersion kv = kp.createKey(\"k0\", options);\r\n                        Assert.assertNull(kv.getMaterial());\r\n                        KeyVersion rollVersion = kp.rollNewVersion(\"k0\");\r\n                        Assert.assertNull(rollVersion.getMaterial());\r\n                        KeyProviderCryptoExtension kpce = KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);\r\n                        try {\r\n                            kpce.generateEncryptedKey(\"k0\");\r\n                            Assert.fail(\"User [CREATE] should not be allowed to generate_eek on k0\");\r\n                        } catch (Exception e) {\r\n                        }\r\n                        newAttribs = new HashMap<String, String>(attributes);\r\n                        newAttribs.put(\"key.acl.name\", \"all_access\");\r\n                        options.setAttributes(newAttribs);\r\n                        try {\r\n                            kp.createKey(\"kx\", options);\r\n                            Assert.fail(\"User [CREATE] should not be allowed to create kx\");\r\n                        } catch (Exception e) {\r\n                        }\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"DECRYPT_EEK\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        Options options = new KeyProvider.Options(conf);\r\n                        Map<String, String> attributes = options.getAttributes();\r\n                        HashMap<String, String> newAttribs = new HashMap<String, String>(attributes);\r\n                        newAttribs.put(\"key.acl.name\", \"some_key\");\r\n                        options.setAttributes(newAttribs);\r\n                        KeyProvider.KeyVersion kv = kp.createKey(\"kk0\", options);\r\n                        Assert.assertNull(kv.getMaterial());\r\n                        KeyVersion rollVersion = kp.rollNewVersion(\"kk0\");\r\n                        Assert.assertNull(rollVersion.getMaterial());\r\n                        KeyProviderCryptoExtension kpce = KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);\r\n                        try {\r\n                            kpce.generateEncryptedKey(\"kk0\");\r\n                            Assert.fail(\"User [DECRYPT_EEK] should not be allowed to generate_eek on kk0\");\r\n                        } catch (Exception e) {\r\n                        }\r\n                        newAttribs = new HashMap<String, String>(attributes);\r\n                        newAttribs.put(\"key.acl.name\", \"all_access\");\r\n                        options.setAttributes(newAttribs);\r\n                        kp.createKey(\"kkx\", options);\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"ROLLOVER\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        Options options = new KeyProvider.Options(conf);\r\n                        Map<String, String> attributes = options.getAttributes();\r\n                        HashMap<String, String> newAttribs = new HashMap<String, String>(attributes);\r\n                        newAttribs.put(\"key.acl.name\", \"test_key2\");\r\n                        options.setAttributes(newAttribs);\r\n                        KeyProvider.KeyVersion kv = kp.createKey(\"k1\", options);\r\n                        Assert.assertNull(kv.getMaterial());\r\n                        KeyVersion rollVersion = kp.rollNewVersion(\"k1\");\r\n                        Assert.assertNull(rollVersion.getMaterial());\r\n                        try {\r\n                            kp.rollNewVersion(\"k0\");\r\n                            Assert.fail(\"User [ROLLOVER] should not be allowed to rollover k0\");\r\n                        } catch (Exception e) {\r\n                        }\r\n                        KeyProviderCryptoExtension kpce = KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);\r\n                        try {\r\n                            kpce.generateEncryptedKey(\"k1\");\r\n                            Assert.fail(\"User [ROLLOVER] should not be allowed to generate_eek on k1\");\r\n                        } catch (Exception e) {\r\n                        }\r\n                        newAttribs = new HashMap<String, String>(attributes);\r\n                        newAttribs.put(\"key.acl.name\", \"all_access\");\r\n                        options.setAttributes(newAttribs);\r\n                        try {\r\n                            kp.createKey(\"kx\", options);\r\n                            Assert.fail(\"User [ROLLOVER] should not be allowed to create kx\");\r\n                        } catch (Exception e) {\r\n                        }\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"GET\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        Options options = new KeyProvider.Options(conf);\r\n                        Map<String, String> attributes = options.getAttributes();\r\n                        HashMap<String, String> newAttribs = new HashMap<String, String>(attributes);\r\n                        newAttribs.put(\"key.acl.name\", \"test_key\");\r\n                        options.setAttributes(newAttribs);\r\n                        try {\r\n                            kp.createKey(\"k2\", options);\r\n                            Assert.fail(\"User [GET] should not be allowed to create key..\");\r\n                        } catch (Exception e) {\r\n                        }\r\n                        newAttribs = new HashMap<String, String>(attributes);\r\n                        newAttribs.put(\"key.acl.name\", \"all_access\");\r\n                        options.setAttributes(newAttribs);\r\n                        try {\r\n                            kp.createKey(\"kx\", options);\r\n                            Assert.fail(\"User [GET] should not be allowed to create kx\");\r\n                        } catch (Exception e) {\r\n                        }\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            final EncryptedKeyVersion ekv = doAs(\"GENERATE_EEK\", new PrivilegedExceptionAction<EncryptedKeyVersion>() {\r\n\r\n                @Override\r\n                public EncryptedKeyVersion run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        Options options = new KeyProvider.Options(conf);\r\n                        Map<String, String> attributes = options.getAttributes();\r\n                        HashMap<String, String> newAttribs = new HashMap<String, String>(attributes);\r\n                        newAttribs.put(\"key.acl.name\", \"all_access\");\r\n                        options.setAttributes(newAttribs);\r\n                        kp.createKey(\"kx\", options);\r\n                        KeyProviderCryptoExtension kpce = KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);\r\n                        try {\r\n                            return kpce.generateEncryptedKey(\"kx\");\r\n                        } catch (Exception e) {\r\n                            Assert.fail(\"User [GENERATE_EEK] should be allowed to generate_eek on kx\");\r\n                        }\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"ROLLOVER\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        KeyProviderCryptoExtension kpce = KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);\r\n                        kpce.decryptEncryptedKey(ekv);\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    });\r\n    conf.set(KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + \"MANAGEMENT\", \"\");\r\n    conf.set(KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + \"GENERATE_EEK\", \"*\");\r\n    writeConf(testDir, conf);\r\n    runServer(null, null, testDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME, 128);\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            doAs(\"GENERATE_EEK\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    KeyProviderCryptoExtension kpce = KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);\r\n                    EncryptedKeyVersion ekv = kpce.generateEncryptedKey(\"k1\");\r\n                    kpce.reencryptEncryptedKey(ekv);\r\n                    List<EncryptedKeyVersion> ekvs = new ArrayList<>(2);\r\n                    ekvs.add(ekv);\r\n                    ekvs.add(ekv);\r\n                    kpce.reencryptEncryptedKeys(ekvs);\r\n                    return null;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 15,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testKMSRestartKerberosAuth",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testKMSRestartKerberosAuth() throws Exception\n{\r\n    doKMSRestart(true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testKMSRestartSimpleAuth",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testKMSRestartSimpleAuth() throws Exception\n{\r\n    doKMSRestart(false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "doKMSRestart",
  "errType" : null,
  "containingMethodsNum" : 21,
  "sourceCodeText" : "void doKMSRestart(boolean useKrb) throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n    final File testDir = getTestDir();\r\n    conf = createBaseKMSConf(testDir, conf);\r\n    if (useKrb) {\r\n        conf.set(\"hadoop.kms.authentication.type\", \"kerberos\");\r\n    }\r\n    conf.set(\"hadoop.kms.authentication.kerberos.keytab\", keytab.getAbsolutePath());\r\n    conf.set(\"hadoop.kms.authentication.kerberos.principal\", \"HTTP/localhost\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.name.rules\", \"DEFAULT\");\r\n    for (KMSACLs.Type type : KMSACLs.Type.values()) {\r\n        conf.set(type.getAclConfigKey(), type.toString());\r\n    }\r\n    conf.set(KMSACLs.Type.CREATE.getAclConfigKey(), KMSACLs.Type.CREATE.toString() + \",SET_KEY_MATERIAL\");\r\n    conf.set(KMSACLs.Type.ROLLOVER.getAclConfigKey(), KMSACLs.Type.ROLLOVER.toString() + \",SET_KEY_MATERIAL\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k0.ALL\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k1.ALL\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k2.ALL\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k3.ALL\", \"*\");\r\n    writeConf(testDir, conf);\r\n    KMSCallable<KeyProvider> c = new KMSCallable<KeyProvider>() {\r\n\r\n        @Override\r\n        public KeyProvider call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME, 128);\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            final KeyProvider kp = doAs(\"SET_KEY_MATERIAL\", new PrivilegedExceptionAction<KeyProvider>() {\r\n\r\n                @Override\r\n                public KeyProvider run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    kp.createKey(\"k1\", new byte[16], new KeyProvider.Options(conf));\r\n                    return kp;\r\n                }\r\n            });\r\n            return kp;\r\n        }\r\n    };\r\n    final KeyProvider retKp = runServer(null, null, testDir, c);\r\n    runServer(c.getKMSUrl().getPort(), null, null, testDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME, 128);\r\n            doAs(\"SET_KEY_MATERIAL\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    retKp.createKey(\"k2\", new byte[16], new KeyProvider.Options(conf));\r\n                    retKp.createKey(\"k3\", new byte[16], new KeyProvider.Options(conf));\r\n                    return null;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testKMSAuthFailureRetry",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 19,
  "sourceCodeText" : "void testKMSAuthFailureRetry() throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n    final File testDir = getTestDir();\r\n    conf = createBaseKMSConf(testDir, conf);\r\n    conf.set(\"hadoop.kms.authentication.kerberos.keytab\", keytab.getAbsolutePath());\r\n    conf.set(\"hadoop.kms.authentication.kerberos.principal\", \"HTTP/localhost\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.name.rules\", \"DEFAULT\");\r\n    conf.set(\"hadoop.kms.authentication.token.validity\", \"1\");\r\n    for (KMSACLs.Type type : KMSACLs.Type.values()) {\r\n        conf.set(type.getAclConfigKey(), type.toString());\r\n    }\r\n    conf.set(KMSACLs.Type.CREATE.getAclConfigKey(), KMSACLs.Type.CREATE.toString() + \",SET_KEY_MATERIAL\");\r\n    conf.set(KMSACLs.Type.ROLLOVER.getAclConfigKey(), KMSACLs.Type.ROLLOVER.toString() + \",SET_KEY_MATERIAL\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k0.ALL\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k1.ALL\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k2.ALL\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k3.ALL\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k4.ALL\", \"*\");\r\n    writeConf(testDir, conf);\r\n    runServer(null, null, testDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME, 128);\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            doAs(\"SET_KEY_MATERIAL\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    kp.createKey(\"k0\", new byte[16], new KeyProvider.Options(conf));\r\n                    kp.createKey(\"k1\", new byte[16], new KeyProvider.Options(conf));\r\n                    Thread.sleep(3500);\r\n                    kp.createKey(\"k2\", new byte[16], new KeyProvider.Options(conf));\r\n                    return null;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    });\r\n    runServer(null, null, testDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME, 128);\r\n            conf.setInt(KMSClientProvider.AUTH_RETRY, 0);\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            doAs(\"SET_KEY_MATERIAL\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    kp.createKey(\"k3\", new byte[16], new KeyProvider.Options(conf));\r\n                    Thread.sleep(3500);\r\n                    try {\r\n                        kp.createKey(\"k4\", new byte[16], new KeyProvider.Options(conf));\r\n                        Assert.fail(\"This should not succeed..\");\r\n                    } catch (IOException e) {\r\n                        Assert.assertTrue(\"HTTP exception must be a 401 : \" + e.getMessage(), e.getMessage().contains(\"401\"));\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testACLs",
  "errType" : [ "AuthorizationException", "Exception", "AuthorizationException", "Exception", "AuthorizationException", "Exception", "AuthorizationException", "Exception", "AuthorizationException", "Exception", "AuthorizationException", "Exception", "AuthorizationException", "Exception", "AuthorizationException", "Exception", "AuthorizationException", "Exception", "AuthorizationException", "Exception", "Exception", "Exception", "Exception", "Exception", "Exception", "Exception", "Exception", "Exception", "Exception", "Exception", "AuthorizationException", "Exception", "IOException", "AuthorizationException", "AuthorizationException" ],
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void testACLs() throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n    final File testDir = getTestDir();\r\n    conf = createBaseKMSConf(testDir, conf);\r\n    conf.set(\"hadoop.kms.authentication.type\", \"kerberos\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.keytab\", keytab.getAbsolutePath());\r\n    conf.set(\"hadoop.kms.authentication.kerberos.principal\", \"HTTP/localhost\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.name.rules\", \"DEFAULT\");\r\n    for (KMSACLs.Type type : KMSACLs.Type.values()) {\r\n        conf.set(type.getAclConfigKey(), type.toString());\r\n    }\r\n    conf.set(KMSACLs.Type.CREATE.getAclConfigKey(), KMSACLs.Type.CREATE.toString() + \",SET_KEY_MATERIAL\");\r\n    conf.set(KMSACLs.Type.ROLLOVER.getAclConfigKey(), KMSACLs.Type.ROLLOVER.toString() + \",SET_KEY_MATERIAL\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k0.ALL\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k1.ALL\", \"*\");\r\n    writeConf(testDir, conf);\r\n    runServer(null, null, testDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME, 128);\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            doAs(\"client\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        kp.createKey(\"k\", new KeyProvider.Options(conf));\r\n                        Assert.fail();\r\n                    } catch (AuthorizationException ex) {\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    try {\r\n                        kp.createKey(\"k\", new byte[16], new KeyProvider.Options(conf));\r\n                        Assert.fail();\r\n                    } catch (AuthorizationException ex) {\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    try {\r\n                        kp.rollNewVersion(\"k\");\r\n                        Assert.fail();\r\n                    } catch (AuthorizationException ex) {\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    try {\r\n                        kp.rollNewVersion(\"k\", new byte[16]);\r\n                        Assert.fail();\r\n                    } catch (AuthorizationException ex) {\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    try {\r\n                        kp.getKeys();\r\n                        Assert.fail();\r\n                    } catch (AuthorizationException ex) {\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    try {\r\n                        kp.getKeysMetadata(\"k\");\r\n                        Assert.fail();\r\n                    } catch (AuthorizationException ex) {\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    try {\r\n                        kp.getKeyVersion(\"k@0\");\r\n                        Assert.fail();\r\n                    } catch (AuthorizationException ex) {\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    try {\r\n                        kp.getCurrentKey(\"k\");\r\n                        Assert.fail();\r\n                    } catch (AuthorizationException ex) {\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    try {\r\n                        kp.getMetadata(\"k\");\r\n                        Assert.fail();\r\n                    } catch (AuthorizationException ex) {\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    try {\r\n                        kp.getKeyVersions(\"k\");\r\n                        Assert.fail();\r\n                    } catch (AuthorizationException ex) {\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"CREATE\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        KeyProvider.KeyVersion kv = kp.createKey(\"k0\", new KeyProvider.Options(conf));\r\n                        Assert.assertNull(kv.getMaterial());\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"DELETE\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        kp.deleteKey(\"k0\");\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"SET_KEY_MATERIAL\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        KeyProvider.KeyVersion kv = kp.createKey(\"k1\", new byte[16], new KeyProvider.Options(conf));\r\n                        Assert.assertNull(kv.getMaterial());\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"ROLLOVER\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        KeyProvider.KeyVersion kv = kp.rollNewVersion(\"k1\");\r\n                        Assert.assertNull(kv.getMaterial());\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"SET_KEY_MATERIAL\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        KeyProvider.KeyVersion kv = kp.rollNewVersion(\"k1\", new byte[16]);\r\n                        Assert.assertNull(kv.getMaterial());\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            final KeyVersion currKv = doAs(\"GET\", new PrivilegedExceptionAction<KeyVersion>() {\r\n\r\n                @Override\r\n                public KeyVersion run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        kp.getKeyVersion(\"k1@0\");\r\n                        KeyVersion kv = kp.getCurrentKey(\"k1\");\r\n                        return kv;\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.toString());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            final EncryptedKeyVersion encKv = doAs(\"GENERATE_EEK\", new PrivilegedExceptionAction<EncryptedKeyVersion>() {\r\n\r\n                @Override\r\n                public EncryptedKeyVersion run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        KeyProviderCryptoExtension kpCE = KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);\r\n                        EncryptedKeyVersion ek1 = kpCE.generateEncryptedKey(currKv.getName());\r\n                        return ek1;\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.toString());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"GENERATE_EEK\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    KeyProviderCryptoExtension kpCE = KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);\r\n                    kpCE.reencryptEncryptedKey(encKv);\r\n                    List<EncryptedKeyVersion> ekvs = new ArrayList<>(2);\r\n                    ekvs.add(encKv);\r\n                    ekvs.add(encKv);\r\n                    kpCE.reencryptEncryptedKeys(ekvs);\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"DECRYPT_EEK\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        KeyProviderCryptoExtension kpCE = KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);\r\n                        kpCE.decryptEncryptedKey(encKv);\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"GET_KEYS\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        kp.getKeys();\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"GET_METADATA\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        kp.getMetadata(\"k1\");\r\n                        kp.getKeysMetadata(\"k1\");\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            KMSWebApp.getACLs().stopReloader();\r\n            GenericTestUtils.setLogLevel(KMSConfiguration.LOG, Level.TRACE);\r\n            conf.set(KMSACLs.Type.CREATE.getAclConfigKey(), \"foo\");\r\n            conf.set(KMSACLs.Type.GENERATE_EEK.getAclConfigKey(), \"foo\");\r\n            writeConf(testDir, conf);\r\n            KMSWebApp.getACLs().forceNextReloadForTesting();\r\n            KMSWebApp.getACLs().run();\r\n            doAs(\"CREATE\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    try {\r\n                        KeyProvider kp = createProvider(uri, conf);\r\n                        KeyProvider.KeyVersion kv = kp.createKey(\"k2\", new KeyProvider.Options(conf));\r\n                        Assert.fail();\r\n                    } catch (AuthorizationException ex) {\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"GENERATE_EEK\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        KeyProviderCryptoExtension kpCE = KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);\r\n                        kpCE.generateEncryptedKey(\"k1\");\r\n                    } catch (IOException ex) {\r\n                        if (ex.getCause().getCause() instanceof AuthorizationException) {\r\n                            LOG.info(\"Caught expected exception.\", ex);\r\n                        } else {\r\n                            throw ex;\r\n                        }\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"GENERATE_EEK\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        KeyProviderCryptoExtension kpCE = KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);\r\n                        kpCE.reencryptEncryptedKey(encKv);\r\n                        fail(\"Should not have been able to reencryptEncryptedKey\");\r\n                    } catch (AuthorizationException ex) {\r\n                        LOG.info(\"reencryptEncryptedKey caught expected exception.\", ex);\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"GENERATE_EEK\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    try {\r\n                        KeyProviderCryptoExtension kpCE = KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);\r\n                        List<EncryptedKeyVersion> ekvs = new ArrayList<>(2);\r\n                        ekvs.add(encKv);\r\n                        ekvs.add(encKv);\r\n                        kpCE.reencryptEncryptedKeys(ekvs);\r\n                        fail(\"Should not have been able to reencryptEncryptedKeys\");\r\n                    } catch (AuthorizationException ex) {\r\n                        LOG.info(\"reencryptEncryptedKeys caught expected exception.\", ex);\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 24,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testKMSBlackList",
  "errType" : [ "Exception", "Exception", "Exception" ],
  "containingMethodsNum" : 17,
  "sourceCodeText" : "void testKMSBlackList() throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n    File testDir = getTestDir();\r\n    conf = createBaseKMSConf(testDir, conf);\r\n    conf.set(\"hadoop.kms.authentication.type\", \"kerberos\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.keytab\", keytab.getAbsolutePath());\r\n    conf.set(\"hadoop.kms.authentication.kerberos.principal\", \"HTTP/localhost\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.name.rules\", \"DEFAULT\");\r\n    for (KMSACLs.Type type : KMSACLs.Type.values()) {\r\n        conf.set(type.getAclConfigKey(), \" \");\r\n    }\r\n    conf.set(KMSACLs.Type.CREATE.getAclConfigKey(), \"client,hdfs,otheradmin\");\r\n    conf.set(KMSACLs.Type.GENERATE_EEK.getAclConfigKey(), \"client,hdfs,otheradmin\");\r\n    conf.set(KMSACLs.Type.DECRYPT_EEK.getAclConfigKey(), \"client,hdfs,otheradmin\");\r\n    conf.set(KMSACLs.Type.DECRYPT_EEK.getBlacklistConfigKey(), \"hdfs,otheradmin\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"ck0.ALL\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"ck1.ALL\", \"*\");\r\n    writeConf(testDir, conf);\r\n    runServer(null, null, testDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME, 128);\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            doAs(\"client\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    try {\r\n                        KeyProvider kp = createProvider(uri, conf);\r\n                        KeyProvider.KeyVersion kv = kp.createKey(\"ck0\", new KeyProvider.Options(conf));\r\n                        EncryptedKeyVersion eek = ((CryptoExtension) kp).generateEncryptedKey(\"ck0\");\r\n                        ((CryptoExtension) kp).decryptEncryptedKey(eek);\r\n                        Assert.assertNull(kv.getMaterial());\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"hdfs\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    try {\r\n                        KeyProvider kp = createProvider(uri, conf);\r\n                        KeyProvider.KeyVersion kv = kp.createKey(\"ck1\", new KeyProvider.Options(conf));\r\n                        EncryptedKeyVersion eek = ((CryptoExtension) kp).generateEncryptedKey(\"ck1\");\r\n                        ((CryptoExtension) kp).decryptEncryptedKey(eek);\r\n                        Assert.fail(\"admin user must not be allowed to decrypt !!\");\r\n                    } catch (Exception ex) {\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"otheradmin\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    try {\r\n                        KeyProvider kp = createProvider(uri, conf);\r\n                        KeyProvider.KeyVersion kv = kp.createKey(\"ck2\", new KeyProvider.Options(conf));\r\n                        EncryptedKeyVersion eek = ((CryptoExtension) kp).generateEncryptedKey(\"ck2\");\r\n                        ((CryptoExtension) kp).decryptEncryptedKey(eek);\r\n                        Assert.fail(\"admin user must not be allowed to decrypt !!\");\r\n                    } catch (Exception ex) {\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 3,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testServicePrincipalACLs",
  "errType" : [ "Exception", "Exception" ],
  "containingMethodsNum" : 13,
  "sourceCodeText" : "void testServicePrincipalACLs() throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n    File testDir = getTestDir();\r\n    conf = createBaseKMSConf(testDir, conf);\r\n    conf.set(\"hadoop.kms.authentication.type\", \"kerberos\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.keytab\", keytab.getAbsolutePath());\r\n    conf.set(\"hadoop.kms.authentication.kerberos.principal\", \"HTTP/localhost\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.name.rules\", \"DEFAULT\");\r\n    for (KMSACLs.Type type : KMSACLs.Type.values()) {\r\n        conf.set(type.getAclConfigKey(), \" \");\r\n    }\r\n    conf.set(KMSACLs.Type.CREATE.getAclConfigKey(), \"client\");\r\n    conf.set(KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + \"MANAGEMENT\", \"client,client/host\");\r\n    writeConf(testDir, conf);\r\n    runServer(null, null, testDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME, 128);\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            doAs(\"client\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    try {\r\n                        KeyProvider kp = createProvider(uri, conf);\r\n                        KeyProvider.KeyVersion kv = kp.createKey(\"ck0\", new KeyProvider.Options(conf));\r\n                        Assert.assertNull(kv.getMaterial());\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"client/host\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    try {\r\n                        KeyProvider kp = createProvider(uri, conf);\r\n                        KeyProvider.KeyVersion kv = kp.createKey(\"ck1\", new KeyProvider.Options(conf));\r\n                        Assert.assertNull(kv.getMaterial());\r\n                    } catch (Exception ex) {\r\n                        Assert.fail(ex.getMessage());\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testKMSTimeout",
  "errType" : [ "Exception", "SocketTimeoutException", "IOException", "SocketTimeoutException", "IOException", "SocketTimeoutException", "IOException" ],
  "containingMethodsNum" : 18,
  "sourceCodeText" : "void testKMSTimeout() throws Exception\n{\r\n    File confDir = getTestDir();\r\n    Configuration conf = createBaseKMSConf(confDir);\r\n    conf.setInt(CommonConfigurationKeysPublic.KMS_CLIENT_TIMEOUT_SECONDS, 1);\r\n    writeConf(confDir, conf);\r\n    ServerSocket sock;\r\n    int port;\r\n    try {\r\n        sock = new ServerSocket(0, 50, InetAddress.getByName(\"localhost\"));\r\n        port = sock.getLocalPort();\r\n    } catch (Exception e) {\r\n        return;\r\n    }\r\n    URL url = new URL(\"http://localhost:\" + port + \"/kms\");\r\n    URI uri = createKMSUri(url);\r\n    boolean caughtTimeout = false;\r\n    try {\r\n        KeyProvider kp = createProvider(uri, conf);\r\n        kp.getKeys();\r\n    } catch (SocketTimeoutException e) {\r\n        caughtTimeout = true;\r\n    } catch (IOException e) {\r\n        Assert.assertTrue(\"Caught unexpected exception\" + e.toString(), false);\r\n    }\r\n    caughtTimeout = false;\r\n    try {\r\n        KeyProvider kp = createProvider(uri, conf);\r\n        KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp).generateEncryptedKey(\"a\");\r\n    } catch (SocketTimeoutException e) {\r\n        caughtTimeout = true;\r\n    } catch (IOException e) {\r\n        Assert.assertTrue(\"Caught unexpected exception\" + e.toString(), false);\r\n    }\r\n    caughtTimeout = false;\r\n    try {\r\n        KeyProvider kp = createProvider(uri, conf);\r\n        KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp).decryptEncryptedKey(new KMSClientProvider.KMSEncryptedKeyVersion(\"a\", \"a\", new byte[] { 1, 2 }, \"EEK\", new byte[] { 1, 2 }));\r\n    } catch (SocketTimeoutException e) {\r\n        caughtTimeout = true;\r\n    } catch (IOException e) {\r\n        Assert.assertTrue(\"Caught unexpected exception\" + e.toString(), false);\r\n    }\r\n    Assert.assertTrue(caughtTimeout);\r\n    sock.close();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 4,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testDelegationTokenAccess",
  "errType" : [ "IOException", "IOException" ],
  "containingMethodsNum" : 11,
  "sourceCodeText" : "void testDelegationTokenAccess() throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n    final File testDir = getTestDir();\r\n    conf = createBaseKMSConf(testDir, conf);\r\n    conf.set(\"hadoop.kms.authentication.type\", \"kerberos\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.keytab\", keytab.getAbsolutePath());\r\n    conf.set(\"hadoop.kms.authentication.kerberos.principal\", \"HTTP/localhost\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.name.rules\", \"DEFAULT\");\r\n    final String keyA = \"key_a\";\r\n    final String keyD = \"key_d\";\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + keyA + \".ALL\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + keyD + \".ALL\", \"*\");\r\n    writeConf(testDir, conf);\r\n    runServer(null, null, testDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME, 128);\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            final Credentials credentials = new Credentials();\r\n            final UserGroupInformation nonKerberosUgi = UserGroupInformation.getCurrentUser();\r\n            try {\r\n                KeyProvider kp = createProvider(uri, conf);\r\n                kp.createKey(keyA, new KeyProvider.Options(conf));\r\n            } catch (IOException ex) {\r\n                System.out.println(ex.getMessage());\r\n            }\r\n            doAs(\"client\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    KeyProviderDelegationTokenExtension kpdte = KeyProviderDelegationTokenExtension.createKeyProviderDelegationTokenExtension(kp);\r\n                    kpdte.addDelegationTokens(\"foo\", credentials);\r\n                    return null;\r\n                }\r\n            });\r\n            nonKerberosUgi.addCredentials(credentials);\r\n            try {\r\n                KeyProvider kp = createProvider(uri, conf);\r\n                kp.createKey(keyA, new KeyProvider.Options(conf));\r\n            } catch (IOException ex) {\r\n                System.out.println(ex.getMessage());\r\n            }\r\n            nonKerberosUgi.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    kp.createKey(keyD, new KeyProvider.Options(conf));\r\n                    return null;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testGetDelegationTokenByProxyUser",
  "errType" : null,
  "containingMethodsNum" : 13,
  "sourceCodeText" : "void testGetDelegationTokenByProxyUser() throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    conf.set(\"hadoop.security.auth_to_local.mechanism\", \"mit\");\r\n    conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n    UserGroupInformation.setConfiguration(conf);\r\n    final File testDir = getTestDir();\r\n    conf = createBaseKMSConf(testDir, conf);\r\n    conf.set(\"hadoop.kms.authentication.type\", \"kerberos\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.keytab\", keytab.getAbsolutePath());\r\n    conf.set(\"hadoop.kms.authentication.kerberos.principal\", \"HTTP/localhost\");\r\n    conf.set(\"hadoop.kms.proxyuser.client.users\", \"foo/localhost\");\r\n    conf.set(\"hadoop.kms.proxyuser.client.hosts\", \"localhost\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"kcc.ALL\", \"foo/localhost\");\r\n    writeConf(testDir, conf);\r\n    runServer(null, null, testDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            UserGroupInformation proxyUgi = UserGroupInformation.loginUserFromKeytabAndReturnUGI(\"client/host\", keytab.getAbsolutePath());\r\n            UserGroupInformation foo = UserGroupInformation.createProxyUser(\"foo/localhost\", proxyUgi);\r\n            final Credentials credentials = new Credentials();\r\n            foo.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    final KeyProvider kp = createProvider(uri, conf);\r\n                    KeyProviderDelegationTokenExtension keyProviderDelegationTokenExtension = KeyProviderDelegationTokenExtension.createKeyProviderDelegationTokenExtension(kp);\r\n                    keyProviderDelegationTokenExtension.addDelegationTokens(\"client\", credentials);\r\n                    Assert.assertNotNull(kp.createKey(\"kcc\", new KeyProvider.Options(conf)));\r\n                    return null;\r\n                }\r\n            });\r\n            UserGroupInformation nonKerberosUgi = UserGroupInformation.getCurrentUser();\r\n            nonKerberosUgi.addCredentials(credentials);\r\n            nonKerberosUgi.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    final KeyProvider kp = createProvider(uri, conf);\r\n                    Assert.assertNotNull(kp.getMetadata(\"kcc\"));\r\n                    return null;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "setupConfForKerberos",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "Configuration setupConfForKerberos(File confDir) throws Exception\n{\r\n    final Configuration conf = createBaseKMSConf(confDir, null);\r\n    conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n    conf.set(\"hadoop.kms.authentication.type\", \"kerberos\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.keytab\", keytab.getAbsolutePath());\r\n    conf.set(\"hadoop.kms.authentication.kerberos.principal\", \"HTTP/localhost\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.name.rules\", \"DEFAULT\");\r\n    return conf;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testDelegationTokensOpsHttpPseudo",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testDelegationTokensOpsHttpPseudo() throws Exception\n{\r\n    testDelegationTokensOps(false, false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testDelegationTokensOpsHttpKerberized",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testDelegationTokensOpsHttpKerberized() throws Exception\n{\r\n    testDelegationTokensOps(false, true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testDelegationTokensOpsHttpsPseudo",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testDelegationTokensOpsHttpsPseudo() throws Exception\n{\r\n    testDelegationTokensOps(true, false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testDelegationTokensOpsHttpsKerberized",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testDelegationTokensOpsHttpsKerberized() throws Exception\n{\r\n    testDelegationTokensOps(true, true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "getTokenService",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "Text getTokenService(KeyProvider provider)\n{\r\n    assertTrue(\"KeyProvider should be an instance of \" + \"LoadBalancingKMSClientProvider\", (provider instanceof LoadBalancingKMSClientProvider));\r\n    assertEquals(\"Num client providers should be 1\", 1, ((LoadBalancingKMSClientProvider) provider).getProviders().length);\r\n    final Text tokenService = new Text((((LoadBalancingKMSClientProvider) provider).getProviders()[0]).getCanonicalServiceName());\r\n    return tokenService;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testDelegationTokensOps",
  "errType" : [ "Exception", "Exception" ],
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void testDelegationTokensOps(final boolean ssl, final boolean kerb) throws Exception\n{\r\n    final File confDir = getTestDir();\r\n    final Configuration conf;\r\n    if (kerb) {\r\n        conf = setupConfForKerberos(confDir);\r\n    } else {\r\n        conf = createBaseKMSConf(confDir, null);\r\n    }\r\n    final String keystore;\r\n    final String password;\r\n    if (ssl) {\r\n        final String sslConfDir = KeyStoreTestUtil.getClasspathDir(TestKMS.class);\r\n        KeyStoreTestUtil.setupSSLConfig(confDir.getAbsolutePath(), sslConfDir, conf, false);\r\n        keystore = confDir.getAbsolutePath() + \"/serverKS.jks\";\r\n        password = \"serverP\";\r\n    } else {\r\n        keystore = null;\r\n        password = null;\r\n    }\r\n    writeConf(confDir, conf);\r\n    runServer(keystore, password, confDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration clientConf = new Configuration();\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            clientConf.set(KeyProviderFactory.KEY_PROVIDER_PATH, createKMSUri(getKMSUrl()).toString());\r\n            doAs(\"client\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, clientConf);\r\n                    clientConf.unset(HADOOP_SECURITY_KEY_PROVIDER_PATH);\r\n                    KeyProviderDelegationTokenExtension kpdte = KeyProviderDelegationTokenExtension.createKeyProviderDelegationTokenExtension(kp);\r\n                    final Credentials credentials = new Credentials();\r\n                    final Token<?>[] tokens = kpdte.addDelegationTokens(\"client1\", credentials);\r\n                    Text tokenService = getTokenService(kp);\r\n                    Assert.assertEquals(1, credentials.getAllTokens().size());\r\n                    Assert.assertEquals(KMSDelegationToken.TOKEN_KIND, credentials.getToken(tokenService).getKind());\r\n                    for (Token<?> token : tokens) {\r\n                        if (!(token.getKind().equals(KMSDelegationToken.TOKEN_KIND))) {\r\n                            LOG.info(\"Skipping token {}\", token);\r\n                            continue;\r\n                        }\r\n                        LOG.info(\"Got dt for \" + uri + \"; \" + token);\r\n                        try {\r\n                            token.renew(clientConf);\r\n                            Assert.fail(\"client should not be allowed to renew token with\" + \"renewer=client1\");\r\n                        } catch (Exception e) {\r\n                            final DelegationTokenIdentifier identifier = (DelegationTokenIdentifier) token.decodeIdentifier();\r\n                            GenericTestUtils.assertExceptionContains(\"tries to renew a token (\" + identifier + \") with non-matching renewer\", e);\r\n                        }\r\n                    }\r\n                    final UserGroupInformation otherUgi;\r\n                    if (kerb) {\r\n                        UserGroupInformation.loginUserFromKeytab(\"client1\", keytab.getAbsolutePath());\r\n                        otherUgi = UserGroupInformation.getLoginUser();\r\n                    } else {\r\n                        otherUgi = UserGroupInformation.createUserForTesting(\"client1\", new String[] { \"other group\" });\r\n                        UserGroupInformation.setLoginUser(otherUgi);\r\n                    }\r\n                    try {\r\n                        otherUgi.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n                            @Override\r\n                            public Void run() throws Exception {\r\n                                boolean renewed = false;\r\n                                for (Token<?> token : tokens) {\r\n                                    if (!(token.getKind().equals(KMSDelegationToken.TOKEN_KIND))) {\r\n                                        LOG.info(\"Skipping token {}\", token);\r\n                                        continue;\r\n                                    }\r\n                                    LOG.info(\"Got dt for \" + uri + \"; \" + token);\r\n                                    long tokenLife = token.renew(clientConf);\r\n                                    LOG.info(\"Renewed token of kind {}, new lifetime:{}\", token.getKind(), tokenLife);\r\n                                    Thread.sleep(100);\r\n                                    long newTokenLife = token.renew(clientConf);\r\n                                    LOG.info(\"Renewed token of kind {}, new lifetime:{}\", token.getKind(), newTokenLife);\r\n                                    Assert.assertTrue(newTokenLife > tokenLife);\r\n                                    renewed = true;\r\n                                }\r\n                                Assert.assertTrue(renewed);\r\n                                for (Token<?> token : tokens) {\r\n                                    if (!(token.getKind().equals(KMSDelegationToken.TOKEN_KIND))) {\r\n                                        LOG.info(\"Skipping token {}\", token);\r\n                                        continue;\r\n                                    }\r\n                                    LOG.info(\"Got dt for \" + uri + \"; \" + token);\r\n                                    token.cancel(clientConf);\r\n                                    LOG.info(\"Cancelled token of kind {}\", token.getKind());\r\n                                    try {\r\n                                        token.renew(clientConf);\r\n                                        Assert.fail(\"should not be able to renew a canceled token\");\r\n                                    } catch (Exception e) {\r\n                                        LOG.info(\"Expected exception when renewing token\", e);\r\n                                    }\r\n                                }\r\n                                return null;\r\n                            }\r\n                        });\r\n                        kp.close();\r\n                        return null;\r\n                    } finally {\r\n                        otherUgi.logoutUserFromKeytab();\r\n                    }\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 3,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testDelegationTokensUpdatedInUGI",
  "errType" : [ "Exception", "Exception" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void testDelegationTokensUpdatedInUGI() throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    File confDir = getTestDir();\r\n    conf = createBaseKMSConf(confDir, conf);\r\n    conf.set(\"hadoop.kms.authentication.delegation-token.max-lifetime.sec\", \"5\");\r\n    conf.set(\"hadoop.kms.authentication.delegation-token.renew-interval.sec\", \"5\");\r\n    writeConf(confDir, conf);\r\n    runServer(null, null, confDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration clientConf = new Configuration();\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            clientConf.set(KeyProviderFactory.KEY_PROVIDER_PATH, createKMSUri(getKMSUrl()).toString());\r\n            final KeyProvider kp = createProvider(uri, clientConf);\r\n            final KeyProviderDelegationTokenExtension kpdte = KeyProviderDelegationTokenExtension.createKeyProviderDelegationTokenExtension(kp);\r\n            final InetSocketAddress kmsAddr = new InetSocketAddress(getKMSUrl().getHost(), getKMSUrl().getPort());\r\n            final Collection<Token<?>> job1Token = new HashSet<>();\r\n            doAs(\"client\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    final Credentials credentials = new Credentials();\r\n                    kpdte.addDelegationTokens(\"client\", credentials);\r\n                    Text tokenService = getTokenService(kp);\r\n                    Assert.assertEquals(1, credentials.getAllTokens().size());\r\n                    Assert.assertEquals(KMSDelegationToken.TOKEN_KIND, credentials.getToken(tokenService).getKind());\r\n                    UserGroupInformation.getCurrentUser().addCredentials(credentials);\r\n                    LOG.info(\"Added kms dt to credentials: {}\", UserGroupInformation.getCurrentUser().getCredentials().getAllTokens());\r\n                    Token<?> token = UserGroupInformation.getCurrentUser().getCredentials().getToken(tokenService);\r\n                    Assert.assertNotNull(token);\r\n                    job1Token.add(token);\r\n                    ByteArrayInputStream buf = new ByteArrayInputStream(token.getIdentifier());\r\n                    DataInputStream dis = new DataInputStream(buf);\r\n                    DelegationTokenIdentifier id = new DelegationTokenIdentifier(token.getKind());\r\n                    id.readFields(dis);\r\n                    dis.close();\r\n                    final long maxTime = id.getMaxDate();\r\n                    Thread.sleep(5100);\r\n                    Assert.assertTrue(\"maxTime \" + maxTime + \" is not less than now.\", maxTime > 0 && maxTime < Time.now());\r\n                    try {\r\n                        kp.getKeys();\r\n                        Assert.fail(\"Operation should fail since dt is expired.\");\r\n                    } catch (Exception e) {\r\n                        LOG.info(\"Expected error.\", e);\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            Assert.assertFalse(job1Token.isEmpty());\r\n            doAs(\"client\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    final Credentials newCreds = new Credentials();\r\n                    kpdte.addDelegationTokens(\"client\", newCreds);\r\n                    Text tokenService = getTokenService(kp);\r\n                    Assert.assertEquals(1, newCreds.getAllTokens().size());\r\n                    Assert.assertEquals(KMSDelegationToken.TOKEN_KIND, newCreds.getToken(tokenService).getKind());\r\n                    final Credentials oldCreds = new Credentials();\r\n                    for (Token<?> token : job1Token) {\r\n                        if (token.getKind().equals(KMSDelegationToken.TOKEN_KIND)) {\r\n                            oldCreds.addToken(tokenService, token);\r\n                        }\r\n                    }\r\n                    UserGroupInformation.getCurrentUser().addCredentials(oldCreds);\r\n                    LOG.info(\"Added old kms dt to credentials: {}\", UserGroupInformation.getCurrentUser().getCredentials().getAllTokens());\r\n                    try {\r\n                        kp.getKeys();\r\n                        Assert.fail(\"Operation should fail since dt is expired.\");\r\n                    } catch (Exception e) {\r\n                        LOG.info(\"Expected error.\", e);\r\n                    }\r\n                    Assert.assertEquals(1, newCreds.getAllTokens().size());\r\n                    Assert.assertEquals(KMSDelegationToken.TOKEN_KIND, newCreds.getToken(tokenService).getKind());\r\n                    UserGroupInformation.getCurrentUser().addCredentials(newCreds);\r\n                    LOG.info(\"Credetials now are: {}\", UserGroupInformation.getCurrentUser().getCredentials().getAllTokens());\r\n                    kp.getKeys();\r\n                    return null;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testKMSWithZKSigner",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testKMSWithZKSigner() throws Exception\n{\r\n    doKMSWithZK(true, false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testKMSWithZKDTSM",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testKMSWithZKDTSM() throws Exception\n{\r\n    doKMSWithZK(false, true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testKMSWithZKSignerAndDTSM",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testKMSWithZKSignerAndDTSM() throws Exception\n{\r\n    doKMSWithZK(true, true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "runServerWithZooKeeper",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "T runServerWithZooKeeper(boolean zkDTSM, boolean zkSigner, KMSCallable<T> callable) throws Exception\n{\r\n    return runServerWithZooKeeper(zkDTSM, zkSigner, callable, 1);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "runServerWithZooKeeper",
  "errType" : null,
  "containingMethodsNum" : 27,
  "sourceCodeText" : "T runServerWithZooKeeper(boolean zkDTSM, boolean zkSigner, KMSCallable<T> callable, int kmsSize) throws Exception\n{\r\n    TestingServer zkServer = null;\r\n    try {\r\n        zkServer = new TestingServer();\r\n        zkServer.start();\r\n        Configuration conf = new Configuration();\r\n        conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n        final File testDir = getTestDir();\r\n        conf = createBaseKMSConf(testDir, conf);\r\n        conf.set(\"hadoop.kms.authentication.type\", \"kerberos\");\r\n        conf.set(\"hadoop.kms.authentication.kerberos.keytab\", keytab.getAbsolutePath());\r\n        conf.set(\"hadoop.kms.authentication.kerberos.principal\", \"HTTP/localhost\");\r\n        conf.set(\"hadoop.kms.authentication.kerberos.name.rules\", \"DEFAULT\");\r\n        if (zkSigner) {\r\n            conf.set(\"hadoop.kms.authentication.signer.secret.provider\", \"zookeeper\");\r\n            conf.set(\"hadoop.kms.authentication.signer.secret.provider.zookeeper.path\", \"/testKMSWithZKDTSM\");\r\n            conf.set(\"hadoop.kms.authentication.signer.secret.provider.zookeeper.connection.string\", zkServer.getConnectString());\r\n        }\r\n        if (zkDTSM) {\r\n            conf.set(\"hadoop.kms.authentication.zk-dt-secret-manager.enable\", \"true\");\r\n        }\r\n        if (zkDTSM && !zkSigner) {\r\n            conf.set(\"hadoop.kms.authentication.zk-dt-secret-manager.zkConnectionString\", zkServer.getConnectString());\r\n            conf.set(\"hadoop.kms.authentication.zk-dt-secret-manager.znodeWorkingPath\", \"testZKPath\");\r\n            conf.set(\"hadoop.kms.authentication.zk-dt-secret-manager.zkAuthType\", \"none\");\r\n        }\r\n        for (KMSACLs.Type type : KMSACLs.Type.values()) {\r\n            conf.set(type.getAclConfigKey(), type.toString());\r\n        }\r\n        conf.set(KMSACLs.Type.CREATE.getAclConfigKey(), KMSACLs.Type.CREATE.toString() + \",SET_KEY_MATERIAL\");\r\n        conf.set(KMSACLs.Type.ROLLOVER.getAclConfigKey(), KMSACLs.Type.ROLLOVER.toString() + \",SET_KEY_MATERIAL\");\r\n        conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k0.ALL\", \"*\");\r\n        conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k1.ALL\", \"*\");\r\n        conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k2.ALL\", \"*\");\r\n        conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"k3.ALL\", \"*\");\r\n        writeConf(testDir, conf);\r\n        int[] ports = new int[kmsSize];\r\n        for (int i = 0; i < ports.length; i++) {\r\n            ports[i] = -1;\r\n        }\r\n        return runServer(ports, null, null, testDir, callable);\r\n    } finally {\r\n        if (zkServer != null) {\r\n            zkServer.stop();\r\n            zkServer.close();\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "doKMSWithZK",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void doKMSWithZK(boolean zkDTSM, boolean zkSigner) throws Exception\n{\r\n    KMSCallable<KeyProvider> c = new KMSCallable<KeyProvider>() {\r\n\r\n        @Override\r\n        public KeyProvider call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME, 128);\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            final KeyProvider kp = doAs(\"SET_KEY_MATERIAL\", new PrivilegedExceptionAction<KeyProvider>() {\r\n\r\n                @Override\r\n                public KeyProvider run() throws Exception {\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    kp.createKey(\"k1\", new byte[16], new KeyProvider.Options(conf));\r\n                    kp.createKey(\"k2\", new byte[16], new KeyProvider.Options(conf));\r\n                    kp.createKey(\"k3\", new byte[16], new KeyProvider.Options(conf));\r\n                    return kp;\r\n                }\r\n            });\r\n            return kp;\r\n        }\r\n    };\r\n    runServerWithZooKeeper(zkDTSM, zkSigner, c);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testKMSHAZooKeeperDelegationToken",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testKMSHAZooKeeperDelegationToken() throws Exception\n{\r\n    final int kmsSize = 2;\r\n    doKMSWithZKWithDelegationToken(true, true, kmsSize);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "doKMSWithZKWithDelegationToken",
  "errType" : [ "Exception", "IOException" ],
  "containingMethodsNum" : 14,
  "sourceCodeText" : "void doKMSWithZKWithDelegationToken(boolean zkDTSM, boolean zkSigner, int kmsSize) throws Exception\n{\r\n    KMSCallable<Void> c = new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME, 128);\r\n            final URI[] uris = createKMSHAUri(getKMSHAUrl());\r\n            final Credentials credentials = new Credentials();\r\n            final UserGroupInformation nonKerberosUgi = UserGroupInformation.getCurrentUser();\r\n            final String lbUri = generateLoadBalancingKeyProviderUriString();\r\n            final LoadBalancingKMSClientProvider lbkp = createHAProvider(URI.create(lbUri), uris, conf);\r\n            conf.unset(HADOOP_SECURITY_KEY_PROVIDER_PATH);\r\n            doAs(\"SET_KEY_MATERIAL\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProviderDelegationTokenExtension kpdte = KeyProviderDelegationTokenExtension.createKeyProviderDelegationTokenExtension(lbkp);\r\n                    kpdte.addDelegationTokens(\"foo\", credentials);\r\n                    return null;\r\n                }\r\n            });\r\n            nonKerberosUgi.addCredentials(credentials);\r\n            nonKerberosUgi.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    int i = 0;\r\n                    for (KMSClientProvider provider : lbkp.getProviders()) {\r\n                        final String key = \"k\" + i++;\r\n                        LOG.info(\"Connect to {} to create key {}.\", provider, key);\r\n                        provider.createKey(key, new KeyProvider.Options(conf));\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            final Collection<Token<? extends TokenIdentifier>> tokens = credentials.getAllTokens();\r\n            doAs(\"foo\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    assertEquals(1, tokens.size());\r\n                    Token token = tokens.iterator().next();\r\n                    assertEquals(KMSDelegationToken.TOKEN_KIND, token.getKind());\r\n                    LOG.info(\"Got dt for token: {}\", token);\r\n                    final long tokenLife = token.renew(conf);\r\n                    LOG.info(\"Renewed token {}, new lifetime:{}\", token, tokenLife);\r\n                    Thread.sleep(10);\r\n                    final long newTokenLife = token.renew(conf);\r\n                    LOG.info(\"Renewed token {}, new lifetime:{}\", token, newTokenLife);\r\n                    assertTrue(newTokenLife > tokenLife);\r\n                    LOG.info(\"Got dt for token: {}\", token);\r\n                    token.cancel(conf);\r\n                    LOG.info(\"Cancelled token {}\", token);\r\n                    try {\r\n                        token.renew(conf);\r\n                        fail(\"should not be able to renew a canceled token\");\r\n                    } catch (Exception e) {\r\n                        LOG.info(\"Expected exception when renewing token\", e);\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            final Credentials newCredentials = new Credentials();\r\n            doAs(\"SET_KEY_MATERIAL\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KeyProviderDelegationTokenExtension kpdte = KeyProviderDelegationTokenExtension.createKeyProviderDelegationTokenExtension(lbkp);\r\n                    kpdte.addDelegationTokens(\"foo\", newCredentials);\r\n                    return null;\r\n                }\r\n            });\r\n            doAs(\"foo\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    KMSClientProvider kp1 = lbkp.getProviders()[0];\r\n                    URL[] urls = getKMSHAUrl();\r\n                    final Collection<Token<? extends TokenIdentifier>> tokens = newCredentials.getAllTokens();\r\n                    assertEquals(1, tokens.size());\r\n                    Token token = tokens.iterator().next();\r\n                    assertEquals(KMSDelegationToken.TOKEN_KIND, token.getKind());\r\n                    Text text = SecurityUtil.buildTokenService(new InetSocketAddress(urls[0].getHost(), urls[0].getPort()));\r\n                    token.setService(text);\r\n                    conf.set(HADOOP_SECURITY_KEY_PROVIDER_PATH, lbUri);\r\n                    long tokenLife = 0L;\r\n                    for (KMSClientProvider kp : lbkp.getProviders()) {\r\n                        long renewedTokenLife = token.renew(conf);\r\n                        LOG.info(\"Renewed token of kind {}, new lifetime:{}\", token.getKind(), renewedTokenLife);\r\n                        assertTrue(renewedTokenLife > tokenLife);\r\n                        tokenLife = renewedTokenLife;\r\n                        Thread.sleep(10);\r\n                    }\r\n                    token.cancel(conf);\r\n                    try {\r\n                        token.renew(conf);\r\n                        fail(\"should not be able to renew a canceled token\");\r\n                    } catch (IOException e) {\r\n                        LOG.info(\"Expected exception when renewing token\", e);\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    };\r\n    runServerWithZooKeeper(zkDTSM, zkSigner, c, kmsSize);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testProxyUserKerb",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testProxyUserKerb() throws Exception\n{\r\n    doProxyUserTest(true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testProxyUserSimple",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testProxyUserSimple() throws Exception\n{\r\n    doProxyUserTest(false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "doProxyUserTest",
  "errType" : [ "AuthorizationException", "Exception" ],
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void doProxyUserTest(final boolean kerberos) throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n    final File testDir = getTestDir();\r\n    conf = createBaseKMSConf(testDir, conf);\r\n    if (kerberos) {\r\n        conf.set(\"hadoop.kms.authentication.type\", \"kerberos\");\r\n    }\r\n    conf.set(\"hadoop.kms.authentication.kerberos.keytab\", keytab.getAbsolutePath());\r\n    conf.set(\"hadoop.kms.authentication.kerberos.principal\", \"HTTP/localhost\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.name.rules\", \"DEFAULT\");\r\n    conf.set(\"hadoop.kms.proxyuser.client.users\", \"foo,bar\");\r\n    conf.set(\"hadoop.kms.proxyuser.client.hosts\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"kaa.ALL\", \"client\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"kbb.ALL\", \"foo\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"kcc.ALL\", \"foo1\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"kdd.ALL\", \"bar\");\r\n    writeConf(testDir, conf);\r\n    runServer(null, null, testDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME, 128);\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            UserGroupInformation proxyUgi = null;\r\n            if (kerberos) {\r\n                proxyUgi = UserGroupInformation.loginUserFromKeytabAndReturnUGI(\"client\", keytab.getAbsolutePath());\r\n            } else {\r\n                proxyUgi = UserGroupInformation.createRemoteUser(\"client\");\r\n                UserGroupInformation.setLoginUser(proxyUgi);\r\n            }\r\n            final UserGroupInformation clientUgi = proxyUgi;\r\n            clientUgi.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    final KeyProvider kp = createProvider(uri, conf);\r\n                    kp.createKey(\"kaa\", new KeyProvider.Options(conf));\r\n                    UserGroupInformation fooUgi = UserGroupInformation.createProxyUser(\"foo\", clientUgi);\r\n                    fooUgi.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n                        @Override\r\n                        public Void run() throws Exception {\r\n                            Assert.assertNotNull(kp.createKey(\"kbb\", new KeyProvider.Options(conf)));\r\n                            return null;\r\n                        }\r\n                    });\r\n                    UserGroupInformation foo1Ugi = UserGroupInformation.createProxyUser(\"foo1\", clientUgi);\r\n                    foo1Ugi.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n                        @Override\r\n                        public Void run() throws Exception {\r\n                            try {\r\n                                kp.createKey(\"kcc\", new KeyProvider.Options(conf));\r\n                                Assert.fail();\r\n                            } catch (AuthorizationException ex) {\r\n                            } catch (Exception ex) {\r\n                                Assert.fail(ex.getMessage());\r\n                            }\r\n                            return null;\r\n                        }\r\n                    });\r\n                    UserGroupInformation barUgi = UserGroupInformation.createProxyUser(\"bar\", clientUgi);\r\n                    barUgi.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n                        @Override\r\n                        public Void run() throws Exception {\r\n                            Assert.assertNotNull(kp.createKey(\"kdd\", new KeyProvider.Options(conf)));\r\n                            return null;\r\n                        }\r\n                    });\r\n                    return null;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testWebHDFSProxyUserKerb",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testWebHDFSProxyUserKerb() throws Exception\n{\r\n    doWebHDFSProxyUserTest(true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testWebHDFSProxyUserSimple",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void testWebHDFSProxyUserSimple() throws Exception\n{\r\n    doWebHDFSProxyUserTest(false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testTGTRenewal",
  "errType" : null,
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void testTGTRenewal() throws Exception\n{\r\n    Properties kdcConf = MiniKdc.createConf();\r\n    kdcConf.setProperty(MiniKdc.MAX_TICKET_LIFETIME, \"3\");\r\n    kdcConf.setProperty(MiniKdc.MIN_TICKET_LIFETIME, \"3\");\r\n    setUpMiniKdc(kdcConf);\r\n    Configuration conf = new Configuration();\r\n    conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n    final File testDir = getTestDir();\r\n    conf = createBaseKMSConf(testDir, conf);\r\n    conf.set(\"hadoop.kms.authentication.type\", \"kerberos\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.keytab\", keytab.getAbsolutePath());\r\n    conf.set(\"hadoop.kms.authentication.kerberos.principal\", \"HTTP/localhost\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.name.rules\", \"DEFAULT\");\r\n    conf.set(\"hadoop.kms.proxyuser.client.users\", \"*\");\r\n    conf.set(\"hadoop.kms.proxyuser.client.hosts\", \"*\");\r\n    writeConf(testDir, conf);\r\n    runServer(null, null, testDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            UserGroupInformation.setShouldRenewImmediatelyForTests(true);\r\n            UserGroupInformation.loginUserFromKeytab(\"client\", keytab.getAbsolutePath());\r\n            final UserGroupInformation clientUgi = UserGroupInformation.getCurrentUser();\r\n            clientUgi.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    Thread.sleep(3100);\r\n                    KeyProvider kp = createProvider(uri, conf);\r\n                    kp.getKeys();\r\n                    Thread.sleep(3100);\r\n                    kp = createProvider(uri, conf);\r\n                    ((KeyProviderDelegationTokenExtension.DelegationTokenExtension) kp).addDelegationTokens(\"myuser\", new Credentials());\r\n                    UserGroupInformation anotherUgi = UserGroupInformation.createProxyUser(\"client1\", clientUgi);\r\n                    anotherUgi.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n                        @Override\r\n                        public Void run() throws Exception {\r\n                            Thread.sleep(3100);\r\n                            KeyProvider kp = createProvider(uri, conf);\r\n                            kp.getKeys();\r\n                            return null;\r\n                        }\r\n                    });\r\n                    return null;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "doWebHDFSProxyUserTest",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 16,
  "sourceCodeText" : "void doWebHDFSProxyUserTest(final boolean kerberos) throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    if (kerberos) {\r\n        conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n    }\r\n    UserGroupInformation.setConfiguration(conf);\r\n    final File testDir = getTestDir();\r\n    conf = createBaseKMSConf(testDir, conf);\r\n    if (kerberos) {\r\n        conf.set(\"hadoop.kms.authentication.type\", \"kerberos\");\r\n    }\r\n    conf.set(\"hadoop.kms.authentication.kerberos.keytab\", keytab.getAbsolutePath());\r\n    conf.set(\"hadoop.kms.authentication.kerberos.principal\", \"HTTP/localhost\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.name.rules\", \"DEFAULT\");\r\n    conf.set(\"hadoop.security.kms.client.timeout\", \"300\");\r\n    conf.set(\"hadoop.kms.proxyuser.client.users\", \"foo,bar\");\r\n    conf.set(\"hadoop.kms.proxyuser.client.hosts\", \"*\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"kaa.ALL\", \"foo\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"kbb.ALL\", \"foo1\");\r\n    conf.set(KeyAuthorizationKeyProvider.KEY_ACL + \"kcc.ALL\", \"bar\");\r\n    writeConf(testDir, conf);\r\n    runServer(null, null, testDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME, 128);\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            UserGroupInformation proxyUgi = null;\r\n            if (kerberos) {\r\n                proxyUgi = UserGroupInformation.loginUserFromKeytabAndReturnUGI(\"client\", keytab.getAbsolutePath());\r\n            } else {\r\n                proxyUgi = UserGroupInformation.createRemoteUser(\"client\");\r\n            }\r\n            final UserGroupInformation clientUgi = proxyUgi;\r\n            clientUgi.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    UserGroupInformation fooUgi = UserGroupInformation.createProxyUser(\"foo\", clientUgi);\r\n                    fooUgi.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n                        @Override\r\n                        public Void run() throws Exception {\r\n                            KeyProvider kp = createProvider(uri, conf);\r\n                            Assert.assertNotNull(kp.createKey(\"kaa\", new KeyProvider.Options(conf)));\r\n                            return null;\r\n                        }\r\n                    });\r\n                    UserGroupInformation foo1Ugi = UserGroupInformation.createProxyUser(\"foo1\", clientUgi);\r\n                    foo1Ugi.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n                        @Override\r\n                        public Void run() throws Exception {\r\n                            try {\r\n                                KeyProvider kp = createProvider(uri, conf);\r\n                                kp.createKey(\"kbb\", new KeyProvider.Options(conf));\r\n                                Assert.fail();\r\n                            } catch (Exception ex) {\r\n                                GenericTestUtils.assertExceptionContains(\"Error while \" + \"authenticating with endpoint\", ex);\r\n                                GenericTestUtils.assertExceptionContains(\"Forbidden\", ex.getCause().getCause());\r\n                            }\r\n                            return null;\r\n                        }\r\n                    });\r\n                    UserGroupInformation barUgi = UserGroupInformation.createProxyUser(\"bar\", clientUgi);\r\n                    barUgi.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n                        @Override\r\n                        public Void run() throws Exception {\r\n                            KeyProvider kp = createProvider(uri, conf);\r\n                            Assert.assertNotNull(kp.createKey(\"kcc\", new KeyProvider.Options(conf)));\r\n                            return null;\r\n                        }\r\n                    });\r\n                    return null;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testKMSJMX",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void testKMSJMX() throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    final File confDir = getTestDir();\r\n    conf = createBaseKMSConf(confDir, conf);\r\n    final String processName = \"testkmsjmx\";\r\n    conf.set(KMSConfiguration.METRICS_PROCESS_NAME_KEY, processName);\r\n    writeConf(confDir, conf);\r\n    runServer(null, null, confDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final URL jmxUrl = new URL(getKMSUrl() + \"/jmx?user.name=whatever&qry=Hadoop:service=\" + processName + \",name=JvmMetrics\");\r\n            LOG.info(\"Requesting jmx from \" + jmxUrl);\r\n            final StringBuilder sb = new StringBuilder();\r\n            final InputStream in = jmxUrl.openConnection().getInputStream();\r\n            final byte[] buffer = new byte[64 * 1024];\r\n            int len;\r\n            while ((len = in.read(buffer)) > 0) {\r\n                sb.append(new String(buffer, 0, len));\r\n            }\r\n            LOG.info(\"jmx returned: \" + sb.toString());\r\n            assertTrue(sb.toString().contains(\"JvmMetrics\"));\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testFilterInitializer",
  "errType" : null,
  "containingMethodsNum" : 14,
  "sourceCodeText" : "void testFilterInitializer() throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    File testDir = getTestDir();\r\n    conf = createBaseKMSConf(testDir, conf);\r\n    conf.set(\"hadoop.security.authentication\", \"kerberos\");\r\n    conf.set(\"hadoop.kms.authentication.token.validity\", \"1\");\r\n    conf.set(\"hadoop.kms.authentication.type\", \"kerberos\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.keytab\", keytab.getAbsolutePath());\r\n    conf.set(\"hadoop.kms.authentication.kerberos.principal\", \"HTTP/localhost\");\r\n    conf.set(\"hadoop.kms.authentication.kerberos.name.rules\", \"DEFAULT\");\r\n    conf.set(\"hadoop.http.filter.initializers\", AuthenticationFilterInitializer.class.getName());\r\n    conf.set(\"hadoop.http.authentication.type\", \"kerberos\");\r\n    conf.set(\"hadoop.http.authentication.kerberos.principal\", \"HTTP/localhost\");\r\n    conf.set(\"hadoop.http.authentication.kerberos.keytab\", keytab.getAbsolutePath());\r\n    writeConf(testDir, conf);\r\n    runServer(null, null, testDir, new KMSCallable<Void>() {\r\n\r\n        @Override\r\n        public Void call() throws Exception {\r\n            final Configuration conf = new Configuration();\r\n            URL url = getKMSUrl();\r\n            final URI uri = createKMSUri(getKMSUrl());\r\n            doAs(\"client\", new PrivilegedExceptionAction<Void>() {\r\n\r\n                @Override\r\n                public Void run() throws Exception {\r\n                    final KeyProvider kp = createProvider(uri, conf);\r\n                    Assert.assertTrue(kp.getKeys().isEmpty());\r\n                    return null;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testConfiguration",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void testConfiguration() throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    conf.set(\"hadoop.kms.authentication.type\", \"simple\");\r\n    Properties prop = new KMSAuthenticationFilter().getKMSConfiguration(conf);\r\n    assertEquals(prop.getProperty(KMSAuthenticationFilter.AUTH_TYPE), PseudoDelegationTokenAuthenticationHandler.class.getName());\r\n    assertEquals(prop.getProperty(DelegationTokenAuthenticationHandler.TOKEN_KIND), KMSDelegationToken.TOKEN_KIND_STR);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "setUp",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void setUp() throws IOException\n{\r\n    filter = new KMSMDCFilter();\r\n    httpRequest = Mockito.mock(HttpServletRequest.class);\r\n    httpResponse = Mockito.mock(HttpServletResponse.class);\r\n    KMSMDCFilter.setContext(null, null, null, null);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testFilter",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void testFilter() throws IOException, ServletException\n{\r\n    when(httpRequest.getMethod()).thenReturn(METHOD);\r\n    when(httpRequest.getRequestURL()).thenReturn(new StringBuffer(URL));\r\n    when(httpRequest.getRemoteAddr()).thenReturn(REMOTE_ADDRESS);\r\n    FilterChain filterChain = new FilterChain() {\r\n\r\n        @Override\r\n        public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException {\r\n            assertEquals(\"filter.remoteClientAddress\", REMOTE_ADDRESS, KMSMDCFilter.getRemoteClientAddress());\r\n            assertEquals(\"filter.method\", METHOD, KMSMDCFilter.getMethod());\r\n            assertEquals(\"filter.url\", URL, KMSMDCFilter.getURL());\r\n        }\r\n    };\r\n    checkMDCValuesAreEmpty();\r\n    filter.doFilter(httpRequest, httpResponse, filterChain);\r\n    checkMDCValuesAreEmpty();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "checkMDCValuesAreEmpty",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void checkMDCValuesAreEmpty()\n{\r\n    assertNull(\"getRemoteClientAddress\", KMSMDCFilter.getRemoteClientAddress());\r\n    assertNull(\"getMethod\", KMSMDCFilter.getMethod());\r\n    assertNull(\"getURL\", KMSMDCFilter.getURL());\r\n    assertNull(\"getUgi\", KMSMDCFilter.getUgi());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "copyResource",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void copyResource(String inputResourceName, File outputFile) throws IOException\n{\r\n    try (InputStream is = ThreadUtil.getResourceAsStream(inputResourceName);\r\n        OutputStream os = new FileOutputStream(outputFile)) {\r\n        IOUtils.copy(is, os);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "start",
  "errType" : null,
  "containingMethodsNum" : 22,
  "sourceCodeText" : "void start() throws Exception\n{\r\n    System.setProperty(KMSConfiguration.KMS_CONFIG_DIR, kmsConfDir);\r\n    File aclsFile = new File(kmsConfDir, \"kms-acls.xml\");\r\n    if (!aclsFile.exists()) {\r\n        copyResource(\"mini-kms-acls-default.xml\", aclsFile);\r\n    }\r\n    File coreFile = new File(kmsConfDir, \"core-site.xml\");\r\n    if (!coreFile.exists()) {\r\n        Configuration core = new Configuration();\r\n        Writer writer = new FileWriter(coreFile);\r\n        core.writeXml(writer);\r\n        writer.close();\r\n    }\r\n    File kmsFile = new File(kmsConfDir, \"kms-site.xml\");\r\n    if (!kmsFile.exists()) {\r\n        Configuration kms = new Configuration(false);\r\n        kms.set(KMSConfiguration.KEY_PROVIDER_URI, \"jceks://file@\" + new Path(kmsConfDir, \"kms.keystore\").toUri());\r\n        kms.set(\"hadoop.kms.authentication.type\", \"simple\");\r\n        Writer writer = new FileWriter(kmsFile);\r\n        kms.writeXml(writer);\r\n        writer.close();\r\n    }\r\n    System.setProperty(\"log4j.configuration\", log4jConfFile);\r\n    final Configuration conf = KMSConfiguration.getKMSConf();\r\n    conf.set(KMSConfiguration.HTTP_HOST_KEY, \"localhost\");\r\n    conf.setInt(KMSConfiguration.HTTP_PORT_KEY, inPort);\r\n    Configuration sslConf = null;\r\n    if (keyStore != null) {\r\n        conf.setBoolean(KMSConfiguration.SSL_ENABLED_KEY, true);\r\n        sslConf = SSLFactory.readSSLConfiguration(conf, SSLFactory.Mode.SERVER);\r\n        sslConf.set(SSLFactory.SSL_SERVER_KEYSTORE_LOCATION, keyStore);\r\n        sslConf.set(SSLFactory.SSL_SERVER_KEYSTORE_PASSWORD, keyStorePassword);\r\n        sslConf.set(SSLFactory.SSL_SERVER_KEYSTORE_TYPE, \"jks\");\r\n    }\r\n    jetty = new KMSWebServer(conf, sslConf);\r\n    jetty.start();\r\n    kmsURL = jetty.getKMSUrl();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "getKMSUrl",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "URL getKMSUrl()\n{\r\n    return kmsURL;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "stop",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void stop()\n{\r\n    if (jetty != null && jetty.isRunning()) {\r\n        try {\r\n            jetty.stop();\r\n            jetty = null;\r\n        } catch (Exception ex) {\r\n            throw new RuntimeException(\"Could not stop MiniKMS embedded Jetty, \" + ex.getMessage(), ex);\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "printUsage",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void printUsage()\n{\r\n    System.err.println(\"Usage: KMSBenchmark\" + \"\\n\\t\" + OperationStatsBase.OP_ALL_USAGE + \" | \\n\\t\" + EncryptKeyStats.OP_ENCRYPT_USAGE + \" | \\n\\t\" + DecryptKeyStats.OP_DECRYPT_USAGE + \" | \\n\\t\" + GENERAL_OPTIONS_USAGE);\r\n    System.err.println();\r\n    GenericOptionsParser.printGenericCommandUsage(System.err);\r\n    ExitUtil.terminate(-1);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "createKeyProviderCryptoExtension",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "KeyProviderCryptoExtension createKeyProviderCryptoExtension(final Configuration conf) throws IOException\n{\r\n    KeyProvider keyProvider = KMSUtil.createKeyProvider(conf, CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH);\r\n    if (keyProvider == null) {\r\n        throw new IOException(\"Key provider was not configured.\");\r\n    }\r\n    return KeyProviderCryptoExtension.createKeyProviderCryptoExtension(keyProvider);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "runBenchmark",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void runBenchmark(Configuration conf, String[] args) throws Exception\n{\r\n    KMSBenchmark bench = null;\r\n    try {\r\n        bench = new KMSBenchmark(conf, args);\r\n        ToolRunner.run(bench, args);\r\n    } finally {\r\n        LOG.info(\"runBenchmark finished.\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "run",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 18,
  "sourceCodeText" : "int run(String[] aArgs) throws Exception\n{\r\n    List<String> args = new ArrayList<String>(Arrays.asList(aArgs));\r\n    if (args.size() < 2 || !args.get(0).startsWith(\"-op\")) {\r\n        printUsage();\r\n    }\r\n    String type = args.get(1);\r\n    boolean runAll = OperationStatsBase.OP_ALL_NAME.equals(type);\r\n    List<OperationStatsBase> ops = new ArrayList<OperationStatsBase>();\r\n    OperationStatsBase opStat = null;\r\n    try {\r\n        if (runAll || EncryptKeyStats.OP_ENCRYPT_KEY.equals(type)) {\r\n            opStat = new EncryptKeyStats(args);\r\n            ops.add(opStat);\r\n        }\r\n        if (runAll || DecryptKeyStats.OP_DECRYPT_KEY.equals(type)) {\r\n            opStat = new DecryptKeyStats(args);\r\n            ops.add(opStat);\r\n        }\r\n        if (ops.isEmpty()) {\r\n            printUsage();\r\n        }\r\n        for (OperationStatsBase op : ops) {\r\n            LOG.info(\"Starting benchmark: \" + op.getOpName());\r\n            op.benchmark();\r\n            op.cleanUp();\r\n        }\r\n        for (OperationStatsBase op : ops) {\r\n            LOG.info(\"\");\r\n            op.printResults();\r\n        }\r\n    } catch (Exception e) {\r\n        LOG.error(\"failed to run benchmarks\", e);\r\n        throw e;\r\n    }\r\n    return 0;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "main",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void main(String[] args) throws Exception\n{\r\n    runBenchmark(new Configuration(), args);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "setConf",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void setConf(Configuration conf)\n{\r\n    config = conf;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "getConf",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Configuration getConf()\n{\r\n    return config;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "createBaseKMSConf",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "Configuration createBaseKMSConf(File keyStoreDir) throws Exception\n{\r\n    Configuration conf = new Configuration(false);\r\n    conf.set(KMSConfiguration.KEY_PROVIDER_URI, \"jceks://file@\" + new Path(keyStoreDir.getAbsolutePath(), \"kms.keystore\").toUri());\r\n    conf.set(\"hadoop.kms.authentication.type\", \"simple\");\r\n    conf.setBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE, false);\r\n    conf.set(KMSACLs.Type.GET_KEYS.getAclConfigKey(), \"foo\");\r\n    return conf;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testMultipleKMSInstancesWithZKSigner",
  "errType" : null,
  "containingMethodsNum" : 21,
  "sourceCodeText" : "void testMultipleKMSInstancesWithZKSigner() throws Exception\n{\r\n    final File testDir = TestKMS.getTestDir();\r\n    Configuration conf = createBaseKMSConf(testDir);\r\n    TestingServer zkServer = new TestingServer();\r\n    zkServer.start();\r\n    MiniKMS kms1 = null;\r\n    MiniKMS kms2 = null;\r\n    conf.set(KMSAuthenticationFilter.CONFIG_PREFIX + AuthenticationFilter.SIGNER_SECRET_PROVIDER, \"zookeeper\");\r\n    conf.set(KMSAuthenticationFilter.CONFIG_PREFIX + ZKSignerSecretProvider.ZOOKEEPER_CONNECTION_STRING, zkServer.getConnectString());\r\n    conf.set(KMSAuthenticationFilter.CONFIG_PREFIX + ZKSignerSecretProvider.ZOOKEEPER_PATH, \"/secret\");\r\n    TestKMS.writeConf(testDir, conf);\r\n    try {\r\n        kms1 = new MiniKMS.Builder().setKmsConfDir(testDir).setLog4jConfFile(\"log4j.properties\").build();\r\n        kms1.start();\r\n        kms2 = new MiniKMS.Builder().setKmsConfDir(testDir).setLog4jConfFile(\"log4j.properties\").build();\r\n        kms2.start();\r\n        final URL url1 = new URL(kms1.getKMSUrl().toExternalForm() + KMSRESTConstants.SERVICE_VERSION + \"/\" + KMSRESTConstants.KEYS_NAMES_RESOURCE);\r\n        final URL url2 = new URL(kms2.getKMSUrl().toExternalForm() + KMSRESTConstants.SERVICE_VERSION + \"/\" + KMSRESTConstants.KEYS_NAMES_RESOURCE);\r\n        final DelegationTokenAuthenticatedURL.Token token = new DelegationTokenAuthenticatedURL.Token();\r\n        final DelegationTokenAuthenticatedURL aUrl = new DelegationTokenAuthenticatedURL();\r\n        UserGroupInformation ugiFoo = UserGroupInformation.createUserForTesting(\"foo\", new String[] { \"gfoo\" });\r\n        UserGroupInformation ugiBar = UserGroupInformation.createUserForTesting(\"bar\", new String[] { \"gBar\" });\r\n        ugiFoo.doAs(new PrivilegedExceptionAction<Object>() {\r\n\r\n            @Override\r\n            public Object run() throws Exception {\r\n                HttpURLConnection conn = aUrl.openConnection(url1, token);\r\n                Assert.assertEquals(HttpURLConnection.HTTP_OK, conn.getResponseCode());\r\n                return null;\r\n            }\r\n        });\r\n        ugiBar.doAs(new PrivilegedExceptionAction<Object>() {\r\n\r\n            @Override\r\n            public Object run() throws Exception {\r\n                HttpURLConnection conn = aUrl.openConnection(url2, token);\r\n                Assert.assertEquals(HttpURLConnection.HTTP_OK, conn.getResponseCode());\r\n                return null;\r\n            }\r\n        });\r\n        ugiBar.doAs(new PrivilegedExceptionAction<Object>() {\r\n\r\n            @Override\r\n            public Object run() throws Exception {\r\n                final DelegationTokenAuthenticatedURL.Token emptyToken = new DelegationTokenAuthenticatedURL.Token();\r\n                HttpURLConnection conn = aUrl.openConnection(url2, emptyToken);\r\n                Assert.assertEquals(HttpURLConnection.HTTP_FORBIDDEN, conn.getResponseCode());\r\n                return null;\r\n            }\r\n        });\r\n    } finally {\r\n        if (kms2 != null) {\r\n            kms2.stop();\r\n        }\r\n        if (kms1 != null) {\r\n            kms1.stop();\r\n        }\r\n        zkServer.stop();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testCreateKey",
  "errType" : [ "IOException", "IOException", "IOException" ],
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void testCreateKey() throws Exception\n{\r\n    final Configuration conf = new Configuration();\r\n    KeyProvider kp = new UserProvider.Factory().createProvider(new URI(\"user:///\"), conf);\r\n    KeyACLs mock = mock(KeyACLs.class);\r\n    when(mock.isACLPresent(\"foo\", KeyOpType.MANAGEMENT)).thenReturn(true);\r\n    UserGroupInformation u1 = UserGroupInformation.createRemoteUser(\"u1\");\r\n    when(mock.hasAccessToKey(\"foo\", u1, KeyOpType.MANAGEMENT)).thenReturn(true);\r\n    final KeyProviderCryptoExtension kpExt = new KeyAuthorizationKeyProvider(KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp), mock);\r\n    u1.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n        @Override\r\n        public Void run() throws Exception {\r\n            try {\r\n                kpExt.createKey(\"foo\", SecureRandom.getSeed(16), newOptions(conf));\r\n            } catch (IOException ioe) {\r\n                Assert.fail(\"User should be Authorized !!\");\r\n            }\r\n            try {\r\n                kpExt.createKey(\"bar\", SecureRandom.getSeed(16), newOptions(conf));\r\n                Assert.fail(\"User should NOT be Authorized !!\");\r\n            } catch (IOException ioe) {\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n    UserGroupInformation.createRemoteUser(\"badGuy\").doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n        @Override\r\n        public Void run() throws Exception {\r\n            try {\r\n                kpExt.createKey(\"foo\", SecureRandom.getSeed(16), newOptions(conf));\r\n                Assert.fail(\"User should NOT be Authorized !!\");\r\n            } catch (IOException ioe) {\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 3,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testOpsWhenACLAttributeExists",
  "errType" : [ "IOException", "IOException", "IOException", "IOException", "IOException" ],
  "containingMethodsNum" : 19,
  "sourceCodeText" : "void testOpsWhenACLAttributeExists() throws Exception\n{\r\n    final Configuration conf = new Configuration();\r\n    KeyProvider kp = new UserProvider.Factory().createProvider(new URI(\"user:///\"), conf);\r\n    KeyACLs mock = mock(KeyACLs.class);\r\n    when(mock.isACLPresent(\"testKey\", KeyOpType.MANAGEMENT)).thenReturn(true);\r\n    when(mock.isACLPresent(\"testKey\", KeyOpType.GENERATE_EEK)).thenReturn(true);\r\n    when(mock.isACLPresent(\"testKey\", KeyOpType.DECRYPT_EEK)).thenReturn(true);\r\n    when(mock.isACLPresent(\"testKey\", KeyOpType.ALL)).thenReturn(true);\r\n    UserGroupInformation u1 = UserGroupInformation.createRemoteUser(\"u1\");\r\n    UserGroupInformation u2 = UserGroupInformation.createRemoteUser(\"u2\");\r\n    UserGroupInformation u3 = UserGroupInformation.createRemoteUser(\"u3\");\r\n    UserGroupInformation sudo = UserGroupInformation.createRemoteUser(\"sudo\");\r\n    when(mock.hasAccessToKey(\"testKey\", u1, KeyOpType.MANAGEMENT)).thenReturn(true);\r\n    when(mock.hasAccessToKey(\"testKey\", u2, KeyOpType.GENERATE_EEK)).thenReturn(true);\r\n    when(mock.hasAccessToKey(\"testKey\", u3, KeyOpType.DECRYPT_EEK)).thenReturn(true);\r\n    when(mock.hasAccessToKey(\"testKey\", sudo, KeyOpType.ALL)).thenReturn(true);\r\n    final KeyProviderCryptoExtension kpExt = new KeyAuthorizationKeyProvider(KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp), mock);\r\n    final KeyVersion barKv = u1.doAs(new PrivilegedExceptionAction<KeyVersion>() {\r\n\r\n        @Override\r\n        public KeyVersion run() throws Exception {\r\n            Options opt = newOptions(conf);\r\n            Map<String, String> m = new HashMap<String, String>();\r\n            m.put(\"key.acl.name\", \"testKey\");\r\n            opt.setAttributes(m);\r\n            try {\r\n                KeyVersion kv = kpExt.createKey(\"foo\", SecureRandom.getSeed(16), opt);\r\n                kpExt.rollNewVersion(kv.getName());\r\n                kpExt.rollNewVersion(kv.getName(), SecureRandom.getSeed(16));\r\n                kpExt.deleteKey(kv.getName());\r\n            } catch (IOException ioe) {\r\n                Assert.fail(\"User should be Authorized !!\");\r\n            }\r\n            KeyVersion retkv = null;\r\n            try {\r\n                retkv = kpExt.createKey(\"bar\", SecureRandom.getSeed(16), opt);\r\n                kpExt.generateEncryptedKey(retkv.getName());\r\n                Assert.fail(\"User should NOT be Authorized to generate EEK !!\");\r\n            } catch (IOException ioe) {\r\n            }\r\n            Assert.assertNotNull(retkv);\r\n            return retkv;\r\n        }\r\n    });\r\n    final EncryptedKeyVersion barEKv = u2.doAs(new PrivilegedExceptionAction<EncryptedKeyVersion>() {\r\n\r\n        @Override\r\n        public EncryptedKeyVersion run() throws Exception {\r\n            try {\r\n                kpExt.deleteKey(barKv.getName());\r\n                Assert.fail(\"User should NOT be Authorized to \" + \"perform any other operation !!\");\r\n            } catch (IOException ioe) {\r\n            }\r\n            return kpExt.generateEncryptedKey(barKv.getName());\r\n        }\r\n    });\r\n    u3.doAs(new PrivilegedExceptionAction<KeyVersion>() {\r\n\r\n        @Override\r\n        public KeyVersion run() throws Exception {\r\n            try {\r\n                kpExt.deleteKey(barKv.getName());\r\n                Assert.fail(\"User should NOT be Authorized to \" + \"perform any other operation !!\");\r\n            } catch (IOException ioe) {\r\n            }\r\n            return kpExt.decryptEncryptedKey(barEKv);\r\n        }\r\n    });\r\n    sudo.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n        @Override\r\n        public Void run() throws Exception {\r\n            Options opt = newOptions(conf);\r\n            Map<String, String> m = new HashMap<String, String>();\r\n            m.put(\"key.acl.name\", \"testKey\");\r\n            opt.setAttributes(m);\r\n            try {\r\n                KeyVersion kv = kpExt.createKey(\"foo\", SecureRandom.getSeed(16), opt);\r\n                kpExt.rollNewVersion(kv.getName());\r\n                kpExt.rollNewVersion(kv.getName(), SecureRandom.getSeed(16));\r\n                EncryptedKeyVersion ekv = kpExt.generateEncryptedKey(kv.getName());\r\n                kpExt.decryptEncryptedKey(ekv);\r\n                kpExt.deleteKey(kv.getName());\r\n            } catch (IOException ioe) {\r\n                Assert.fail(\"User should be Allowed to do everything !!\");\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 5,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "newOptions",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "KeyProvider.Options newOptions(Configuration conf)\n{\r\n    KeyProvider.Options options = new KeyProvider.Options(conf);\r\n    options.setCipher(CIPHER);\r\n    options.setBitLength(128);\r\n    return options;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testDecryptWithKeyVersionNameKeyMismatch",
  "errType" : null,
  "containingMethodsNum" : 16,
  "sourceCodeText" : "void testDecryptWithKeyVersionNameKeyMismatch() throws Exception\n{\r\n    final Configuration conf = new Configuration();\r\n    KeyProvider kp = new UserProvider.Factory().createProvider(new URI(\"user:///\"), conf);\r\n    KeyACLs mock = mock(KeyACLs.class);\r\n    when(mock.isACLPresent(\"testKey\", KeyOpType.MANAGEMENT)).thenReturn(true);\r\n    when(mock.isACLPresent(\"testKey\", KeyOpType.GENERATE_EEK)).thenReturn(true);\r\n    when(mock.isACLPresent(\"testKey\", KeyOpType.DECRYPT_EEK)).thenReturn(true);\r\n    when(mock.isACLPresent(\"testKey\", KeyOpType.ALL)).thenReturn(true);\r\n    UserGroupInformation u1 = UserGroupInformation.createRemoteUser(\"u1\");\r\n    UserGroupInformation u2 = UserGroupInformation.createRemoteUser(\"u2\");\r\n    UserGroupInformation u3 = UserGroupInformation.createRemoteUser(\"u3\");\r\n    UserGroupInformation sudo = UserGroupInformation.createRemoteUser(\"sudo\");\r\n    when(mock.hasAccessToKey(\"testKey\", u1, KeyOpType.MANAGEMENT)).thenReturn(true);\r\n    when(mock.hasAccessToKey(\"testKey\", u2, KeyOpType.GENERATE_EEK)).thenReturn(true);\r\n    when(mock.hasAccessToKey(\"testKey\", u3, KeyOpType.DECRYPT_EEK)).thenReturn(true);\r\n    when(mock.hasAccessToKey(\"testKey\", sudo, KeyOpType.ALL)).thenReturn(true);\r\n    final KeyProviderCryptoExtension kpExt = new KeyAuthorizationKeyProvider(KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp), mock);\r\n    sudo.doAs(new PrivilegedExceptionAction<Void>() {\r\n\r\n        @Override\r\n        public Void run() throws Exception {\r\n            Options opt = newOptions(conf);\r\n            Map<String, String> m = new HashMap<String, String>();\r\n            m.put(\"key.acl.name\", \"testKey\");\r\n            opt.setAttributes(m);\r\n            KeyVersion kv = kpExt.createKey(\"foo\", SecureRandom.getSeed(16), opt);\r\n            kpExt.rollNewVersion(kv.getName());\r\n            kpExt.rollNewVersion(kv.getName(), SecureRandom.getSeed(16));\r\n            EncryptedKeyVersion ekv = kpExt.generateEncryptedKey(kv.getName());\r\n            ekv = EncryptedKeyVersion.createForDecryption(ekv.getEncryptionKeyName() + \"x\", ekv.getEncryptionKeyVersionName(), ekv.getEncryptedKeyIv(), ekv.getEncryptedKeyVersion().getMaterial());\r\n            kpExt.decryptEncryptedKey(ekv);\r\n            return null;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testDefaults",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void testDefaults()\n{\r\n    final KMSACLs acls = new KMSACLs(new Configuration(false));\r\n    for (KMSACLs.Type type : KMSACLs.Type.values()) {\r\n        Assert.assertTrue(acls.hasAccess(type, UserGroupInformation.createRemoteUser(\"foo\")));\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testCustom",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void testCustom()\n{\r\n    final Configuration conf = new Configuration(false);\r\n    for (KMSACLs.Type type : KMSACLs.Type.values()) {\r\n        conf.set(type.getAclConfigKey(), type.toString() + \" \");\r\n    }\r\n    final KMSACLs acls = new KMSACLs(conf);\r\n    for (KMSACLs.Type type : KMSACLs.Type.values()) {\r\n        Assert.assertTrue(acls.hasAccess(type, UserGroupInformation.createRemoteUser(type.toString())));\r\n        Assert.assertFalse(acls.hasAccess(type, UserGroupInformation.createRemoteUser(\"foo\")));\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testKeyAclConfigurationLoad",
  "errType" : null,
  "containingMethodsNum" : 12,
  "sourceCodeText" : "void testKeyAclConfigurationLoad()\n{\r\n    final Configuration conf = new Configuration(false);\r\n    conf.set(KEY_ACL + \"test_key_1.MANAGEMENT\", \"CREATE\");\r\n    conf.set(KEY_ACL + \"test_key_2.ALL\", \"CREATE\");\r\n    conf.set(KEY_ACL + \"test_key_3.NONEXISTOPERATION\", \"CREATE\");\r\n    conf.set(DEFAULT_KEY_ACL_PREFIX + \"MANAGEMENT\", \"ROLLOVER\");\r\n    conf.set(WHITELIST_KEY_ACL_PREFIX + \"MANAGEMENT\", \"DECRYPT_EEK\");\r\n    conf.set(DEFAULT_KEY_ACL_PREFIX + \"ALL\", \"invalid\");\r\n    conf.set(WHITELIST_KEY_ACL_PREFIX + \"ALL\", \"invalid\");\r\n    final KMSACLs acls = new KMSACLs(conf);\r\n    Assert.assertTrue(\"expected key ACL size is 2 but got \" + acls.keyAcls.size(), acls.keyAcls.size() == 2);\r\n    Assert.assertTrue(\"expected whitelist ACL size is 1 but got \" + acls.whitelistKeyAcls.size(), acls.whitelistKeyAcls.size() == 1);\r\n    Assert.assertFalse(\"ALL should not be allowed for whitelist ACLs.\", acls.whitelistKeyAcls.containsKey(KeyOpType.ALL));\r\n    Assert.assertTrue(\"expected default ACL size is 1 but got \" + acls.defaultKeyAcls.size(), acls.defaultKeyAcls.size() == 1);\r\n    Assert.assertTrue(\"ALL should not be allowed for default ACLs.\", acls.defaultKeyAcls.size() == 1);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testKeyAclDuplicateEntries",
  "errType" : null,
  "containingMethodsNum" : 18,
  "sourceCodeText" : "void testKeyAclDuplicateEntries()\n{\r\n    final Configuration conf = new Configuration(false);\r\n    conf.set(KEY_ACL + \"test_key_1.DECRYPT_EEK\", \"decrypt1\");\r\n    conf.set(KEY_ACL + \"test_key_2.ALL\", \"all2\");\r\n    conf.set(KEY_ACL + \"test_key_1.DECRYPT_EEK\", \"decrypt2\");\r\n    conf.set(KEY_ACL + \"test_key_2.ALL\", \"all1,all3\");\r\n    conf.set(DEFAULT_KEY_ACL_PREFIX + \"MANAGEMENT\", \"default1\");\r\n    conf.set(DEFAULT_KEY_ACL_PREFIX + \"MANAGEMENT\", \"\");\r\n    conf.set(DEFAULT_KEY_ACL_PREFIX + \"DECRYPT_EEK\", \"*\");\r\n    conf.set(DEFAULT_KEY_ACL_PREFIX + \"DECRYPT_EEK\", \"\");\r\n    conf.set(WHITELIST_KEY_ACL_PREFIX + \"DECRYPT_EEK\", \"whitelist1\");\r\n    conf.set(WHITELIST_KEY_ACL_PREFIX + \"DECRYPT_EEK\", \"*\");\r\n    final KMSACLs acls = new KMSACLs(conf);\r\n    Assert.assertTrue(\"expected key ACL size is 2 but got \" + acls.keyAcls.size(), acls.keyAcls.size() == 2);\r\n    assertKeyAcl(\"test_key_1\", acls, KeyOpType.DECRYPT_EEK, \"decrypt2\");\r\n    assertKeyAcl(\"test_key_2\", acls, KeyOpType.ALL, \"all1\", \"all3\");\r\n    assertDefaultKeyAcl(acls, KeyOpType.MANAGEMENT);\r\n    assertDefaultKeyAcl(acls, KeyOpType.DECRYPT_EEK);\r\n    AccessControlList acl = acls.whitelistKeyAcls.get(KeyOpType.DECRYPT_EEK);\r\n    Assert.assertNotNull(acl);\r\n    Assert.assertTrue(acl.isAllAllowed());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "testKeyAclReload",
  "errType" : null,
  "containingMethodsNum" : 57,
  "sourceCodeText" : "void testKeyAclReload()\n{\r\n    Configuration conf = new Configuration(false);\r\n    conf.set(DEFAULT_KEY_ACL_PREFIX + \"READ\", \"read1\");\r\n    conf.set(DEFAULT_KEY_ACL_PREFIX + \"MANAGEMENT\", \"\");\r\n    conf.set(DEFAULT_KEY_ACL_PREFIX + \"GENERATE_EEK\", \"*\");\r\n    conf.set(DEFAULT_KEY_ACL_PREFIX + \"DECRYPT_EEK\", \"decrypt1\");\r\n    conf.set(KEY_ACL + \"testuser1.ALL\", \"testkey1\");\r\n    conf.set(WHITELIST_KEY_ACL_PREFIX + \"READ\", \"admin_read1\");\r\n    conf.set(WHITELIST_KEY_ACL_PREFIX + \"MANAGEMENT\", \"\");\r\n    conf.set(WHITELIST_KEY_ACL_PREFIX + \"GENERATE_EEK\", \"*\");\r\n    conf.set(WHITELIST_KEY_ACL_PREFIX + \"DECRYPT_EEK\", \"admin_decrypt1\");\r\n    final KMSACLs acls = new KMSACLs(conf);\r\n    conf.set(DEFAULT_KEY_ACL_PREFIX + \"READ\", \"read2\");\r\n    conf.set(DEFAULT_KEY_ACL_PREFIX + \"MANAGEMENT\", \"mgmt1,mgmt2\");\r\n    conf.set(DEFAULT_KEY_ACL_PREFIX + \"GENERATE_EEK\", \"\");\r\n    conf.set(DEFAULT_KEY_ACL_PREFIX + \"DECRYPT_EEK\", \"decrypt2\");\r\n    conf.set(KEY_ACL + \"testkey1.ALL\", \"testkey1,testkey2\");\r\n    conf.set(WHITELIST_KEY_ACL_PREFIX + \"READ\", \"admin_read2\");\r\n    conf.set(WHITELIST_KEY_ACL_PREFIX + \"MANAGEMENT\", \"admin_mgmt,admin_mgmt1\");\r\n    conf.set(WHITELIST_KEY_ACL_PREFIX + \"GENERATE_EEK\", \"\");\r\n    conf.set(WHITELIST_KEY_ACL_PREFIX + \"DECRYPT_EEK\", \"admin_decrypt2\");\r\n    acls.setKeyACLs(conf);\r\n    assertDefaultKeyAcl(acls, KeyOpType.READ, \"read2\");\r\n    assertDefaultKeyAcl(acls, KeyOpType.MANAGEMENT, \"mgmt1\", \"mgmt2\");\r\n    assertDefaultKeyAcl(acls, KeyOpType.GENERATE_EEK);\r\n    assertDefaultKeyAcl(acls, KeyOpType.DECRYPT_EEK, \"decrypt2\");\r\n    assertKeyAcl(\"testuser1\", acls, KeyOpType.ALL, \"testkey1\");\r\n    assertWhitelistKeyAcl(acls, KeyOpType.READ, \"admin_read2\");\r\n    assertWhitelistKeyAcl(acls, KeyOpType.MANAGEMENT, \"admin_mgmt\", \"admin_mgmt1\");\r\n    assertWhitelistKeyAcl(acls, KeyOpType.GENERATE_EEK);\r\n    assertWhitelistKeyAcl(acls, KeyOpType.DECRYPT_EEK, \"admin_decrypt2\");\r\n    acls.setKeyACLs(conf);\r\n    assertDefaultKeyAcl(acls, KeyOpType.READ, \"read2\");\r\n    assertDefaultKeyAcl(acls, KeyOpType.MANAGEMENT, \"mgmt1\", \"mgmt2\");\r\n    assertDefaultKeyAcl(acls, KeyOpType.GENERATE_EEK);\r\n    assertDefaultKeyAcl(acls, KeyOpType.DECRYPT_EEK, \"decrypt2\");\r\n    assertKeyAcl(\"testuser1\", acls, KeyOpType.ALL, \"testkey1\");\r\n    assertWhitelistKeyAcl(acls, KeyOpType.READ, \"admin_read2\");\r\n    assertWhitelistKeyAcl(acls, KeyOpType.MANAGEMENT, \"admin_mgmt\", \"admin_mgmt1\");\r\n    assertWhitelistKeyAcl(acls, KeyOpType.GENERATE_EEK);\r\n    assertWhitelistKeyAcl(acls, KeyOpType.DECRYPT_EEK, \"admin_decrypt2\");\r\n    conf.set(DEFAULT_KEY_ACL_PREFIX + \"DECRYPT_EEK\", \"*\");\r\n    acls.setKeyACLs(conf);\r\n    AccessControlList acl = acls.defaultKeyAcls.get(KeyOpType.DECRYPT_EEK);\r\n    Assert.assertTrue(acl.isAllAllowed());\r\n    Assert.assertTrue(acl.getUsers().isEmpty());\r\n    assertDefaultKeyAcl(acls, KeyOpType.READ, \"read2\");\r\n    assertDefaultKeyAcl(acls, KeyOpType.MANAGEMENT, \"mgmt1\", \"mgmt2\");\r\n    assertDefaultKeyAcl(acls, KeyOpType.GENERATE_EEK);\r\n    assertKeyAcl(\"testuser1\", acls, KeyOpType.ALL, \"testkey1\");\r\n    assertWhitelistKeyAcl(acls, KeyOpType.READ, \"admin_read2\");\r\n    assertWhitelistKeyAcl(acls, KeyOpType.MANAGEMENT, \"admin_mgmt\", \"admin_mgmt1\");\r\n    assertWhitelistKeyAcl(acls, KeyOpType.GENERATE_EEK);\r\n    assertWhitelistKeyAcl(acls, KeyOpType.DECRYPT_EEK, \"admin_decrypt2\");\r\n    conf = new Configuration();\r\n    conf.set(DEFAULT_KEY_ACL_PREFIX + \"DECRYPT_EEK\", \"new\");\r\n    acls.setKeyACLs(conf);\r\n    assertDefaultKeyAcl(acls, KeyOpType.DECRYPT_EEK, \"new\");\r\n    Assert.assertTrue(acls.keyAcls.isEmpty());\r\n    Assert.assertTrue(acls.whitelistKeyAcls.isEmpty());\r\n    Assert.assertEquals(\"Got unexpected sized acls:\" + acls.defaultKeyAcls, 1, acls.defaultKeyAcls.size());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "assertDefaultKeyAcl",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void assertDefaultKeyAcl(final KMSACLs acls, final KeyOpType op, final String... names)\n{\r\n    final AccessControlList acl = acls.defaultKeyAcls.get(op);\r\n    assertAcl(acl, op, names);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "assertWhitelistKeyAcl",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void assertWhitelistKeyAcl(final KMSACLs acls, final KeyOpType op, final String... names)\n{\r\n    final AccessControlList acl = acls.whitelistKeyAcls.get(op);\r\n    assertAcl(acl, op, names);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "assertKeyAcl",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void assertKeyAcl(final String keyName, final KMSACLs acls, final KeyOpType op, final String... names)\n{\r\n    Assert.assertTrue(acls.keyAcls.containsKey(keyName));\r\n    final HashMap<KeyOpType, AccessControlList> keyacl = acls.keyAcls.get(keyName);\r\n    Assert.assertNotNull(keyacl.get(op));\r\n    assertAcl(keyacl.get(op), op, names);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-kms\\src\\test\\java\\org\\apache\\hadoop\\crypto\\key\\kms\\server",
  "methodName" : "assertAcl",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void assertAcl(final AccessControlList acl, final KeyOpType op, final String... names)\n{\r\n    Assert.assertNotNull(acl);\r\n    Assert.assertFalse(acl.isAllAllowed());\r\n    final Collection<String> actual = acl.getUsers();\r\n    final HashSet<String> expected = new HashSet<>();\r\n    for (String name : names) {\r\n        expected.add(name);\r\n    }\r\n    Assert.assertEquals(\"defaultKeyAcls don't match for op:\" + op, expected, actual);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
} ]