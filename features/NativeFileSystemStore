[ {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getScheme",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getScheme()\n{\r\n    return CosNFileSystem.SCHEME;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "initialize",
  "errType" : null,
  "containingMethodsNum" : 17,
  "sourceCodeText" : "void initialize(URI name, Configuration conf) throws IOException\n{\r\n    super.initialize(name, conf);\r\n    this.bucket = name.getHost();\r\n    if (this.store == null) {\r\n        this.store = createDefaultStore(conf);\r\n    }\r\n    this.store.initialize(name, conf);\r\n    setConf(conf);\r\n    this.uri = URI.create(name.getScheme() + \"://\" + name.getAuthority());\r\n    this.workingDir = new Path(\"/user\", System.getProperty(\"user.name\")).makeQualified(this.uri, this.getWorkingDirectory());\r\n    this.owner = getOwnerId();\r\n    this.group = getGroupId();\r\n    LOG.debug(\"owner:\" + owner + \", group:\" + group);\r\n    BufferPool.getInstance().initialize(this.getConf());\r\n    int uploadThreadPoolSize = this.getConf().getInt(CosNConfigKeys.UPLOAD_THREAD_POOL_SIZE_KEY, CosNConfigKeys.DEFAULT_UPLOAD_THREAD_POOL_SIZE);\r\n    int readAheadPoolSize = this.getConf().getInt(CosNConfigKeys.READ_AHEAD_QUEUE_SIZE, CosNConfigKeys.DEFAULT_READ_AHEAD_QUEUE_SIZE);\r\n    int ioThreadPoolSize = uploadThreadPoolSize + readAheadPoolSize / 3;\r\n    long threadKeepAlive = this.getConf().getLong(CosNConfigKeys.THREAD_KEEP_ALIVE_TIME_KEY, CosNConfigKeys.DEFAULT_THREAD_KEEP_ALIVE_TIME);\r\n    this.boundedIOThreadPool = BlockingThreadPoolExecutorService.newInstance(ioThreadPoolSize / 2, ioThreadPoolSize, threadKeepAlive, TimeUnit.SECONDS, \"cos-transfer-thread-pool\");\r\n    int copyThreadPoolSize = this.getConf().getInt(CosNConfigKeys.COPY_THREAD_POOL_SIZE_KEY, CosNConfigKeys.DEFAULT_COPY_THREAD_POOL_SIZE);\r\n    this.boundedCopyThreadPool = BlockingThreadPoolExecutorService.newInstance(CosNConfigKeys.DEFAULT_COPY_THREAD_POOL_SIZE, copyThreadPoolSize, 60L, TimeUnit.SECONDS, \"cos-copy-thread-pool\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "createDefaultStore",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "NativeFileSystemStore createDefaultStore(Configuration conf)\n{\r\n    NativeFileSystemStore store = new CosNativeFileSystemStore();\r\n    RetryPolicy basePolicy = RetryPolicies.retryUpToMaximumCountWithFixedSleep(conf.getInt(CosNConfigKeys.COSN_MAX_RETRIES_KEY, CosNConfigKeys.DEFAULT_MAX_RETRIES), conf.getLong(CosNConfigKeys.COSN_RETRY_INTERVAL_KEY, CosNConfigKeys.DEFAULT_RETRY_INTERVAL), TimeUnit.SECONDS);\r\n    Map<Class<? extends Exception>, RetryPolicy> exceptionToPolicyMap = new HashMap<>();\r\n    exceptionToPolicyMap.put(IOException.class, basePolicy);\r\n    RetryPolicy methodPolicy = RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL, exceptionToPolicyMap);\r\n    Map<String, RetryPolicy> methodNameToPolicyMap = new HashMap<>();\r\n    methodNameToPolicyMap.put(\"storeFile\", methodPolicy);\r\n    methodNameToPolicyMap.put(\"rename\", methodPolicy);\r\n    return (NativeFileSystemStore) RetryProxy.create(NativeFileSystemStore.class, store, methodNameToPolicyMap);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getOwnerId",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String getOwnerId()\n{\r\n    return System.getProperty(\"user.name\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getGroupId",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String getGroupId()\n{\r\n    return System.getProperty(\"user.name\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getOwnerInfo",
  "errType" : [ "IOException|InterruptedException" ],
  "containingMethodsNum" : 9,
  "sourceCodeText" : "String getOwnerInfo(boolean getOwnerId)\n{\r\n    String ownerInfoId = \"\";\r\n    try {\r\n        String userName = System.getProperty(\"user.name\");\r\n        String command = \"id -u \" + userName;\r\n        if (!getOwnerId) {\r\n            command = \"id -g \" + userName;\r\n        }\r\n        Process child = Runtime.getRuntime().exec(command);\r\n        child.waitFor();\r\n        InputStream in = child.getInputStream();\r\n        StringBuilder strBuffer = new StringBuilder();\r\n        int c;\r\n        while ((c = in.read()) != -1) {\r\n            strBuffer.append((char) c);\r\n        }\r\n        in.close();\r\n        ownerInfoId = strBuffer.toString();\r\n    } catch (IOException | InterruptedException e) {\r\n        LOG.error(\"Getting owner info occurs a exception\", e);\r\n    }\r\n    return ownerInfoId;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "pathToKey",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "String pathToKey(Path path)\n{\r\n    if (path.toUri().getScheme() != null && path.toUri().getPath().isEmpty()) {\r\n        return \"\";\r\n    }\r\n    if (!path.isAbsolute()) {\r\n        throw new IllegalArgumentException(\"Path must be absolute: \" + path);\r\n    }\r\n    String ret = path.toUri().getPath();\r\n    if (ret.endsWith(\"/\") && (ret.indexOf(\"/\") != ret.length() - 1)) {\r\n        ret = ret.substring(0, ret.length() - 1);\r\n    }\r\n    return ret;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "keyToPath",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Path keyToPath(String key)\n{\r\n    if (!key.startsWith(PATH_DELIMITER)) {\r\n        return new Path(\"/\" + key);\r\n    } else {\r\n        return new Path(key);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "makeAbsolute",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Path makeAbsolute(Path path)\n{\r\n    if (path.isAbsolute()) {\r\n        return path;\r\n    }\r\n    return new Path(workingDir, path);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "append",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "FSDataOutputStream append(Path f, int bufferSize, Progressable progress) throws IOException\n{\r\n    throw new IOException(\"Not supported\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "create",
  "errType" : [ "FileNotFoundException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "FSDataOutputStream create(Path f, FsPermission permission, boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress) throws IOException\n{\r\n    FileStatus fileStatus;\r\n    try {\r\n        fileStatus = getFileStatus(f);\r\n        if (fileStatus.isDirectory()) {\r\n            throw new FileAlreadyExistsException(f + \" is a directory\");\r\n        }\r\n        if (!overwrite) {\r\n            throw new FileAlreadyExistsException(f + \" already exists\");\r\n        }\r\n    } catch (FileNotFoundException e) {\r\n        LOG.debug(\"Creating a new file: [{}] in COS.\", f);\r\n    }\r\n    Path absolutePath = makeAbsolute(f);\r\n    String key = pathToKey(absolutePath);\r\n    return new FSDataOutputStream(new CosNOutputStream(getConf(), store, key, blockSize, this.boundedIOThreadPool), statistics);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "rejectRootDirectoryDelete",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean rejectRootDirectoryDelete(boolean isEmptyDir, boolean recursive) throws PathIOException\n{\r\n    if (isEmptyDir) {\r\n        return true;\r\n    }\r\n    if (recursive) {\r\n        return false;\r\n    } else {\r\n        throw new PathIOException(this.bucket, \"Can not delete root path\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "createNonRecursive",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "FSDataOutputStream createNonRecursive(Path f, FsPermission permission, EnumSet<CreateFlag> flags, int bufferSize, short replication, long blockSize, Progressable progress) throws IOException\n{\r\n    Path parent = f.getParent();\r\n    if (null != parent) {\r\n        if (!getFileStatus(parent).isDirectory()) {\r\n            throw new FileAlreadyExistsException(\"Not a directory: \" + parent);\r\n        }\r\n    }\r\n    return create(f, permission, flags.contains(CreateFlag.OVERWRITE), bufferSize, replication, blockSize, progress);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "delete",
  "errType" : [ "FileNotFoundException", "Exception" ],
  "containingMethodsNum" : 24,
  "sourceCodeText" : "boolean delete(Path f, boolean recursive) throws IOException\n{\r\n    LOG.debug(\"Ready to delete path: [{}]. recursive: [{}].\", f, recursive);\r\n    FileStatus status;\r\n    try {\r\n        status = getFileStatus(f);\r\n    } catch (FileNotFoundException e) {\r\n        LOG.debug(\"Ready to delete the file: [{}], but it does not exist.\", f);\r\n        return false;\r\n    }\r\n    Path absolutePath = makeAbsolute(f);\r\n    String key = pathToKey(absolutePath);\r\n    if (key.compareToIgnoreCase(\"/\") == 0) {\r\n        FileStatus[] fileStatuses = listStatus(f);\r\n        return this.rejectRootDirectoryDelete(fileStatuses.length == 0, recursive);\r\n    }\r\n    if (status.isDirectory()) {\r\n        if (!key.endsWith(PATH_DELIMITER)) {\r\n            key += PATH_DELIMITER;\r\n        }\r\n        if (!recursive && listStatus(f).length > 0) {\r\n            String errMsg = String.format(\"Can not delete the directory: [%s], as\" + \" it is not empty and option recursive is false.\", f);\r\n            throw new IOException(errMsg);\r\n        }\r\n        createParent(f);\r\n        String priorLastKey = null;\r\n        do {\r\n            PartialListing listing = store.list(key, Constants.COS_MAX_LISTING_LENGTH, priorLastKey, true);\r\n            for (FileMetadata file : listing.getFiles()) {\r\n                store.delete(file.getKey());\r\n            }\r\n            for (FileMetadata commonPrefix : listing.getCommonPrefixes()) {\r\n                store.delete(commonPrefix.getKey());\r\n            }\r\n            priorLastKey = listing.getPriorLastKey();\r\n        } while (priorLastKey != null);\r\n        try {\r\n            store.delete(key);\r\n        } catch (Exception e) {\r\n            LOG.error(\"Deleting the COS key: [{}] occurs an exception.\", key, e);\r\n        }\r\n    } else {\r\n        LOG.debug(\"Delete the file: {}\", f);\r\n        createParent(f);\r\n        store.delete(key);\r\n    }\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getFileStatus",
  "errType" : null,
  "containingMethodsNum" : 19,
  "sourceCodeText" : "FileStatus getFileStatus(Path f) throws IOException\n{\r\n    Path absolutePath = makeAbsolute(f);\r\n    String key = pathToKey(absolutePath);\r\n    if (key.length() == 0) {\r\n        return newDirectory(absolutePath);\r\n    }\r\n    LOG.debug(\"Call the getFileStatus to obtain the metadata for \" + \"the file: [{}].\", f);\r\n    FileMetadata meta = store.retrieveMetadata(key);\r\n    if (meta != null) {\r\n        if (meta.isFile()) {\r\n            LOG.debug(\"Path: [{}] is a file. COS key: [{}]\", f, key);\r\n            return newFile(meta, absolutePath);\r\n        } else {\r\n            LOG.debug(\"Path: [{}] is a dir. COS key: [{}]\", f, key);\r\n            return newDirectory(meta, absolutePath);\r\n        }\r\n    }\r\n    if (!key.endsWith(PATH_DELIMITER)) {\r\n        key += PATH_DELIMITER;\r\n    }\r\n    LOG.debug(\"List COS key: [{}] to check the existence of the path.\", key);\r\n    PartialListing listing = store.list(key, 1);\r\n    if (listing.getFiles().length > 0 || listing.getCommonPrefixes().length > 0) {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Path: [{}] is a directory. COS key: [{}]\", f, key);\r\n        }\r\n        return newDirectory(absolutePath);\r\n    }\r\n    throw new FileNotFoundException(\"No such file or directory '\" + absolutePath + \"'\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getUri",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "URI getUri()\n{\r\n    return uri;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "listStatus",
  "errType" : null,
  "containingMethodsNum" : 19,
  "sourceCodeText" : "FileStatus[] listStatus(Path f) throws IOException\n{\r\n    Path absolutePath = makeAbsolute(f);\r\n    String key = pathToKey(absolutePath);\r\n    if (key.length() > 0) {\r\n        FileStatus fileStatus = this.getFileStatus(f);\r\n        if (fileStatus.isFile()) {\r\n            return new FileStatus[] { fileStatus };\r\n        }\r\n    }\r\n    if (!key.endsWith(PATH_DELIMITER)) {\r\n        key += PATH_DELIMITER;\r\n    }\r\n    URI pathUri = absolutePath.toUri();\r\n    Set<FileStatus> status = new TreeSet<>();\r\n    String priorLastKey = null;\r\n    do {\r\n        PartialListing listing = store.list(key, Constants.COS_MAX_LISTING_LENGTH, priorLastKey, false);\r\n        for (FileMetadata fileMetadata : listing.getFiles()) {\r\n            Path subPath = keyToPath(fileMetadata.getKey());\r\n            if (fileMetadata.getKey().equals(key)) {\r\n                LOG.debug(\"The file list contains the COS key [{}] to be listed.\", key);\r\n            } else {\r\n                status.add(newFile(fileMetadata, subPath));\r\n            }\r\n        }\r\n        for (FileMetadata commonPrefix : listing.getCommonPrefixes()) {\r\n            Path subPath = keyToPath(commonPrefix.getKey());\r\n            String relativePath = pathUri.relativize(subPath.toUri()).getPath();\r\n            status.add(newDirectory(commonPrefix, new Path(absolutePath, relativePath)));\r\n        }\r\n        priorLastKey = listing.getPriorLastKey();\r\n    } while (priorLastKey != null);\r\n    return status.toArray(new FileStatus[status.size()]);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "newFile",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "FileStatus newFile(FileMetadata meta, Path path)\n{\r\n    return new FileStatus(meta.getLength(), false, 1, getDefaultBlockSize(), meta.getLastModified(), 0, null, this.owner, this.group, path.makeQualified(this.getUri(), this.getWorkingDirectory()));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "newDirectory",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "FileStatus newDirectory(Path path)\n{\r\n    return new FileStatus(0, true, 1, 0, 0, 0, null, this.owner, this.group, path.makeQualified(this.getUri(), this.getWorkingDirectory()));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "newDirectory",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "FileStatus newDirectory(FileMetadata meta, Path path)\n{\r\n    if (meta == null) {\r\n        return newDirectory(path);\r\n    }\r\n    return new FileStatus(0, true, 1, 0, meta.getLastModified(), 0, null, this.owner, this.group, path.makeQualified(this.getUri(), this.getWorkingDirectory()));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "validatePath",
  "errType" : [ "FileNotFoundException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void validatePath(Path path) throws IOException\n{\r\n    Path parent = path.getParent();\r\n    do {\r\n        try {\r\n            FileStatus fileStatus = getFileStatus(parent);\r\n            if (fileStatus.isDirectory()) {\r\n                break;\r\n            } else {\r\n                throw new FileAlreadyExistsException(String.format(\"Can't make directory for path '%s', it is a file.\", parent));\r\n            }\r\n        } catch (FileNotFoundException e) {\r\n            LOG.debug(\"The Path: [{}] does not exist.\", path);\r\n        }\r\n        parent = parent.getParent();\r\n    } while (parent != null);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "mkdirs",
  "errType" : [ "FileNotFoundException" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "boolean mkdirs(Path f, FsPermission permission) throws IOException\n{\r\n    try {\r\n        FileStatus fileStatus = getFileStatus(f);\r\n        if (fileStatus.isDirectory()) {\r\n            return true;\r\n        } else {\r\n            throw new FileAlreadyExistsException(\"Path is a file: \" + f);\r\n        }\r\n    } catch (FileNotFoundException e) {\r\n        validatePath(f);\r\n    }\r\n    return mkDirRecursively(f, permission);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "mkDirRecursively",
  "errType" : [ "FileNotFoundException" ],
  "containingMethodsNum" : 12,
  "sourceCodeText" : "boolean mkDirRecursively(Path f, FsPermission permission) throws IOException\n{\r\n    Path absolutePath = makeAbsolute(f);\r\n    List<Path> paths = new ArrayList<>();\r\n    do {\r\n        paths.add(absolutePath);\r\n        absolutePath = absolutePath.getParent();\r\n    } while (absolutePath != null);\r\n    for (Path path : paths) {\r\n        if (path.equals(new Path(CosNFileSystem.PATH_DELIMITER))) {\r\n            break;\r\n        }\r\n        try {\r\n            FileStatus fileStatus = getFileStatus(path);\r\n            if (fileStatus.isFile()) {\r\n                throw new FileAlreadyExistsException(String.format(\"Can't make directory for path: %s, \" + \"since it is a file.\", f));\r\n            }\r\n            if (fileStatus.isDirectory()) {\r\n                break;\r\n            }\r\n        } catch (FileNotFoundException e) {\r\n            LOG.debug(\"Making dir: [{}] in COS\", f);\r\n            String folderPath = pathToKey(makeAbsolute(f));\r\n            if (!folderPath.endsWith(PATH_DELIMITER)) {\r\n                folderPath += PATH_DELIMITER;\r\n            }\r\n            store.storeEmptyFile(folderPath);\r\n        }\r\n    }\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "mkdir",
  "errType" : [ "FileNotFoundException" ],
  "containingMethodsNum" : 8,
  "sourceCodeText" : "boolean mkdir(Path f) throws IOException\n{\r\n    try {\r\n        FileStatus fileStatus = getFileStatus(f);\r\n        if (fileStatus.isFile()) {\r\n            throw new FileAlreadyExistsException(String.format(\"Can't make directory for path '%s' since it is a file.\", f));\r\n        }\r\n    } catch (FileNotFoundException e) {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Make directory: [{}] in COS.\", f);\r\n        }\r\n        String folderPath = pathToKey(makeAbsolute(f));\r\n        if (!folderPath.endsWith(PATH_DELIMITER)) {\r\n            folderPath += PATH_DELIMITER;\r\n        }\r\n        store.storeEmptyFile(folderPath);\r\n    }\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "open",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "FSDataInputStream open(Path f, int bufferSize) throws IOException\n{\r\n    FileStatus fs = getFileStatus(f);\r\n    if (fs.isDirectory()) {\r\n        throw new FileNotFoundException(\"'\" + f + \"' is a directory\");\r\n    }\r\n    LOG.info(\"Open the file: [{}] for reading.\", f);\r\n    Path absolutePath = makeAbsolute(f);\r\n    String key = pathToKey(absolutePath);\r\n    long fileSize = store.getFileLength(key);\r\n    return new FSDataInputStream(new BufferedFSInputStream(new CosNInputStream(this.getConf(), store, statistics, key, fileSize, this.boundedIOThreadPool), bufferSize));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "rename",
  "errType" : [ "FileNotFoundException", "FileNotFoundException" ],
  "containingMethodsNum" : 27,
  "sourceCodeText" : "boolean rename(Path src, Path dst) throws IOException\n{\r\n    LOG.debug(\"Rename source path: [{}] to dest path: [{}].\", src, dst);\r\n    if (src.isRoot()) {\r\n        LOG.debug(\"Cannot rename the root directory of a filesystem.\");\r\n        return false;\r\n    }\r\n    FileStatus srcFileStatus = this.getFileStatus(src);\r\n    if (src.equals(dst)) {\r\n        LOG.debug(\"Source path and dest path refer to \" + \"the same file or directory: [{}].\", dst);\r\n        throw new IOException(\"Source path and dest path refer \" + \"the same file or directory\");\r\n    }\r\n    Path dstParentPath;\r\n    for (dstParentPath = dst.getParent(); null != dstParentPath && !src.equals(dstParentPath); dstParentPath = dstParentPath.getParent()) {\r\n        LOG.debug(\"Recursively find the common parent directory of the source \" + \"and destination paths. The currently found parent path: {}\", dstParentPath);\r\n    }\r\n    if (null != dstParentPath) {\r\n        LOG.debug(\"It is not allowed to rename a parent directory:[{}] \" + \"to its subdirectory:[{}].\", src, dst);\r\n        throw new IOException(String.format(\"It is not allowed to rename a parent directory: %s \" + \"to its subdirectory: %s\", src, dst));\r\n    }\r\n    FileStatus dstFileStatus;\r\n    try {\r\n        dstFileStatus = this.getFileStatus(dst);\r\n        if (dstFileStatus.isFile()) {\r\n            throw new FileAlreadyExistsException(String.format(\"File: %s already exists\", dstFileStatus.getPath()));\r\n        } else {\r\n            dst = new Path(dst, src.getName());\r\n            FileStatus[] statuses;\r\n            try {\r\n                statuses = this.listStatus(dst);\r\n            } catch (FileNotFoundException e) {\r\n                statuses = null;\r\n            }\r\n            if (null != statuses && statuses.length > 0) {\r\n                LOG.debug(\"Cannot rename source file: [{}] to dest file: [{}], \" + \"because the file already exists.\", src, dst);\r\n                throw new FileAlreadyExistsException(String.format(\"File: %s already exists\", dst));\r\n            }\r\n        }\r\n    } catch (FileNotFoundException e) {\r\n        Path tempDstParentPath = dst.getParent();\r\n        FileStatus dstParentStatus = this.getFileStatus(tempDstParentPath);\r\n        if (!dstParentStatus.isDirectory()) {\r\n            throw new IOException(String.format(\"Cannot rename %s to %s, %s is a file\", src, dst, dst.getParent()));\r\n        }\r\n    }\r\n    boolean result;\r\n    if (srcFileStatus.isDirectory()) {\r\n        result = this.copyDirectory(src, dst);\r\n    } else {\r\n        result = this.copyFile(src, dst);\r\n    }\r\n    if (!result) {\r\n        return false;\r\n    } else {\r\n        return this.delete(src, true);\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "copyFile",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "boolean copyFile(Path srcPath, Path dstPath) throws IOException\n{\r\n    String srcKey = pathToKey(srcPath);\r\n    String dstKey = pathToKey(dstPath);\r\n    this.store.copy(srcKey, dstKey);\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "copyDirectory",
  "errType" : [ "InterruptedException" ],
  "containingMethodsNum" : 16,
  "sourceCodeText" : "boolean copyDirectory(Path srcPath, Path dstPath) throws IOException\n{\r\n    String srcKey = pathToKey(srcPath);\r\n    if (!srcKey.endsWith(PATH_DELIMITER)) {\r\n        srcKey += PATH_DELIMITER;\r\n    }\r\n    String dstKey = pathToKey(dstPath);\r\n    if (!dstKey.endsWith(PATH_DELIMITER)) {\r\n        dstKey += PATH_DELIMITER;\r\n    }\r\n    if (dstKey.startsWith(srcKey)) {\r\n        throw new IOException(\"can not copy a directory to a subdirectory of self\");\r\n    }\r\n    this.store.storeEmptyFile(dstKey);\r\n    CosNCopyFileContext copyFileContext = new CosNCopyFileContext();\r\n    int copiesToFinishes = 0;\r\n    String priorLastKey = null;\r\n    do {\r\n        PartialListing objectList = this.store.list(srcKey, Constants.COS_MAX_LISTING_LENGTH, priorLastKey, true);\r\n        for (FileMetadata file : objectList.getFiles()) {\r\n            this.boundedCopyThreadPool.execute(new CosNCopyFileTask(this.store, file.getKey(), dstKey.concat(file.getKey().substring(srcKey.length())), copyFileContext));\r\n            copiesToFinishes++;\r\n            if (!copyFileContext.isCopySuccess()) {\r\n                break;\r\n            }\r\n        }\r\n        priorLastKey = objectList.getPriorLastKey();\r\n    } while (null != priorLastKey);\r\n    copyFileContext.lock();\r\n    try {\r\n        copyFileContext.awaitAllFinish(copiesToFinishes);\r\n    } catch (InterruptedException e) {\r\n        LOG.warn(\"interrupted when wait copies to finish\");\r\n    } finally {\r\n        copyFileContext.lock();\r\n    }\r\n    return copyFileContext.isCopySuccess();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "createParent",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void createParent(Path path) throws IOException\n{\r\n    Path parent = path.getParent();\r\n    if (parent != null) {\r\n        String parentKey = pathToKey(parent);\r\n        LOG.debug(\"Create parent key: {}\", parentKey);\r\n        if (!parentKey.equals(PATH_DELIMITER)) {\r\n            String key = pathToKey(makeAbsolute(parent));\r\n            if (key.length() > 0) {\r\n                try {\r\n                    store.storeEmptyFile(key + PATH_DELIMITER);\r\n                } catch (IOException e) {\r\n                    LOG.debug(\"Store a empty file in COS failed.\", e);\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getDefaultBlockSize",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "long getDefaultBlockSize()\n{\r\n    return getConf().getLong(CosNConfigKeys.COSN_BLOCK_SIZE_KEY, CosNConfigKeys.DEFAULT_BLOCK_SIZE);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "setWorkingDirectory",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void setWorkingDirectory(Path newDir)\n{\r\n    workingDir = newDir;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getWorkingDirectory",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Path getWorkingDirectory()\n{\r\n    return workingDir;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getCanonicalServiceName",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getCanonicalServiceName()\n{\r\n    return null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "close",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void close() throws IOException\n{\r\n    try {\r\n        this.store.close();\r\n        this.boundedIOThreadPool.shutdown();\r\n        this.boundedCopyThreadPool.shutdown();\r\n    } finally {\r\n        super.close();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getFiles",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "FileMetadata[] getFiles()\n{\r\n    return files;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getCommonPrefixes",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "FileMetadata[] getCommonPrefixes()\n{\r\n    return commonPrefixes;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getPriorLastKey",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getPriorLastKey()\n{\r\n    return priorLastKey;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "run",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void run()\n{\r\n    boolean fail = false;\r\n    LOG.info(Thread.currentThread().getName() + \"copying...\");\r\n    try {\r\n        this.store.copy(srcKey, dstKey);\r\n    } catch (IOException e) {\r\n        LOG.warn(\"Exception thrown when copy from {} to {}, exception:{}\", this.srcKey, this.dstKey, e);\r\n        fail = true;\r\n    } finally {\r\n        this.cosCopyFileContext.lock();\r\n        if (fail) {\r\n            cosCopyFileContext.setCopySuccess(false);\r\n        }\r\n        cosCopyFileContext.incCopiesFinish();\r\n        cosCopyFileContext.signalAll();\r\n        this.cosCopyFileContext.unlock();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "lock",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void lock()\n{\r\n    this.lock.lock();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "unlock",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void unlock()\n{\r\n    this.lock.unlock();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "awaitAllFinish",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void awaitAllFinish(int waitCopiesFinish) throws InterruptedException\n{\r\n    while (this.copiesFinish.get() != waitCopiesFinish) {\r\n        this.readyCondition.await();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "signalAll",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void signalAll()\n{\r\n    this.readyCondition.signalAll();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "isCopySuccess",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean isCopySuccess()\n{\r\n    return this.copySuccess.get();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "setCopySuccess",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void setCopySuccess(boolean copySuccess)\n{\r\n    this.copySuccess.set(copySuccess);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "incCopiesFinish",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void incCopiesFinish()\n{\r\n    this.copiesFinish.addAndGet(1);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn\\auth",
  "methodName" : "getCredentials",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "COSCredentials getCredentials()\n{\r\n    String secretId = System.getenv(Constants.COSN_SECRET_ID_ENV);\r\n    String secretKey = System.getenv(Constants.COSN_SECRET_KEY_ENV);\r\n    secretId = StringUtils.trim(secretId);\r\n    secretKey = StringUtils.trim(secretKey);\r\n    if (!StringUtils.isNullOrEmpty(secretId) && !StringUtils.isNullOrEmpty(secretKey)) {\r\n        return new BasicCOSCredentials(secretId, secretKey);\r\n    }\r\n    return null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn\\auth",
  "methodName" : "refresh",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void refresh()\n{\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn\\auth",
  "methodName" : "toString",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String toString()\n{\r\n    return String.format(\"EnvironmentVariableCredentialsProvider{%s, %s}\", Constants.COSN_SECRET_ID_ENV, Constants.COSN_SECRET_KEY_ENV);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "write",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void write(int b)\n{\r\n    byte[] singleBytes = new byte[1];\r\n    singleBytes[0] = (byte) b;\r\n    this.byteBuffer.put(singleBytes, 0, 1);\r\n    this.isFlush = false;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "flush",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void flush()\n{\r\n    if (this.isFlush) {\r\n        return;\r\n    }\r\n    this.isFlush = true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "close",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void close() throws IOException\n{\r\n    if (this.isClosed) {\r\n        return;\r\n    }\r\n    if (null == this.byteBuffer) {\r\n        throw new IOException(\"Can not close a null object\");\r\n    }\r\n    this.flush();\r\n    this.byteBuffer.flip();\r\n    this.byteBuffer = null;\r\n    this.isFlush = false;\r\n    this.isClosed = true;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn\\auth",
  "methodName" : "add",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void add(COSCredentialsProvider provider)\n{\r\n    this.providers.add(provider);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn\\auth",
  "methodName" : "getRefCount",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "int getRefCount()\n{\r\n    return this.refCount.get();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn\\auth",
  "methodName" : "checkNotEmpty",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void checkNotEmpty()\n{\r\n    if (this.providers.isEmpty()) {\r\n        throw new NoAuthWithCOSException(NO_COS_CREDENTIAL_PROVIDERS);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn\\auth",
  "methodName" : "share",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "COSCredentialsProviderList share()\n{\r\n    Preconditions.checkState(!this.closed(), \"Provider list is closed\");\r\n    this.refCount.incrementAndGet();\r\n    return this;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn\\auth",
  "methodName" : "closed",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean closed()\n{\r\n    return this.isClosed.get();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn\\auth",
  "methodName" : "getCredentials",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "COSCredentials getCredentials()\n{\r\n    if (this.closed()) {\r\n        throw new NoAuthWithCOSException(CREDENTIALS_REQUESTED_WHEN_CLOSED);\r\n    }\r\n    this.checkNotEmpty();\r\n    if (this.reuseLastProvider && this.lastProvider != null) {\r\n        return this.lastProvider.getCredentials();\r\n    }\r\n    for (COSCredentialsProvider provider : this.providers) {\r\n        COSCredentials credentials = provider.getCredentials();\r\n        if (null != credentials && !StringUtils.isNullOrEmpty(credentials.getCOSAccessKeyId()) && !StringUtils.isNullOrEmpty(credentials.getCOSSecretKey()) || credentials instanceof AnonymousCOSCredentials) {\r\n            this.lastProvider = provider;\r\n            return credentials;\r\n        }\r\n    }\r\n    throw new NoAuthWithCOSException(\"No COS Credentials provided by \" + this.providers.toString());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn\\auth",
  "methodName" : "refresh",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void refresh()\n{\r\n    if (this.closed()) {\r\n        return;\r\n    }\r\n    for (COSCredentialsProvider cosCredentialsProvider : this.providers) {\r\n        cosCredentialsProvider.refresh();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn\\auth",
  "methodName" : "close",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void close() throws Exception\n{\r\n    if (this.closed()) {\r\n        return;\r\n    }\r\n    int remainder = this.refCount.decrementAndGet();\r\n    if (remainder != 0) {\r\n        return;\r\n    }\r\n    this.isClosed.set(true);\r\n    for (COSCredentialsProvider provider : this.providers) {\r\n        if (provider instanceof Closeable) {\r\n            ((Closeable) provider).close();\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "run",
  "errType" : [ "IOException", "Exception" ],
  "containingMethodsNum" : 13,
  "sourceCodeText" : "void run()\n{\r\n    int retries = 0;\r\n    RetryPolicy.RetryAction retryAction;\r\n    try {\r\n        this.readBuffer.lock();\r\n        do {\r\n            try {\r\n                InputStream inputStream = this.store.retrieveBlock(this.key, this.readBuffer.getStart(), this.readBuffer.getEnd());\r\n                IOUtils.readFully(inputStream, this.readBuffer.getBuffer(), 0, readBuffer.getBuffer().length);\r\n                inputStream.close();\r\n                this.readBuffer.setStatus(CosNInputStream.ReadBuffer.SUCCESS);\r\n                break;\r\n            } catch (IOException e) {\r\n                this.readBuffer.setStatus(CosNInputStream.ReadBuffer.ERROR);\r\n                LOG.warn(\"Exception occurs when retrieve the block range start: \" + String.valueOf(this.readBuffer.getStart()) + \" end: \" + this.readBuffer.getEnd());\r\n                try {\r\n                    retryAction = this.retryPolicy.shouldRetry(e, retries++, 0, true);\r\n                    if (retryAction.action == RetryPolicy.RetryAction.RetryDecision.RETRY) {\r\n                        Thread.sleep(retryAction.delayMillis);\r\n                    }\r\n                } catch (Exception e1) {\r\n                    String errMsg = String.format(\"Exception occurs when retry[%s] \" + \"to retrieve the block range start: %s, end:%s\", this.retryPolicy.toString(), String.valueOf(this.readBuffer.getStart()), String.valueOf(this.readBuffer.getEnd()));\r\n                    LOG.error(errMsg, e1);\r\n                    break;\r\n                }\r\n            }\r\n        } while (retryAction.action == RetryPolicy.RetryAction.RetryDecision.RETRY);\r\n        this.readBuffer.signalAll();\r\n    } finally {\r\n        this.readBuffer.unLock();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 3,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "read",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "int read() throws IOException\n{\r\n    if (null == this.byteBuffer) {\r\n        throw new IOException(\"this byte buffer for InputStream is null\");\r\n    }\r\n    if (!this.byteBuffer.hasRemaining()) {\r\n        return -1;\r\n    }\r\n    return this.byteBuffer.get() & 0xFF;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "mark",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void mark(int readLimit)\n{\r\n    if (!this.markSupported()) {\r\n        return;\r\n    }\r\n    this.byteBuffer.mark();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "markSupported",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean markSupported()\n{\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "reset",
  "errType" : [ "InvalidMarkException" ],
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void reset() throws IOException\n{\r\n    if (this.isClosed) {\r\n        throw new IOException(\"Closed in InputStream\");\r\n    }\r\n    try {\r\n        this.byteBuffer.reset();\r\n    } catch (InvalidMarkException e) {\r\n        throw new IOException(\"Invalid mark\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "available",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "int available()\n{\r\n    return this.byteBuffer.remaining();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "close",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void close()\n{\r\n    this.byteBuffer.rewind();\r\n    this.byteBuffer = null;\r\n    this.isClosed = true;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn\\auth",
  "methodName" : "getUri",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "URI getUri()\n{\r\n    return uri;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn\\auth",
  "methodName" : "getConf",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Configuration getConf()\n{\r\n    return conf;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "reopen",
  "errType" : [ "InterruptedException" ],
  "containingMethodsNum" : 17,
  "sourceCodeText" : "void reopen(long pos) throws IOException\n{\r\n    long partSize;\r\n    if (pos < 0) {\r\n        throw new EOFException(FSExceptionMessages.NEGATIVE_SEEK);\r\n    } else if (pos > this.fileSize) {\r\n        throw new EOFException(FSExceptionMessages.CANNOT_SEEK_PAST_EOF);\r\n    } else {\r\n        if (pos + this.preReadPartSize > this.fileSize) {\r\n            partSize = this.fileSize - pos;\r\n        } else {\r\n            partSize = this.preReadPartSize;\r\n        }\r\n    }\r\n    this.buffer = null;\r\n    boolean isRandomIO = true;\r\n    if (pos == this.nextPos) {\r\n        isRandomIO = false;\r\n    } else {\r\n        while (this.readBufferQueue.size() != 0) {\r\n            if (this.readBufferQueue.element().getStart() != pos) {\r\n                this.readBufferQueue.poll();\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    this.nextPos = pos + partSize;\r\n    int currentBufferQueueSize = this.readBufferQueue.size();\r\n    long lastByteStart;\r\n    if (currentBufferQueueSize == 0) {\r\n        lastByteStart = pos - partSize;\r\n    } else {\r\n        ReadBuffer[] readBuffers = this.readBufferQueue.toArray(new ReadBuffer[currentBufferQueueSize]);\r\n        lastByteStart = readBuffers[currentBufferQueueSize - 1].getStart();\r\n    }\r\n    int maxLen = this.maxReadPartNumber - currentBufferQueueSize;\r\n    for (int i = 0; i < maxLen && i < (currentBufferQueueSize + 1) * 2; i++) {\r\n        if (lastByteStart + partSize * (i + 1) > this.fileSize) {\r\n            break;\r\n        }\r\n        long byteStart = lastByteStart + partSize * (i + 1);\r\n        long byteEnd = byteStart + partSize - 1;\r\n        if (byteEnd >= this.fileSize) {\r\n            byteEnd = this.fileSize - 1;\r\n        }\r\n        ReadBuffer readBuffer = new ReadBuffer(byteStart, byteEnd);\r\n        if (readBuffer.getBuffer().length == 0) {\r\n            readBuffer.setStatus(ReadBuffer.SUCCESS);\r\n        } else {\r\n            this.readAheadExecutorService.execute(new CosNFileReadTask(this.conf, this.key, this.store, readBuffer));\r\n        }\r\n        this.readBufferQueue.add(readBuffer);\r\n        if (isRandomIO) {\r\n            break;\r\n        }\r\n    }\r\n    ReadBuffer readBuffer = this.readBufferQueue.poll();\r\n    if (null != readBuffer) {\r\n        readBuffer.lock();\r\n        try {\r\n            readBuffer.await(ReadBuffer.INIT);\r\n            if (readBuffer.getStatus() == ReadBuffer.ERROR) {\r\n                this.buffer = null;\r\n            } else {\r\n                this.buffer = readBuffer.getBuffer();\r\n            }\r\n        } catch (InterruptedException e) {\r\n            LOG.warn(\"An interrupted exception occurred \" + \"when waiting a read buffer.\");\r\n        } finally {\r\n            readBuffer.unLock();\r\n        }\r\n    }\r\n    if (null == this.buffer) {\r\n        throw new IOException(\"Null IO stream\");\r\n    }\r\n    this.position = pos;\r\n    this.partRemaining = partSize;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "seek",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void seek(long pos) throws IOException\n{\r\n    if (pos < 0) {\r\n        throw new EOFException(FSExceptionMessages.NEGATIVE_SEEK);\r\n    }\r\n    if (pos > this.fileSize) {\r\n        throw new EOFException(FSExceptionMessages.CANNOT_SEEK_PAST_EOF);\r\n    }\r\n    if (this.position == pos) {\r\n        return;\r\n    }\r\n    if (pos > position && pos < this.position + partRemaining) {\r\n        long len = pos - this.position;\r\n        this.position = pos;\r\n        this.partRemaining -= len;\r\n    } else {\r\n        this.reopen(pos);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getPos",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "long getPos()\n{\r\n    return this.position;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "seekToNewSource",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean seekToNewSource(long targetPos)\n{\r\n    return false;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "read",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "int read() throws IOException\n{\r\n    if (this.closed) {\r\n        throw new IOException(FSExceptionMessages.STREAM_IS_CLOSED);\r\n    }\r\n    if (this.partRemaining <= 0 && this.position < this.fileSize) {\r\n        this.reopen(this.position);\r\n    }\r\n    int byteRead = -1;\r\n    if (this.partRemaining != 0) {\r\n        byteRead = this.buffer[(int) (this.buffer.length - this.partRemaining)] & 0xff;\r\n    }\r\n    if (byteRead >= 0) {\r\n        this.position++;\r\n        this.partRemaining--;\r\n        if (null != this.statistics) {\r\n            this.statistics.incrementBytesRead(byteRead);\r\n        }\r\n    }\r\n    return byteRead;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "read",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "int read(byte[] b, int off, int len) throws IOException\n{\r\n    if (this.closed) {\r\n        throw new IOException(FSExceptionMessages.STREAM_IS_CLOSED);\r\n    }\r\n    if (len == 0) {\r\n        return 0;\r\n    }\r\n    if (off < 0 || len < 0 || len > b.length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    int bytesRead = 0;\r\n    while (position < fileSize && bytesRead < len) {\r\n        if (partRemaining <= 0) {\r\n            reopen(position);\r\n        }\r\n        int bytes = 0;\r\n        for (int i = this.buffer.length - (int) partRemaining; i < this.buffer.length; i++) {\r\n            b[off + bytesRead] = this.buffer[i];\r\n            bytes++;\r\n            bytesRead++;\r\n            if (off + bytesRead >= len) {\r\n                break;\r\n            }\r\n        }\r\n        if (bytes > 0) {\r\n            this.position += bytes;\r\n            this.partRemaining -= bytes;\r\n        } else if (this.partRemaining != 0) {\r\n            throw new IOException(\"Failed to read from stream. Remaining: \" + this.partRemaining);\r\n        }\r\n    }\r\n    if (null != this.statistics && bytesRead > 0) {\r\n        this.statistics.incrementBytesRead(bytesRead);\r\n    }\r\n    return bytesRead == 0 ? -1 : bytesRead;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "available",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "int available() throws IOException\n{\r\n    if (this.closed) {\r\n        throw new IOException(FSExceptionMessages.STREAM_IS_CLOSED);\r\n    }\r\n    long remaining = this.fileSize - this.position;\r\n    if (remaining > Integer.MAX_VALUE) {\r\n        return Integer.MAX_VALUE;\r\n    }\r\n    return (int) remaining;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "close",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void close()\n{\r\n    if (this.closed) {\r\n        return;\r\n    }\r\n    this.closed = true;\r\n    this.buffer = null;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn\\auth",
  "methodName" : "getCredentials",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "COSCredentials getCredentials()\n{\r\n    if (!StringUtils.isNullOrEmpty(this.secretId) && !StringUtils.isNullOrEmpty(this.secretKey)) {\r\n        return new BasicCOSCredentials(this.secretId, this.secretKey);\r\n    }\r\n    return null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn\\auth",
  "methodName" : "refresh",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void refresh()\n{\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getUriDefaultPort",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "int getUriDefaultPort()\n{\r\n    return -1;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getInstance",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "BufferPool getInstance()\n{\r\n    return ourInstance;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "createDir",
  "errType" : null,
  "containingMethodsNum" : 11,
  "sourceCodeText" : "File createDir(String dirPath) throws IOException\n{\r\n    File dir = new File(dirPath);\r\n    if (!dir.exists()) {\r\n        LOG.debug(\"Buffer dir: [{}] does not exists. create it first.\", dirPath);\r\n        if (dir.mkdirs()) {\r\n            if (!dir.setWritable(true) || !dir.setReadable(true) || !dir.setExecutable(true)) {\r\n                LOG.warn(\"Set the buffer dir: [{}]'s permission [writable,\" + \"readable, executable] failed.\", dir.getAbsolutePath());\r\n            }\r\n            LOG.debug(\"Buffer dir: [{}] is created successfully.\", dir.getAbsolutePath());\r\n        } else {\r\n            if (!dir.exists()) {\r\n                throw new IOException(\"buffer dir:\" + dir.getAbsolutePath() + \" is created unsuccessfully\");\r\n            }\r\n        }\r\n    } else {\r\n        LOG.debug(\"buffer dir: {} already exists.\", dirPath);\r\n    }\r\n    return dir;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "initialize",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void initialize(Configuration conf) throws IOException\n{\r\n    if (this.isInitialize.get()) {\r\n        return;\r\n    }\r\n    this.singleBufferSize = conf.getLong(CosNConfigKeys.COSN_BLOCK_SIZE_KEY, CosNConfigKeys.DEFAULT_BLOCK_SIZE);\r\n    if (this.singleBufferSize < Constants.MIN_PART_SIZE || this.singleBufferSize > Constants.MAX_PART_SIZE) {\r\n        String exceptionMsg = String.format(\"The block size of CosN is limited to %d to %d\", Constants.MIN_PART_SIZE, Constants.MAX_PART_SIZE);\r\n        throw new IOException(exceptionMsg);\r\n    }\r\n    long memoryBufferLimit = conf.getLong(CosNConfigKeys.COSN_UPLOAD_BUFFER_SIZE_KEY, CosNConfigKeys.DEFAULT_UPLOAD_BUFFER_SIZE);\r\n    this.diskBufferDir = this.createDir(conf.get(CosNConfigKeys.COSN_BUFFER_DIR_KEY, CosNConfigKeys.DEFAULT_BUFFER_DIR));\r\n    int bufferPoolSize = (int) (memoryBufferLimit / this.singleBufferSize);\r\n    if (0 == bufferPoolSize) {\r\n        throw new IOException(String.format(\"The total size of the buffer [%d] is \" + \"smaller than a single block [%d].\" + \"please consider increase the buffer size \" + \"or decrease the block size\", memoryBufferLimit, this.singleBufferSize));\r\n    }\r\n    this.bufferPool = new LinkedBlockingQueue<>(bufferPoolSize);\r\n    for (int i = 0; i < bufferPoolSize; i++) {\r\n        this.bufferPool.add(ByteBuffer.allocateDirect((int) this.singleBufferSize));\r\n    }\r\n    this.isInitialize.set(true);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "checkInitialize",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void checkInitialize() throws IOException\n{\r\n    if (!this.isInitialize.get()) {\r\n        throw new IOException(\"The buffer pool has not been initialized yet\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getBuffer",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "ByteBufferWrapper getBuffer(int bufferSize) throws IOException\n{\r\n    this.checkInitialize();\r\n    if (bufferSize > 0 && bufferSize <= this.singleBufferSize) {\r\n        ByteBufferWrapper byteBufferWrapper = this.getByteBuffer();\r\n        if (null == byteBufferWrapper) {\r\n            byteBufferWrapper = this.getMappedBuffer();\r\n        }\r\n        return byteBufferWrapper;\r\n    } else {\r\n        String exceptionMsg = String.format(\"Parameter buffer size out of range: 1048576 to %d\", this.singleBufferSize);\r\n        throw new IOException(exceptionMsg);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getByteBuffer",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "ByteBufferWrapper getByteBuffer() throws IOException\n{\r\n    this.checkInitialize();\r\n    ByteBuffer buffer = this.bufferPool.poll();\r\n    return buffer == null ? null : new ByteBufferWrapper(buffer);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getMappedBuffer",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "ByteBufferWrapper getMappedBuffer() throws IOException\n{\r\n    this.checkInitialize();\r\n    File tmpFile = File.createTempFile(Constants.BLOCK_TMP_FILE_PREFIX, Constants.BLOCK_TMP_FILE_SUFFIX, this.diskBufferDir);\r\n    tmpFile.deleteOnExit();\r\n    RandomAccessFile raf = new RandomAccessFile(tmpFile, \"rw\");\r\n    raf.setLength(this.singleBufferSize);\r\n    MappedByteBuffer buf = raf.getChannel().map(FileChannel.MapMode.READ_WRITE, 0, this.singleBufferSize);\r\n    return new ByteBufferWrapper(buf, raf, tmpFile);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "returnBuffer",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void returnBuffer(ByteBufferWrapper byteBufferWrapper) throws InterruptedException, IOException\n{\r\n    if (null == this.bufferPool || null == byteBufferWrapper) {\r\n        return;\r\n    }\r\n    if (byteBufferWrapper.isDiskBuffer()) {\r\n        byteBufferWrapper.close();\r\n    } else {\r\n        ByteBuffer byteBuffer = byteBufferWrapper.getByteBuffer();\r\n        if (null != byteBuffer) {\r\n            byteBuffer.clear();\r\n            LOG.debug(\"Return the buffer to the buffer pool.\");\r\n            if (!this.bufferPool.offer(byteBuffer)) {\r\n                LOG.error(\"Return the buffer to buffer pool failed.\");\r\n            }\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "initCOSClient",
  "errType" : null,
  "containingMethodsNum" : 12,
  "sourceCodeText" : "void initCOSClient(URI uri, Configuration conf) throws IOException\n{\r\n    COSCredentialsProviderList credentialProviderList = CosNUtils.createCosCredentialsProviderSet(uri, conf);\r\n    String region = conf.get(CosNConfigKeys.COSN_REGION_KEY);\r\n    String endpointSuffix = conf.get(CosNConfigKeys.COSN_ENDPOINT_SUFFIX_KEY);\r\n    if (null == region && null == endpointSuffix) {\r\n        String exceptionMsg = String.format(\"config %s and %s at least one\", CosNConfigKeys.COSN_REGION_KEY, CosNConfigKeys.COSN_ENDPOINT_SUFFIX_KEY);\r\n        throw new IOException(exceptionMsg);\r\n    }\r\n    COSCredentials cosCred;\r\n    cosCred = new BasicCOSCredentials(credentialProviderList.getCredentials().getCOSAccessKeyId(), credentialProviderList.getCredentials().getCOSSecretKey());\r\n    boolean useHttps = conf.getBoolean(CosNConfigKeys.COSN_USE_HTTPS_KEY, CosNConfigKeys.DEFAULT_USE_HTTPS);\r\n    ClientConfig config;\r\n    if (null == region) {\r\n        config = new ClientConfig(new Region(\"\"));\r\n        config.setEndpointBuilder(new SuffixEndpointBuilder(endpointSuffix));\r\n    } else {\r\n        config = new ClientConfig(new Region(region));\r\n    }\r\n    if (useHttps) {\r\n        config.setHttpProtocol(HttpProtocol.https);\r\n    }\r\n    config.setUserAgent(conf.get(CosNConfigKeys.USER_AGENT, CosNConfigKeys.DEFAULT_USER_AGENT) + \" For \" + \" Hadoop \" + VersionInfo.getVersion());\r\n    this.maxRetryTimes = conf.getInt(CosNConfigKeys.COSN_MAX_RETRIES_KEY, CosNConfigKeys.DEFAULT_MAX_RETRIES);\r\n    config.setMaxConnectionsCount(conf.getInt(CosNConfigKeys.MAX_CONNECTION_NUM, CosNConfigKeys.DEFAULT_MAX_CONNECTION_NUM));\r\n    this.cosClient = new COSClient(cosCred, config);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "initialize",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void initialize(URI uri, Configuration conf) throws IOException\n{\r\n    try {\r\n        initCOSClient(uri, conf);\r\n        this.bucketName = uri.getHost();\r\n    } catch (Exception e) {\r\n        handleException(e, \"\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "storeFileWithRetry",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void storeFileWithRetry(String key, InputStream inputStream, byte[] md5Hash, long length) throws IOException\n{\r\n    try {\r\n        ObjectMetadata objectMetadata = new ObjectMetadata();\r\n        objectMetadata.setContentMD5(Base64.encodeAsString(md5Hash));\r\n        objectMetadata.setContentLength(length);\r\n        PutObjectRequest putObjectRequest = new PutObjectRequest(bucketName, key, inputStream, objectMetadata);\r\n        PutObjectResult putObjectResult = (PutObjectResult) callCOSClientWithRetry(putObjectRequest);\r\n        LOG.debug(\"Store file successfully. COS key: [{}], ETag: [{}].\", key, putObjectResult.getETag());\r\n    } catch (Exception e) {\r\n        String errMsg = String.format(\"Store file failed. COS key: [%s], \" + \"exception: [%s]\", key, e.toString());\r\n        LOG.error(errMsg);\r\n        handleException(new Exception(errMsg), key);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "storeFile",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void storeFile(String key, File file, byte[] md5Hash) throws IOException\n{\r\n    LOG.info(\"Store file from local path: [{}]. file length: [{}] COS key: \" + \"[{}]\", file.getCanonicalPath(), file.length(), key);\r\n    storeFileWithRetry(key, new BufferedInputStream(new FileInputStream(file)), md5Hash, file.length());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "storeFile",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void storeFile(String key, InputStream inputStream, byte[] md5Hash, long contentLength) throws IOException\n{\r\n    LOG.info(\"Store file from input stream. COS key: [{}], \" + \"length: [{}].\", key, contentLength);\r\n    storeFileWithRetry(key, inputStream, md5Hash, contentLength);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "storeEmptyFile",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void storeEmptyFile(String key) throws IOException\n{\r\n    if (!key.endsWith(CosNFileSystem.PATH_DELIMITER)) {\r\n        key = key + CosNFileSystem.PATH_DELIMITER;\r\n    }\r\n    ObjectMetadata objectMetadata = new ObjectMetadata();\r\n    objectMetadata.setContentLength(0);\r\n    InputStream input = new ByteArrayInputStream(new byte[0]);\r\n    PutObjectRequest putObjectRequest = new PutObjectRequest(bucketName, key, input, objectMetadata);\r\n    try {\r\n        PutObjectResult putObjectResult = (PutObjectResult) callCOSClientWithRetry(putObjectRequest);\r\n        LOG.debug(\"Store empty file successfully. COS key: [{}], ETag: [{}].\", key, putObjectResult.getETag());\r\n    } catch (Exception e) {\r\n        String errMsg = String.format(\"Store empty file failed. \" + \"COS key: [%s], exception: [%s]\", key, e.toString());\r\n        LOG.error(errMsg);\r\n        handleException(new Exception(errMsg), key);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "uploadPart",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "PartETag uploadPart(File file, String key, String uploadId, int partNum) throws IOException\n{\r\n    InputStream inputStream = new FileInputStream(file);\r\n    try {\r\n        return uploadPart(inputStream, key, uploadId, partNum, file.length());\r\n    } finally {\r\n        inputStream.close();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "uploadPart",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "PartETag uploadPart(InputStream inputStream, String key, String uploadId, int partNum, long partSize) throws IOException\n{\r\n    UploadPartRequest uploadPartRequest = new UploadPartRequest();\r\n    uploadPartRequest.setBucketName(this.bucketName);\r\n    uploadPartRequest.setUploadId(uploadId);\r\n    uploadPartRequest.setInputStream(inputStream);\r\n    uploadPartRequest.setPartNumber(partNum);\r\n    uploadPartRequest.setPartSize(partSize);\r\n    uploadPartRequest.setKey(key);\r\n    try {\r\n        UploadPartResult uploadPartResult = (UploadPartResult) callCOSClientWithRetry(uploadPartRequest);\r\n        return uploadPartResult.getPartETag();\r\n    } catch (Exception e) {\r\n        String errMsg = String.format(\"Current thread: [%d], COS key: [%s], \" + \"upload id: [%s], part num: [%d], exception: [%s]\", Thread.currentThread().getId(), key, uploadId, partNum, e.toString());\r\n        handleException(new Exception(errMsg), key);\r\n    }\r\n    return null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "abortMultipartUpload",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void abortMultipartUpload(String key, String uploadId)\n{\r\n    LOG.info(\"Abort the multipart upload. COS key: [{}], upload id: [{}].\", key, uploadId);\r\n    AbortMultipartUploadRequest abortMultipartUploadRequest = new AbortMultipartUploadRequest(bucketName, key, uploadId);\r\n    cosClient.abortMultipartUpload(abortMultipartUploadRequest);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getUploadId",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "String getUploadId(String key)\n{\r\n    if (null == key || key.length() == 0) {\r\n        return \"\";\r\n    }\r\n    LOG.info(\"Initiate a multipart upload. bucket: [{}], COS key: [{}].\", bucketName, key);\r\n    InitiateMultipartUploadRequest initiateMultipartUploadRequest = new InitiateMultipartUploadRequest(bucketName, key);\r\n    InitiateMultipartUploadResult initiateMultipartUploadResult = cosClient.initiateMultipartUpload(initiateMultipartUploadRequest);\r\n    return initiateMultipartUploadResult.getUploadId();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "completeMultipartUpload",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "CompleteMultipartUploadResult completeMultipartUpload(String key, String uploadId, List<PartETag> partETagList)\n{\r\n    Collections.sort(partETagList, new Comparator<PartETag>() {\r\n\r\n        @Override\r\n        public int compare(PartETag o1, PartETag o2) {\r\n            return o1.getPartNumber() - o2.getPartNumber();\r\n        }\r\n    });\r\n    LOG.info(\"Complete the multipart upload. bucket: [{}], COS key: [{}], \" + \"upload id: [{}].\", bucketName, key, uploadId);\r\n    CompleteMultipartUploadRequest completeMultipartUploadRequest = new CompleteMultipartUploadRequest(bucketName, key, uploadId, partETagList);\r\n    return cosClient.completeMultipartUpload(completeMultipartUploadRequest);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "queryObjectMetadata",
  "errType" : [ "CosServiceException" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "FileMetadata queryObjectMetadata(String key) throws IOException\n{\r\n    GetObjectMetadataRequest getObjectMetadataRequest = new GetObjectMetadataRequest(bucketName, key);\r\n    try {\r\n        ObjectMetadata objectMetadata = (ObjectMetadata) callCOSClientWithRetry(getObjectMetadataRequest);\r\n        long mtime = 0;\r\n        if (objectMetadata.getLastModified() != null) {\r\n            mtime = objectMetadata.getLastModified().getTime();\r\n        }\r\n        long fileSize = objectMetadata.getContentLength();\r\n        FileMetadata fileMetadata = new FileMetadata(key, fileSize, mtime, !key.endsWith(CosNFileSystem.PATH_DELIMITER));\r\n        LOG.debug(\"Retrieve file metadata. COS key: [{}], ETag: [{}], \" + \"length: [{}].\", key, objectMetadata.getETag(), objectMetadata.getContentLength());\r\n        return fileMetadata;\r\n    } catch (CosServiceException e) {\r\n        if (e.getStatusCode() != HttpStatus.SC_NOT_FOUND) {\r\n            String errorMsg = String.format(\"Retrieve file metadata file failed. \" + \"COS key: [%s], CosServiceException: [%s].\", key, e.toString());\r\n            LOG.error(errorMsg);\r\n            handleException(new Exception(errorMsg), key);\r\n        }\r\n    }\r\n    return null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "retrieveMetadata",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "FileMetadata retrieveMetadata(String key) throws IOException\n{\r\n    if (key.endsWith(CosNFileSystem.PATH_DELIMITER)) {\r\n        key = key.substring(0, key.length() - 1);\r\n    }\r\n    if (!key.isEmpty()) {\r\n        FileMetadata fileMetadata = queryObjectMetadata(key);\r\n        if (fileMetadata != null) {\r\n            return fileMetadata;\r\n        }\r\n    }\r\n    key = key + CosNFileSystem.PATH_DELIMITER;\r\n    return queryObjectMetadata(key);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "retrieve",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "InputStream retrieve(String key) throws IOException\n{\r\n    LOG.debug(\"Retrieve object key: [{}].\", key);\r\n    GetObjectRequest getObjectRequest = new GetObjectRequest(this.bucketName, key);\r\n    try {\r\n        COSObject cosObject = (COSObject) callCOSClientWithRetry(getObjectRequest);\r\n        return cosObject.getObjectContent();\r\n    } catch (Exception e) {\r\n        String errMsg = String.format(\"Retrieving key: [%s] occurs \" + \"an exception: [%s].\", key, e.toString());\r\n        LOG.error(\"Retrieving COS key: [{}] occurs an exception: [{}].\", key, e);\r\n        handleException(new Exception(errMsg), key);\r\n    }\r\n    return null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "retrieve",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 8,
  "sourceCodeText" : "InputStream retrieve(String key, long byteRangeStart) throws IOException\n{\r\n    try {\r\n        LOG.debug(\"Retrieve COS key:[{}]. range start:[{}].\", key, byteRangeStart);\r\n        long fileSize = getFileLength(key);\r\n        long byteRangeEnd = fileSize - 1;\r\n        GetObjectRequest getObjectRequest = new GetObjectRequest(this.bucketName, key);\r\n        if (byteRangeEnd >= byteRangeStart) {\r\n            getObjectRequest.setRange(byteRangeStart, fileSize - 1);\r\n        }\r\n        COSObject cosObject = (COSObject) callCOSClientWithRetry(getObjectRequest);\r\n        return cosObject.getObjectContent();\r\n    } catch (Exception e) {\r\n        String errMsg = String.format(\"Retrieving COS key: [%s] occurs an exception. \" + \"byte range start: [%s], exception: [%s].\", key, byteRangeStart, e.toString());\r\n        LOG.error(errMsg);\r\n        handleException(new Exception(errMsg), key);\r\n    }\r\n    return null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "retrieveBlock",
  "errType" : [ "CosServiceException", "CosClientException" ],
  "containingMethodsNum" : 9,
  "sourceCodeText" : "InputStream retrieveBlock(String key, long byteRangeStart, long byteRangeEnd) throws IOException\n{\r\n    try {\r\n        GetObjectRequest request = new GetObjectRequest(this.bucketName, key);\r\n        request.setRange(byteRangeStart, byteRangeEnd);\r\n        COSObject cosObject = (COSObject) this.callCOSClientWithRetry(request);\r\n        return cosObject.getObjectContent();\r\n    } catch (CosServiceException e) {\r\n        String errMsg = String.format(\"Retrieving key [%s] with byteRangeStart [%d] occurs \" + \"an CosServiceException: [%s].\", key, byteRangeStart, e.toString());\r\n        LOG.error(errMsg);\r\n        handleException(new Exception(errMsg), key);\r\n        return null;\r\n    } catch (CosClientException e) {\r\n        String errMsg = String.format(\"Retrieving key [%s] with byteRangeStart [%d] \" + \"occurs an exception: [%s].\", key, byteRangeStart, e.toString());\r\n        LOG.error(\"Retrieving COS key: [{}] with byteRangeStart: [{}] \" + \"occurs an exception: [{}].\", key, byteRangeStart, e);\r\n        handleException(new Exception(errMsg), key);\r\n    }\r\n    return null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "list",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "PartialListing list(String prefix, int maxListingLength) throws IOException\n{\r\n    return list(prefix, maxListingLength, null, false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "list",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "PartialListing list(String prefix, int maxListingLength, String priorLastKey, boolean recurse) throws IOException\n{\r\n    return list(prefix, recurse ? null : CosNFileSystem.PATH_DELIMITER, maxListingLength, priorLastKey);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "list",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 32,
  "sourceCodeText" : "PartialListing list(String prefix, String delimiter, int maxListingLength, String priorLastKey) throws IOException\n{\r\n    LOG.debug(\"List objects. prefix: [{}], delimiter: [{}], \" + \"maxListLength: [{}], priorLastKey: [{}].\", prefix, delimiter, maxListingLength, priorLastKey);\r\n    if (!prefix.startsWith(CosNFileSystem.PATH_DELIMITER)) {\r\n        prefix += CosNFileSystem.PATH_DELIMITER;\r\n    }\r\n    ListObjectsRequest listObjectsRequest = new ListObjectsRequest();\r\n    listObjectsRequest.setBucketName(bucketName);\r\n    listObjectsRequest.setPrefix(prefix);\r\n    listObjectsRequest.setDelimiter(delimiter);\r\n    listObjectsRequest.setMarker(priorLastKey);\r\n    listObjectsRequest.setMaxKeys(maxListingLength);\r\n    ObjectListing objectListing = null;\r\n    try {\r\n        objectListing = (ObjectListing) callCOSClientWithRetry(listObjectsRequest);\r\n    } catch (Exception e) {\r\n        String errMsg = String.format(\"prefix: [%s], delimiter: [%s], \" + \"maxListingLength: [%d], priorLastKey: [%s]. \" + \"List objects occur an exception: [%s].\", prefix, (delimiter == null) ? \"\" : delimiter, maxListingLength, priorLastKey, e.toString());\r\n        LOG.error(errMsg);\r\n        handleException(new Exception(errMsg), prefix);\r\n    }\r\n    ArrayList<FileMetadata> fileMetadataArray = new ArrayList<>();\r\n    ArrayList<FileMetadata> commonPrefixArray = new ArrayList<>();\r\n    if (null == objectListing) {\r\n        String errMsg = String.format(\"List the prefix: [%s] failed. \" + \"delimiter: [%s], max listing length:\" + \" [%s], prior last key: [%s]\", prefix, delimiter, maxListingLength, priorLastKey);\r\n        handleException(new Exception(errMsg), prefix);\r\n    }\r\n    List<COSObjectSummary> summaries = objectListing.getObjectSummaries();\r\n    for (COSObjectSummary cosObjectSummary : summaries) {\r\n        String filePath = cosObjectSummary.getKey();\r\n        if (!filePath.startsWith(CosNFileSystem.PATH_DELIMITER)) {\r\n            filePath = CosNFileSystem.PATH_DELIMITER + filePath;\r\n        }\r\n        if (filePath.equals(prefix)) {\r\n            continue;\r\n        }\r\n        long mtime = 0;\r\n        if (cosObjectSummary.getLastModified() != null) {\r\n            mtime = cosObjectSummary.getLastModified().getTime();\r\n        }\r\n        long fileLen = cosObjectSummary.getSize();\r\n        fileMetadataArray.add(new FileMetadata(filePath, fileLen, mtime, true));\r\n    }\r\n    List<String> commonPrefixes = objectListing.getCommonPrefixes();\r\n    for (String commonPrefix : commonPrefixes) {\r\n        if (!commonPrefix.startsWith(CosNFileSystem.PATH_DELIMITER)) {\r\n            commonPrefix = CosNFileSystem.PATH_DELIMITER + commonPrefix;\r\n        }\r\n        commonPrefixArray.add(new FileMetadata(commonPrefix, 0, 0, false));\r\n    }\r\n    FileMetadata[] fileMetadata = new FileMetadata[fileMetadataArray.size()];\r\n    for (int i = 0; i < fileMetadataArray.size(); ++i) {\r\n        fileMetadata[i] = fileMetadataArray.get(i);\r\n    }\r\n    FileMetadata[] commonPrefixMetaData = new FileMetadata[commonPrefixArray.size()];\r\n    for (int i = 0; i < commonPrefixArray.size(); ++i) {\r\n        commonPrefixMetaData[i] = commonPrefixArray.get(i);\r\n    }\r\n    if (!objectListing.isTruncated()) {\r\n        return new PartialListing(null, fileMetadata, commonPrefixMetaData);\r\n    } else {\r\n        return new PartialListing(objectListing.getNextMarker(), fileMetadata, commonPrefixMetaData);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "delete",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void delete(String key) throws IOException\n{\r\n    LOG.debug(\"Delete object key: [{}] from bucket: {}.\", key, this.bucketName);\r\n    try {\r\n        DeleteObjectRequest deleteObjectRequest = new DeleteObjectRequest(bucketName, key);\r\n        callCOSClientWithRetry(deleteObjectRequest);\r\n    } catch (Exception e) {\r\n        String errMsg = String.format(\"Delete key: [%s] occurs an exception: [%s].\", key, e.toString());\r\n        LOG.error(errMsg);\r\n        handleException(new Exception(errMsg), key);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "rename",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void rename(String srcKey, String dstKey) throws IOException\n{\r\n    LOG.debug(\"Rename source key: [{}] to dest key: [{}].\", srcKey, dstKey);\r\n    try {\r\n        CopyObjectRequest copyObjectRequest = new CopyObjectRequest(bucketName, srcKey, bucketName, dstKey);\r\n        callCOSClientWithRetry(copyObjectRequest);\r\n        DeleteObjectRequest deleteObjectRequest = new DeleteObjectRequest(bucketName, srcKey);\r\n        callCOSClientWithRetry(deleteObjectRequest);\r\n    } catch (Exception e) {\r\n        String errMsg = String.format(\"Rename object unsuccessfully. \" + \"source cos key: [%s], dest COS \" + \"key: [%s], exception: [%s]\", srcKey, dstKey, e.toString());\r\n        LOG.error(errMsg);\r\n        handleException(new Exception(errMsg), srcKey);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "copy",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void copy(String srcKey, String dstKey) throws IOException\n{\r\n    LOG.debug(\"Copy source key: [{}] to dest key: [{}].\", srcKey, dstKey);\r\n    try {\r\n        CopyObjectRequest copyObjectRequest = new CopyObjectRequest(bucketName, srcKey, bucketName, dstKey);\r\n        callCOSClientWithRetry(copyObjectRequest);\r\n    } catch (Exception e) {\r\n        String errMsg = String.format(\"Copy object unsuccessfully. \" + \"source COS key: %s, dest COS key: \" + \"%s, exception: %s\", srcKey, dstKey, e.toString());\r\n        LOG.error(errMsg);\r\n        handleException(new Exception(errMsg), srcKey);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "purge",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void purge(String prefix) throws IOException\n{\r\n    throw new IOException(\"purge not supported\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "dump",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void dump() throws IOException\n{\r\n    throw new IOException(\"dump not supported\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "handleException",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void handleException(Exception e, String key) throws IOException\n{\r\n    String cosPath = CosNFileSystem.SCHEME + \"://\" + bucketName + key;\r\n    String exceptInfo = String.format(\"%s : %s\", cosPath, e.toString());\r\n    throw new IOException(exceptInfo);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getFileLength",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "long getFileLength(String key) throws IOException\n{\r\n    LOG.debug(\"Get file length. COS key: {}\", key);\r\n    GetObjectMetadataRequest getObjectMetadataRequest = new GetObjectMetadataRequest(bucketName, key);\r\n    try {\r\n        ObjectMetadata objectMetadata = (ObjectMetadata) callCOSClientWithRetry(getObjectMetadataRequest);\r\n        return objectMetadata.getContentLength();\r\n    } catch (Exception e) {\r\n        String errMsg = String.format(\"Getting file length occurs an exception.\" + \"COS key: %s, exception: %s\", key, e.toString());\r\n        LOG.error(errMsg);\r\n        handleException(new Exception(errMsg), key);\r\n        return 0;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "callCOSClientWithRetry",
  "errType" : [ "CosServiceException", "Exception", "InterruptedException" ],
  "containingMethodsNum" : 19,
  "sourceCodeText" : "Object callCOSClientWithRetry(X request) throws CosServiceException, IOException\n{\r\n    String sdkMethod = \"\";\r\n    int retryIndex = 1;\r\n    while (true) {\r\n        try {\r\n            if (request instanceof PutObjectRequest) {\r\n                sdkMethod = \"putObject\";\r\n                return this.cosClient.putObject((PutObjectRequest) request);\r\n            } else if (request instanceof UploadPartRequest) {\r\n                sdkMethod = \"uploadPart\";\r\n                if (((UploadPartRequest) request).getInputStream() instanceof ByteBufferInputStream) {\r\n                    ((UploadPartRequest) request).getInputStream().mark((int) ((UploadPartRequest) request).getPartSize());\r\n                }\r\n                return this.cosClient.uploadPart((UploadPartRequest) request);\r\n            } else if (request instanceof GetObjectMetadataRequest) {\r\n                sdkMethod = \"queryObjectMeta\";\r\n                return this.cosClient.getObjectMetadata((GetObjectMetadataRequest) request);\r\n            } else if (request instanceof DeleteObjectRequest) {\r\n                sdkMethod = \"deleteObject\";\r\n                this.cosClient.deleteObject((DeleteObjectRequest) request);\r\n                return new Object();\r\n            } else if (request instanceof CopyObjectRequest) {\r\n                sdkMethod = \"copyFile\";\r\n                return this.cosClient.copyObject((CopyObjectRequest) request);\r\n            } else if (request instanceof GetObjectRequest) {\r\n                sdkMethod = \"getObject\";\r\n                return this.cosClient.getObject((GetObjectRequest) request);\r\n            } else if (request instanceof ListObjectsRequest) {\r\n                sdkMethod = \"listObjects\";\r\n                return this.cosClient.listObjects((ListObjectsRequest) request);\r\n            } else {\r\n                throw new IOException(\"no such method\");\r\n            }\r\n        } catch (CosServiceException cse) {\r\n            String errMsg = String.format(\"Call cos sdk failed, \" + \"retryIndex: [%d / %d], \" + \"call method: %s, exception: %s\", retryIndex, this.maxRetryTimes, sdkMethod, cse.toString());\r\n            int statusCode = cse.getStatusCode();\r\n            if (statusCode / 100 == 5) {\r\n                if (retryIndex <= this.maxRetryTimes) {\r\n                    LOG.info(errMsg);\r\n                    long sleepLeast = retryIndex * 300L;\r\n                    long sleepBound = retryIndex * 500L;\r\n                    try {\r\n                        if (request instanceof UploadPartRequest) {\r\n                            if (((UploadPartRequest) request).getInputStream() instanceof ByteBufferInputStream) {\r\n                                ((UploadPartRequest) request).getInputStream().reset();\r\n                            }\r\n                        }\r\n                        Thread.sleep(ThreadLocalRandom.current().nextLong(sleepLeast, sleepBound));\r\n                        ++retryIndex;\r\n                    } catch (InterruptedException e) {\r\n                        throw new IOException(e.toString());\r\n                    }\r\n                } else {\r\n                    LOG.error(errMsg);\r\n                    throw new IOException(errMsg);\r\n                }\r\n            } else {\r\n                throw cse;\r\n            }\r\n        } catch (Exception e) {\r\n            String errMsg = String.format(\"Call cos sdk failed, \" + \"call method: %s, exception: %s\", sdkMethod, e.toString());\r\n            LOG.error(errMsg);\r\n            throw new IOException(errMsg);\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "close",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void close()\n{\r\n    if (null != this.cosClient) {\r\n        this.cosClient.shutdown();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getKey",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getKey()\n{\r\n    return key;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getLength",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "long getLength()\n{\r\n    return length;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getLastModified",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "long getLastModified()\n{\r\n    return lastModified;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "toString",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String toString()\n{\r\n    return \"FileMetadata[\" + key + \", \" + length + \", \" + lastModified + \", \" + \"file?\" + isFile + \"]\";\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "isFile",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean isFile()\n{\r\n    return isFile;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "flush",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void flush() throws IOException\n{\r\n    this.currentBlockOutputStream.flush();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "close",
  "errType" : [ "InterruptedException" ],
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void close() throws IOException\n{\r\n    if (this.closed) {\r\n        return;\r\n    }\r\n    this.currentBlockOutputStream.flush();\r\n    this.currentBlockOutputStream.close();\r\n    LOG.info(\"The output stream has been close, and \" + \"begin to upload the last block: [{}].\", this.currentBlockId);\r\n    this.blockCacheBuffers.add(this.currentBlockBuffer);\r\n    if (this.blockCacheBuffers.size() == 1) {\r\n        byte[] md5Hash = this.digest == null ? null : this.digest.digest();\r\n        store.storeFile(this.key, new ByteBufferInputStream(this.currentBlockBuffer.getByteBuffer()), md5Hash, this.currentBlockBuffer.getByteBuffer().remaining());\r\n    } else {\r\n        PartETag partETag = null;\r\n        if (this.blockWritten > 0) {\r\n            LOG.info(\"Upload the last part..., blockId: [{}], written bytes: [{}]\", this.currentBlockId, this.blockWritten);\r\n            partETag = store.uploadPart(new ByteBufferInputStream(currentBlockBuffer.getByteBuffer()), key, uploadId, currentBlockId + 1, currentBlockBuffer.getByteBuffer().remaining());\r\n        }\r\n        final List<PartETag> futurePartETagList = this.waitForFinishPartUploads();\r\n        if (null == futurePartETagList) {\r\n            throw new IOException(\"Failed to multipart upload to cos, abort it.\");\r\n        }\r\n        List<PartETag> tmpPartEtagList = new LinkedList<>(futurePartETagList);\r\n        if (null != partETag) {\r\n            tmpPartEtagList.add(partETag);\r\n        }\r\n        store.completeMultipartUpload(this.key, this.uploadId, tmpPartEtagList);\r\n    }\r\n    try {\r\n        BufferPool.getInstance().returnBuffer(this.currentBlockBuffer);\r\n    } catch (InterruptedException e) {\r\n        LOG.error(\"An exception occurred \" + \"while returning the buffer to the buffer pool.\", e);\r\n    }\r\n    LOG.info(\"The outputStream for key: [{}] has been uploaded.\", key);\r\n    this.blockWritten = 0;\r\n    this.closed = true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "waitForFinishPartUploads",
  "errType" : [ "InterruptedException", "ExecutionException" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "List<PartETag> waitForFinishPartUploads() throws IOException\n{\r\n    try {\r\n        LOG.info(\"Wait for all parts to finish their uploading.\");\r\n        return Futures.allAsList(this.etagList).get();\r\n    } catch (InterruptedException e) {\r\n        LOG.error(\"Interrupt the part upload.\", e);\r\n        return null;\r\n    } catch (ExecutionException e) {\r\n        LOG.error(\"Cancelling futures.\");\r\n        for (ListenableFuture<PartETag> future : this.etagList) {\r\n            future.cancel(true);\r\n        }\r\n        (store).abortMultipartUpload(this.key, this.uploadId);\r\n        LOG.error(\"Multipart upload with id: [{}] to COS key: [{}]\", this.uploadId, this.key, e);\r\n        throw new IOException(\"Multipart upload with id: \" + this.uploadId + \" to \" + this.key, e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "uploadPart",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 11,
  "sourceCodeText" : "void uploadPart() throws IOException\n{\r\n    this.currentBlockOutputStream.flush();\r\n    this.currentBlockOutputStream.close();\r\n    this.blockCacheBuffers.add(this.currentBlockBuffer);\r\n    if (this.currentBlockId == 0) {\r\n        uploadId = (store).getUploadId(key);\r\n    }\r\n    ListenableFuture<PartETag> partETagListenableFuture = this.executorService.submit(new Callable<PartETag>() {\r\n\r\n        private final ByteBufferWrapper buf = currentBlockBuffer;\r\n\r\n        private final String localKey = key;\r\n\r\n        private final String localUploadId = uploadId;\r\n\r\n        private final int blockId = currentBlockId;\r\n\r\n        @Override\r\n        public PartETag call() throws Exception {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"{} is uploading a part.\", Thread.currentThread().getName());\r\n            }\r\n            PartETag partETag = (store).uploadPart(new ByteBufferInputStream(this.buf.getByteBuffer()), this.localKey, this.localUploadId, this.blockId + 1, this.buf.getByteBuffer().remaining());\r\n            BufferPool.getInstance().returnBuffer(this.buf);\r\n            return partETag;\r\n        }\r\n    });\r\n    this.etagList.add(partETagListenableFuture);\r\n    try {\r\n        this.currentBlockBuffer = BufferPool.getInstance().getBuffer((int) this.blockSize);\r\n    } catch (IOException e) {\r\n        String errMsg = String.format(\"Getting a buffer [size:%d] from \" + \"the buffer pool failed.\", this.blockSize);\r\n        throw new IOException(errMsg, e);\r\n    }\r\n    this.currentBlockId++;\r\n    if (null != this.digest) {\r\n        this.digest.reset();\r\n        this.currentBlockOutputStream = new DigestOutputStream(new ByteBufferOutputStream(this.currentBlockBuffer.getByteBuffer()), this.digest);\r\n    } else {\r\n        this.currentBlockOutputStream = new ByteBufferOutputStream(this.currentBlockBuffer.getByteBuffer());\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "write",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void write(byte[] b, int off, int len) throws IOException\n{\r\n    if (this.closed) {\r\n        throw new IOException(\"block stream has been closed.\");\r\n    }\r\n    while (len > 0) {\r\n        long writeBytes;\r\n        if (this.blockWritten + len > this.blockSize) {\r\n            writeBytes = this.blockSize - this.blockWritten;\r\n        } else {\r\n            writeBytes = len;\r\n        }\r\n        this.currentBlockOutputStream.write(b, off, (int) writeBytes);\r\n        this.blockWritten += writeBytes;\r\n        if (this.blockWritten >= this.blockSize) {\r\n            this.uploadPart();\r\n            this.blockWritten = 0;\r\n        }\r\n        len -= writeBytes;\r\n        off += writeBytes;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "write",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void write(byte[] b) throws IOException\n{\r\n    this.write(b, 0, b.length);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "write",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void write(int b) throws IOException\n{\r\n    if (this.closed) {\r\n        throw new IOException(\"block stream has been closed.\");\r\n    }\r\n    byte[] singleBytes = new byte[1];\r\n    singleBytes[0] = (byte) b;\r\n    this.currentBlockOutputStream.write(singleBytes, 0, 1);\r\n    this.blockWritten += 1;\r\n    if (this.blockWritten >= this.blockSize) {\r\n        this.uploadPart();\r\n        this.blockWritten = 0;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getByteBuffer",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "ByteBuffer getByteBuffer()\n{\r\n    return this.byteBuffer;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "isDiskBuffer",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean isDiskBuffer()\n{\r\n    return this.file != null && this.randomAccessFile != null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "munmap",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void munmap(MappedByteBuffer buffer)\n{\r\n    if (CleanerUtil.UNMAP_SUPPORTED) {\r\n        try {\r\n            CleanerUtil.getCleaner().freeBuffer(buffer);\r\n        } catch (IOException e) {\r\n            LOG.warn(\"Failed to unmap the buffer\", e);\r\n        }\r\n    } else {\r\n        LOG.trace(CleanerUtil.UNMAP_NOT_SUPPORTED_REASON);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "close",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void close() throws IOException\n{\r\n    if (null != this.byteBuffer) {\r\n        this.byteBuffer.clear();\r\n    }\r\n    IOException exception = null;\r\n    try {\r\n        if (null != randomAccessFile) {\r\n            this.randomAccessFile.close();\r\n        }\r\n    } catch (IOException e) {\r\n        LOG.error(\"Close the random access file occurs an exception.\", e);\r\n        exception = e;\r\n    }\r\n    if (this.byteBuffer instanceof MappedByteBuffer) {\r\n        munmap((MappedByteBuffer) this.byteBuffer);\r\n    }\r\n    if (null != this.file && this.file.exists()) {\r\n        if (!this.file.delete()) {\r\n            LOG.warn(\"Delete the tmp file: [{}] failed.\", this.file.getAbsolutePath());\r\n        }\r\n    }\r\n    if (null != exception) {\r\n        throw exception;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "createCosCredentialsProviderSet",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "COSCredentialsProviderList createCosCredentialsProviderSet(URI uri, Configuration conf) throws IOException\n{\r\n    COSCredentialsProviderList credentialProviderList = new COSCredentialsProviderList();\r\n    Class<?>[] cosClasses = CosNUtils.loadCosProviderClasses(conf, CosNConfigKeys.COSN_CREDENTIALS_PROVIDER);\r\n    if (0 == cosClasses.length) {\r\n        credentialProviderList.add(new SimpleCredentialsProvider(uri, conf));\r\n        credentialProviderList.add(new EnvironmentVariableCredentialsProvider(uri, conf));\r\n    } else {\r\n        for (Class<?> credClass : cosClasses) {\r\n            credentialProviderList.add(createCOSCredentialProvider(uri, conf, credClass));\r\n        }\r\n    }\r\n    return credentialProviderList;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "loadCosProviderClasses",
  "errType" : [ "RuntimeException" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "Class<?>[] loadCosProviderClasses(Configuration conf, String key, Class<?>... defaultValue) throws IOException\n{\r\n    try {\r\n        return conf.getClasses(key, defaultValue);\r\n    } catch (RuntimeException e) {\r\n        Throwable c = e.getCause() != null ? e.getCause() : e;\r\n        throw new IOException(\"From option \" + key + ' ' + c, c);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "createCOSCredentialProvider",
  "errType" : [ "IllegalAccessException", "InstantiationException", "InvocationTargetException" ],
  "containingMethodsNum" : 15,
  "sourceCodeText" : "COSCredentialsProvider createCOSCredentialProvider(URI uri, Configuration conf, Class<?> credClass) throws IOException\n{\r\n    COSCredentialsProvider credentialsProvider;\r\n    if (!COSCredentialsProvider.class.isAssignableFrom(credClass)) {\r\n        throw new IllegalArgumentException(\"class \" + credClass + \" \" + NOT_COS_CREDENTIAL_PROVIDER);\r\n    }\r\n    if (Modifier.isAbstract(credClass.getModifiers())) {\r\n        throw new IllegalArgumentException(\"class \" + credClass + \" \" + ABSTRACT_CREDENTIAL_PROVIDER);\r\n    }\r\n    LOG.debug(\"Credential Provider class: \" + credClass.getName());\r\n    try {\r\n        Constructor constructor = getConstructor(credClass);\r\n        if (constructor != null) {\r\n            credentialsProvider = (COSCredentialsProvider) constructor.newInstance();\r\n            return credentialsProvider;\r\n        }\r\n        constructor = getConstructor(credClass, Configuration.class);\r\n        if (null != constructor) {\r\n            credentialsProvider = (COSCredentialsProvider) constructor.newInstance(conf);\r\n            return credentialsProvider;\r\n        }\r\n        constructor = getConstructor(credClass, URI.class, Configuration.class);\r\n        if (null != constructor) {\r\n            credentialsProvider = (COSCredentialsProvider) constructor.newInstance(uri, conf);\r\n            return credentialsProvider;\r\n        }\r\n        Method factory = getFactoryMethod(credClass, COSCredentialsProvider.class, \"getInstance\");\r\n        if (null != factory) {\r\n            credentialsProvider = (COSCredentialsProvider) factory.invoke(null);\r\n            return credentialsProvider;\r\n        }\r\n        throw new IllegalArgumentException(\"Not supported constructor or factory method found\");\r\n    } catch (IllegalAccessException e) {\r\n        throw new IOException(credClass.getName() + \" \" + INSTANTIATION_EXCEPTION + \": \" + e, e);\r\n    } catch (InstantiationException e) {\r\n        throw new IOException(credClass.getName() + \" \" + INSTANTIATION_EXCEPTION + \": \" + e, e);\r\n    } catch (InvocationTargetException e) {\r\n        Throwable targetException = e.getTargetException();\r\n        if (targetException == null) {\r\n            targetException = e;\r\n        }\r\n        throw new IOException(credClass.getName() + \" \" + INSTANTIATION_EXCEPTION + \": \" + targetException, targetException);\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getConstructor",
  "errType" : [ "NoSuchMethodException" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "Constructor<?> getConstructor(Class<?> cl, Class<?>... args)\n{\r\n    try {\r\n        Constructor constructor = cl.getDeclaredConstructor(args);\r\n        return Modifier.isPublic(constructor.getModifiers()) ? constructor : null;\r\n    } catch (NoSuchMethodException e) {\r\n        return null;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-cos\\src\\main\\java\\org\\apache\\hadoop\\fs\\cosn",
  "methodName" : "getFactoryMethod",
  "errType" : [ "NoSuchMethodException" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "Method getFactoryMethod(Class<?> cl, Class<?> returnType, String methodName)\n{\r\n    try {\r\n        Method m = cl.getDeclaredMethod(methodName);\r\n        if (Modifier.isPublic(m.getModifiers()) && Modifier.isStatic(m.getModifiers()) && returnType.isAssignableFrom(m.getReturnType())) {\r\n            return m;\r\n        } else {\r\n            return null;\r\n        }\r\n    } catch (NoSuchMethodException e) {\r\n        return null;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
} ]