[ {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "testSerializeMeta",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void testSerializeMeta() throws Exception\n{\r\n    assertEquals(1, ShuffleHandler.deserializeMetaData(ShuffleHandler.serializeMetaData(1)));\r\n    assertEquals(-1, ShuffleHandler.deserializeMetaData(ShuffleHandler.serializeMetaData(-1)));\r\n    assertEquals(8080, ShuffleHandler.deserializeMetaData(ShuffleHandler.serializeMetaData(8080)));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "testShuffleMetrics",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void testShuffleMetrics() throws Exception\n{\r\n    MetricsSystem ms = new MetricsSystemImpl();\r\n    ShuffleHandler sh = new ShuffleHandler(ms);\r\n    ChannelFuture cf = mock(ChannelFuture.class);\r\n    when(cf.isSuccess()).thenReturn(true).thenReturn(false);\r\n    sh.metrics.shuffleConnections.incr();\r\n    sh.metrics.shuffleOutputBytes.incr(1 * MiB);\r\n    sh.metrics.shuffleConnections.incr();\r\n    sh.metrics.shuffleOutputBytes.incr(2 * MiB);\r\n    checkShuffleMetrics(ms, 3 * MiB, 0, 0, 2);\r\n    sh.metrics.operationComplete(cf);\r\n    sh.metrics.operationComplete(cf);\r\n    checkShuffleMetrics(ms, 3 * MiB, 1, 1, 0);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "checkShuffleMetrics",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void checkShuffleMetrics(MetricsSystem ms, long bytes, int failed, int succeeded, int connections)\n{\r\n    MetricsSource source = ms.getSource(\"ShuffleMetrics\");\r\n    MetricsRecordBuilder rb = getMetrics(source);\r\n    assertCounter(\"ShuffleOutputBytes\", bytes, rb);\r\n    assertCounter(\"ShuffleOutputsFailed\", failed, rb);\r\n    assertCounter(\"ShuffleOutputsOK\", succeeded, rb);\r\n    assertGauge(\"ShuffleConnections\", connections, rb);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "testClientClosesConnection",
  "errType" : null,
  "containingMethodsNum" : 26,
  "sourceCodeText" : "void testClientClosesConnection() throws Exception\n{\r\n    final ArrayList<Throwable> failures = new ArrayList<Throwable>(1);\r\n    Configuration conf = new Configuration();\r\n    conf.setInt(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY, 0);\r\n    ShuffleHandler shuffleHandler = new ShuffleHandler() {\r\n\r\n        @Override\r\n        protected Shuffle getShuffle(Configuration conf) {\r\n            return new Shuffle(conf) {\r\n\r\n                @Override\r\n                protected MapOutputInfo getMapOutputInfo(String mapId, int reduce, String jobId, String user) throws IOException {\r\n                    return null;\r\n                }\r\n\r\n                @Override\r\n                protected void populateHeaders(List<String> mapIds, String jobId, String user, int reduce, HttpRequest request, HttpResponse response, boolean keepAliveParam, Map<String, MapOutputInfo> infoMap) throws IOException {\r\n                    super.setResponseHeaders(response, keepAliveParam, 100);\r\n                }\r\n\r\n                @Override\r\n                protected void verifyRequest(String appid, ChannelHandlerContext ctx, HttpRequest request, HttpResponse response, URL requestUri) throws IOException {\r\n                }\r\n\r\n                @Override\r\n                protected ChannelFuture sendMapOutput(ChannelHandlerContext ctx, Channel ch, String user, String mapId, int reduce, MapOutputInfo info) throws IOException {\r\n                    ShuffleHeader header = new ShuffleHeader(\"attempt_12345_1_m_1_0\", 5678, 5678, 1);\r\n                    DataOutputBuffer dob = new DataOutputBuffer();\r\n                    header.write(dob);\r\n                    ch.write(wrappedBuffer(dob.getData(), 0, dob.getLength()));\r\n                    dob = new DataOutputBuffer();\r\n                    for (int i = 0; i < 100000; ++i) {\r\n                        header.write(dob);\r\n                    }\r\n                    return ch.write(wrappedBuffer(dob.getData(), 0, dob.getLength()));\r\n                }\r\n\r\n                @Override\r\n                protected void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {\r\n                    if (failures.size() == 0) {\r\n                        failures.add(new Error());\r\n                        ctx.getChannel().close();\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                protected void sendError(ChannelHandlerContext ctx, String message, HttpResponseStatus status) {\r\n                    if (failures.size() == 0) {\r\n                        failures.add(new Error());\r\n                        ctx.getChannel().close();\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    };\r\n    shuffleHandler.init(conf);\r\n    shuffleHandler.start();\r\n    URL url = new URL(\"http://127.0.0.1:\" + shuffleHandler.getConfig().get(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY) + \"/mapOutput?job=job_12345_1&reduce=1&map=attempt_12345_1_m_1_0\");\r\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\r\n    conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_NAME, ShuffleHeader.DEFAULT_HTTP_HEADER_NAME);\r\n    conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_VERSION, ShuffleHeader.DEFAULT_HTTP_HEADER_VERSION);\r\n    conn.connect();\r\n    DataInputStream input = new DataInputStream(conn.getInputStream());\r\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, conn.getResponseCode());\r\n    Assert.assertEquals(\"close\", conn.getHeaderField(HttpHeader.CONNECTION.asString()));\r\n    ShuffleHeader header = new ShuffleHeader();\r\n    header.readFields(input);\r\n    input.close();\r\n    shuffleHandler.stop();\r\n    Assert.assertTrue(\"sendError called when client closed connection\", failures.size() == 0);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "testKeepAlive",
  "errType" : null,
  "containingMethodsNum" : 47,
  "sourceCodeText" : "void testKeepAlive() throws Exception\n{\r\n    final ArrayList<Throwable> failures = new ArrayList<Throwable>(1);\r\n    Configuration conf = new Configuration();\r\n    conf.setInt(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY, 0);\r\n    conf.setBoolean(ShuffleHandler.SHUFFLE_CONNECTION_KEEP_ALIVE_ENABLED, true);\r\n    conf.setInt(ShuffleHandler.SHUFFLE_CONNECTION_KEEP_ALIVE_TIME_OUT, -100);\r\n    final LastSocketAddress lastSocketAddress = new LastSocketAddress();\r\n    ShuffleHandler shuffleHandler = new ShuffleHandler() {\r\n\r\n        @Override\r\n        protected Shuffle getShuffle(final Configuration conf) {\r\n            return new Shuffle(conf) {\r\n\r\n                @Override\r\n                protected MapOutputInfo getMapOutputInfo(String mapId, int reduce, String jobId, String user) throws IOException {\r\n                    return null;\r\n                }\r\n\r\n                @Override\r\n                protected void verifyRequest(String appid, ChannelHandlerContext ctx, HttpRequest request, HttpResponse response, URL requestUri) throws IOException {\r\n                }\r\n\r\n                @Override\r\n                protected void populateHeaders(List<String> mapIds, String jobId, String user, int reduce, HttpRequest request, HttpResponse response, boolean keepAliveParam, Map<String, MapOutputInfo> infoMap) throws IOException {\r\n                    ShuffleHeader header = new ShuffleHeader(\"attempt_12345_1_m_1_0\", 5678, 5678, 1);\r\n                    DataOutputBuffer dob = new DataOutputBuffer();\r\n                    header.write(dob);\r\n                    dob = new DataOutputBuffer();\r\n                    for (int i = 0; i < 100000; ++i) {\r\n                        header.write(dob);\r\n                    }\r\n                    long contentLength = dob.getLength();\r\n                    if (keepAliveParam) {\r\n                        connectionKeepAliveEnabled = false;\r\n                    }\r\n                    super.setResponseHeaders(response, keepAliveParam, contentLength);\r\n                }\r\n\r\n                @Override\r\n                protected ChannelFuture sendMapOutput(ChannelHandlerContext ctx, Channel ch, String user, String mapId, int reduce, MapOutputInfo info) throws IOException {\r\n                    lastSocketAddress.setAddress(ch.getRemoteAddress());\r\n                    HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);\r\n                    ShuffleHeader header = new ShuffleHeader(\"attempt_12345_1_m_1_0\", 5678, 5678, 1);\r\n                    DataOutputBuffer dob = new DataOutputBuffer();\r\n                    header.write(dob);\r\n                    ch.write(wrappedBuffer(dob.getData(), 0, dob.getLength()));\r\n                    dob = new DataOutputBuffer();\r\n                    for (int i = 0; i < 100000; ++i) {\r\n                        header.write(dob);\r\n                    }\r\n                    return ch.write(wrappedBuffer(dob.getData(), 0, dob.getLength()));\r\n                }\r\n\r\n                @Override\r\n                protected void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {\r\n                    if (failures.size() == 0) {\r\n                        failures.add(new Error());\r\n                        ctx.getChannel().close();\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                protected void sendError(ChannelHandlerContext ctx, String message, HttpResponseStatus status) {\r\n                    if (failures.size() == 0) {\r\n                        failures.add(new Error());\r\n                        ctx.getChannel().close();\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    };\r\n    shuffleHandler.init(conf);\r\n    shuffleHandler.start();\r\n    String shuffleBaseURL = \"http://127.0.0.1:\" + shuffleHandler.getConfig().get(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY);\r\n    URL url = new URL(shuffleBaseURL + \"/mapOutput?job=job_12345_1&reduce=1&\" + \"map=attempt_12345_1_m_1_0\");\r\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\r\n    conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_NAME, ShuffleHeader.DEFAULT_HTTP_HEADER_NAME);\r\n    conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_VERSION, ShuffleHeader.DEFAULT_HTTP_HEADER_VERSION);\r\n    conn.connect();\r\n    DataInputStream input = new DataInputStream(conn.getInputStream());\r\n    Assert.assertEquals(HttpHeader.KEEP_ALIVE.asString(), conn.getHeaderField(HttpHeader.CONNECTION.asString()));\r\n    Assert.assertEquals(\"timeout=1\", conn.getHeaderField(HttpHeader.KEEP_ALIVE.asString()));\r\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, conn.getResponseCode());\r\n    ShuffleHeader header = new ShuffleHeader();\r\n    header.readFields(input);\r\n    byte[] buffer = new byte[1024];\r\n    while (input.read(buffer) != -1) {\r\n    }\r\n    SocketAddress firstAddress = lastSocketAddress.getSocketAddres();\r\n    input.close();\r\n    url = new URL(shuffleBaseURL + \"/mapOutput?job=job_12345_1&reduce=1&\" + \"map=attempt_12345_1_m_1_0&keepAlive=true\");\r\n    conn = (HttpURLConnection) url.openConnection();\r\n    conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_NAME, ShuffleHeader.DEFAULT_HTTP_HEADER_NAME);\r\n    conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_VERSION, ShuffleHeader.DEFAULT_HTTP_HEADER_VERSION);\r\n    conn.connect();\r\n    input = new DataInputStream(conn.getInputStream());\r\n    Assert.assertEquals(HttpHeader.KEEP_ALIVE.asString(), conn.getHeaderField(HttpHeader.CONNECTION.asString()));\r\n    Assert.assertEquals(\"timeout=1\", conn.getHeaderField(HttpHeader.KEEP_ALIVE.asString()));\r\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, conn.getResponseCode());\r\n    header = new ShuffleHeader();\r\n    header.readFields(input);\r\n    input.close();\r\n    SocketAddress secondAddress = lastSocketAddress.getSocketAddres();\r\n    Assert.assertNotNull(\"Initial shuffle address should not be null\", firstAddress);\r\n    Assert.assertNotNull(\"Keep-Alive shuffle address should not be null\", secondAddress);\r\n    Assert.assertEquals(\"Initial shuffle address and keep-alive shuffle \" + \"address should be the same\", firstAddress, secondAddress);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "testSocketKeepAlive",
  "errType" : null,
  "containingMethodsNum" : 17,
  "sourceCodeText" : "void testSocketKeepAlive() throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    conf.setInt(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY, 0);\r\n    conf.setBoolean(ShuffleHandler.SHUFFLE_CONNECTION_KEEP_ALIVE_ENABLED, true);\r\n    conf.setInt(ShuffleHandler.SHUFFLE_CONNECTION_KEEP_ALIVE_TIME_OUT, -100);\r\n    HttpURLConnection conn = null;\r\n    MockShuffleHandler2 shuffleHandler = new MockShuffleHandler2();\r\n    AuxiliaryLocalPathHandler pathHandler = mock(AuxiliaryLocalPathHandler.class);\r\n    when(pathHandler.getLocalPathForRead(anyString())).thenThrow(new DiskChecker.DiskErrorException(\"Test\"));\r\n    shuffleHandler.setAuxiliaryLocalPathHandler(pathHandler);\r\n    try {\r\n        shuffleHandler.init(conf);\r\n        shuffleHandler.start();\r\n        String shuffleBaseURL = \"http://127.0.0.1:\" + shuffleHandler.getConfig().get(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY);\r\n        URL url = new URL(shuffleBaseURL + \"/mapOutput?job=job_12345_1&reduce=1&\" + \"map=attempt_12345_1_m_1_0\");\r\n        conn = (HttpURLConnection) url.openConnection();\r\n        conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_NAME, ShuffleHeader.DEFAULT_HTTP_HEADER_NAME);\r\n        conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_VERSION, ShuffleHeader.DEFAULT_HTTP_HEADER_VERSION);\r\n        conn.connect();\r\n        conn.getInputStream();\r\n        Assert.assertTrue(\"socket should be set KEEP_ALIVE\", shuffleHandler.isSocketKeepAlive());\r\n    } finally {\r\n        if (conn != null) {\r\n            conn.disconnect();\r\n        }\r\n        shuffleHandler.stop();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "testIncompatibleShuffleVersion",
  "errType" : null,
  "containingMethodsNum" : 11,
  "sourceCodeText" : "void testIncompatibleShuffleVersion() throws Exception\n{\r\n    final int failureNum = 3;\r\n    Configuration conf = new Configuration();\r\n    conf.setInt(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY, 0);\r\n    ShuffleHandler shuffleHandler = new ShuffleHandler();\r\n    shuffleHandler.init(conf);\r\n    shuffleHandler.start();\r\n    URL url = new URL(\"http://127.0.0.1:\" + shuffleHandler.getConfig().get(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY) + \"/mapOutput?job=job_12345_1&reduce=1&map=attempt_12345_1_m_1_0\");\r\n    for (int i = 0; i < failureNum; ++i) {\r\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\r\n        conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_NAME, i == 0 ? \"mapreduce\" : \"other\");\r\n        conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_VERSION, i == 1 ? \"1.0.0\" : \"1.0.1\");\r\n        conn.connect();\r\n        Assert.assertEquals(HttpURLConnection.HTTP_BAD_REQUEST, conn.getResponseCode());\r\n    }\r\n    shuffleHandler.stop();\r\n    shuffleHandler.close();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "testMaxConnections",
  "errType" : [ "IOException", "NumberFormatException", "Exception" ],
  "containingMethodsNum" : 29,
  "sourceCodeText" : "void testMaxConnections() throws Exception\n{\r\n    Configuration conf = new Configuration();\r\n    conf.setInt(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY, 0);\r\n    conf.setInt(ShuffleHandler.MAX_SHUFFLE_CONNECTIONS, 3);\r\n    ShuffleHandler shuffleHandler = new ShuffleHandler() {\r\n\r\n        @Override\r\n        protected Shuffle getShuffle(Configuration conf) {\r\n            return new Shuffle(conf) {\r\n\r\n                @Override\r\n                protected MapOutputInfo getMapOutputInfo(String mapId, int reduce, String jobId, String user) throws IOException {\r\n                    return null;\r\n                }\r\n\r\n                @Override\r\n                protected void populateHeaders(List<String> mapIds, String jobId, String user, int reduce, HttpRequest request, HttpResponse response, boolean keepAliveParam, Map<String, MapOutputInfo> infoMap) throws IOException {\r\n                }\r\n\r\n                @Override\r\n                protected void verifyRequest(String appid, ChannelHandlerContext ctx, HttpRequest request, HttpResponse response, URL requestUri) throws IOException {\r\n                }\r\n\r\n                @Override\r\n                protected ChannelFuture sendMapOutput(ChannelHandlerContext ctx, Channel ch, String user, String mapId, int reduce, MapOutputInfo info) throws IOException {\r\n                    ShuffleHeader header = new ShuffleHeader(\"dummy_header\", 5678, 5678, 1);\r\n                    DataOutputBuffer dob = new DataOutputBuffer();\r\n                    header.write(dob);\r\n                    ch.write(wrappedBuffer(dob.getData(), 0, dob.getLength()));\r\n                    dob = new DataOutputBuffer();\r\n                    for (int i = 0; i < 100000; ++i) {\r\n                        header.write(dob);\r\n                    }\r\n                    return ch.write(wrappedBuffer(dob.getData(), 0, dob.getLength()));\r\n                }\r\n            };\r\n        }\r\n    };\r\n    shuffleHandler.init(conf);\r\n    shuffleHandler.start();\r\n    int connAttempts = 3;\r\n    HttpURLConnection[] conns = new HttpURLConnection[connAttempts];\r\n    for (int i = 0; i < connAttempts; i++) {\r\n        String URLstring = \"http://127.0.0.1:\" + shuffleHandler.getConfig().get(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY) + \"/mapOutput?job=job_12345_1&reduce=1&map=attempt_12345_1_m_\" + i + \"_0\";\r\n        URL url = new URL(URLstring);\r\n        conns[i] = (HttpURLConnection) url.openConnection();\r\n        conns[i].setRequestProperty(ShuffleHeader.HTTP_HEADER_NAME, ShuffleHeader.DEFAULT_HTTP_HEADER_NAME);\r\n        conns[i].setRequestProperty(ShuffleHeader.HTTP_HEADER_VERSION, ShuffleHeader.DEFAULT_HTTP_HEADER_VERSION);\r\n    }\r\n    for (int i = 0; i < connAttempts; i++) {\r\n        conns[i].connect();\r\n    }\r\n    conns[0].getInputStream();\r\n    int rc = conns[0].getResponseCode();\r\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, rc);\r\n    conns[1].getInputStream();\r\n    rc = conns[1].getResponseCode();\r\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, rc);\r\n    try {\r\n        rc = conns[2].getResponseCode();\r\n        Assert.assertEquals(\"Expected a too-many-requests response code\", ShuffleHandler.TOO_MANY_REQ_STATUS.getCode(), rc);\r\n        long backoff = Long.valueOf(conns[2].getHeaderField(ShuffleHandler.RETRY_AFTER_HEADER));\r\n        Assert.assertTrue(\"The backoff value cannot be negative.\", backoff > 0);\r\n        conns[2].getInputStream();\r\n        Assert.fail(\"Expected an IOException\");\r\n    } catch (IOException ioe) {\r\n        LOG.info(\"Expected - connection should not be open\");\r\n    } catch (NumberFormatException ne) {\r\n        Assert.fail(\"Expected a numerical value for RETRY_AFTER header field\");\r\n    } catch (Exception e) {\r\n        Assert.fail(\"Expected a IOException\");\r\n    }\r\n    shuffleHandler.stop();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "testMapFileAccess",
  "errType" : [ "EOFException" ],
  "containingMethodsNum" : 31,
  "sourceCodeText" : "void testMapFileAccess() throws IOException\n{\r\n    assumeTrue(NativeIO.isAvailable());\r\n    Configuration conf = new Configuration();\r\n    conf.setInt(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY, 0);\r\n    conf.setInt(ShuffleHandler.MAX_SHUFFLE_CONNECTIONS, 3);\r\n    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION, \"kerberos\");\r\n    UserGroupInformation.setConfiguration(conf);\r\n    conf.set(YarnConfiguration.NM_LOCAL_DIRS, ABS_LOG_DIR.getAbsolutePath());\r\n    ApplicationId appId = ApplicationId.newInstance(12345, 1);\r\n    LOG.info(appId.toString());\r\n    String appAttemptId = \"attempt_12345_1_m_1_0\";\r\n    String user = \"randomUser\";\r\n    String reducerId = \"0\";\r\n    List<File> fileMap = new ArrayList<File>();\r\n    createShuffleHandlerFiles(ABS_LOG_DIR, user, appId.toString(), appAttemptId, conf, fileMap);\r\n    ShuffleHandler shuffleHandler = new ShuffleHandler() {\r\n\r\n        @Override\r\n        protected Shuffle getShuffle(Configuration conf) {\r\n            return new Shuffle(conf) {\r\n\r\n                @Override\r\n                protected void verifyRequest(String appid, ChannelHandlerContext ctx, HttpRequest request, HttpResponse response, URL requestUri) throws IOException {\r\n                }\r\n            };\r\n        }\r\n    };\r\n    AuxiliaryLocalPathHandler pathHandler = new TestAuxiliaryLocalPathHandler();\r\n    shuffleHandler.setAuxiliaryLocalPathHandler(pathHandler);\r\n    shuffleHandler.init(conf);\r\n    try {\r\n        shuffleHandler.start();\r\n        DataOutputBuffer outputBuffer = new DataOutputBuffer();\r\n        outputBuffer.reset();\r\n        Token<JobTokenIdentifier> jt = new Token<JobTokenIdentifier>(\"identifier\".getBytes(), \"password\".getBytes(), new Text(user), new Text(\"shuffleService\"));\r\n        jt.write(outputBuffer);\r\n        shuffleHandler.initializeApplication(new ApplicationInitializationContext(user, appId, ByteBuffer.wrap(outputBuffer.getData(), 0, outputBuffer.getLength())));\r\n        URL url = new URL(\"http://127.0.0.1:\" + shuffleHandler.getConfig().get(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY) + \"/mapOutput?job=job_12345_0001&reduce=\" + reducerId + \"&map=attempt_12345_1_m_1_0\");\r\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\r\n        conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_NAME, ShuffleHeader.DEFAULT_HTTP_HEADER_NAME);\r\n        conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_VERSION, ShuffleHeader.DEFAULT_HTTP_HEADER_VERSION);\r\n        conn.connect();\r\n        byte[] byteArr = new byte[10000];\r\n        try {\r\n            DataInputStream is = new DataInputStream(conn.getInputStream());\r\n            is.readFully(byteArr);\r\n        } catch (EOFException e) {\r\n        }\r\n        FileInputStream is = new FileInputStream(fileMap.get(0));\r\n        String owner = NativeIO.POSIX.getFstat(is.getFD()).getOwner();\r\n        is.close();\r\n        String message = \"Owner '\" + owner + \"' for path \" + fileMap.get(0).getAbsolutePath() + \" did not match expected owner '\" + user + \"'\";\r\n        Assert.assertTrue((new String(byteArr)).contains(message));\r\n    } finally {\r\n        shuffleHandler.stop();\r\n        FileUtil.fullyDelete(ABS_LOG_DIR);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "createShuffleHandlerFiles",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void createShuffleHandlerFiles(File logDir, String user, String appId, String appAttemptId, Configuration conf, List<File> fileMap) throws IOException\n{\r\n    String attemptDir = StringUtils.join(Path.SEPARATOR, new String[] { logDir.getAbsolutePath(), ContainerLocalizer.USERCACHE, user, ContainerLocalizer.APPCACHE, appId, \"output\", appAttemptId });\r\n    File appAttemptDir = new File(attemptDir);\r\n    appAttemptDir.mkdirs();\r\n    System.out.println(appAttemptDir.getAbsolutePath());\r\n    File indexFile = new File(appAttemptDir, \"file.out.index\");\r\n    fileMap.add(indexFile);\r\n    createIndexFile(indexFile, conf);\r\n    File mapOutputFile = new File(appAttemptDir, \"file.out\");\r\n    fileMap.add(mapOutputFile);\r\n    createMapOutputFile(mapOutputFile, conf);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "createMapOutputFile",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void createMapOutputFile(File mapOutputFile, Configuration conf) throws IOException\n{\r\n    FileOutputStream out = new FileOutputStream(mapOutputFile);\r\n    out.write(\"Creating new dummy map output file. Used only for testing\".getBytes());\r\n    out.flush();\r\n    out.close();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "createIndexFile",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void createIndexFile(File indexFile, Configuration conf) throws IOException\n{\r\n    if (indexFile.exists()) {\r\n        System.out.println(\"Deleting existing file\");\r\n        indexFile.delete();\r\n    }\r\n    indexFile.createNewFile();\r\n    FSDataOutputStream output = FileSystem.getLocal(conf).getRaw().append(new Path(indexFile.getAbsolutePath()));\r\n    Checksum crc = new PureJavaCrc32();\r\n    crc.reset();\r\n    CheckedOutputStream chk = new CheckedOutputStream(output, crc);\r\n    String msg = \"Writing new index file. This file will be used only \" + \"for the testing.\";\r\n    chk.write(Arrays.copyOf(msg.getBytes(), MapTask.MAP_OUTPUT_INDEX_RECORD_LENGTH));\r\n    output.writeLong(chk.getChecksum().getValue());\r\n    output.close();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "testRecovery",
  "errType" : null,
  "containingMethodsNum" : 37,
  "sourceCodeText" : "void testRecovery() throws IOException\n{\r\n    final String user = \"someuser\";\r\n    final ApplicationId appId = ApplicationId.newInstance(12345, 1);\r\n    final JobID jobId = JobID.downgrade(TypeConverter.fromYarn(appId));\r\n    final File tmpDir = new File(System.getProperty(\"test.build.data\", System.getProperty(\"java.io.tmpdir\")), TestShuffleHandler.class.getName());\r\n    ShuffleHandler shuffle = new ShuffleHandler();\r\n    AuxiliaryLocalPathHandler pathHandler = new TestAuxiliaryLocalPathHandler();\r\n    shuffle.setAuxiliaryLocalPathHandler(pathHandler);\r\n    Configuration conf = new Configuration();\r\n    conf.setInt(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY, 0);\r\n    conf.setInt(ShuffleHandler.MAX_SHUFFLE_CONNECTIONS, 3);\r\n    conf.set(YarnConfiguration.NM_LOCAL_DIRS, ABS_LOG_DIR.getAbsolutePath());\r\n    shuffle.setRecoveryPath(new Path(tmpDir.toString()));\r\n    tmpDir.mkdirs();\r\n    try {\r\n        shuffle.init(conf);\r\n        shuffle.start();\r\n        DataOutputBuffer outputBuffer = new DataOutputBuffer();\r\n        outputBuffer.reset();\r\n        Token<JobTokenIdentifier> jt = new Token<JobTokenIdentifier>(\"identifier\".getBytes(), \"password\".getBytes(), new Text(user), new Text(\"shuffleService\"));\r\n        jt.write(outputBuffer);\r\n        shuffle.initializeApplication(new ApplicationInitializationContext(user, appId, ByteBuffer.wrap(outputBuffer.getData(), 0, outputBuffer.getLength())));\r\n        int rc = getShuffleResponseCode(shuffle, jt);\r\n        Assert.assertEquals(HttpURLConnection.HTTP_OK, rc);\r\n        shuffle.close();\r\n        shuffle = new ShuffleHandler();\r\n        shuffle.setAuxiliaryLocalPathHandler(pathHandler);\r\n        shuffle.setRecoveryPath(new Path(tmpDir.toString()));\r\n        shuffle.init(conf);\r\n        shuffle.start();\r\n        rc = getShuffleResponseCode(shuffle, jt);\r\n        Assert.assertEquals(HttpURLConnection.HTTP_OK, rc);\r\n        shuffle.stopApplication(new ApplicationTerminationContext(appId));\r\n        rc = getShuffleResponseCode(shuffle, jt);\r\n        Assert.assertEquals(HttpURLConnection.HTTP_UNAUTHORIZED, rc);\r\n        shuffle.close();\r\n        shuffle = new ShuffleHandler();\r\n        shuffle.setRecoveryPath(new Path(tmpDir.toString()));\r\n        shuffle.init(conf);\r\n        shuffle.start();\r\n        rc = getShuffleResponseCode(shuffle, jt);\r\n        Assert.assertEquals(HttpURLConnection.HTTP_UNAUTHORIZED, rc);\r\n    } finally {\r\n        if (shuffle != null) {\r\n            shuffle.close();\r\n        }\r\n        FileUtil.fullyDelete(tmpDir);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "testRecoveryFromOtherVersions",
  "errType" : [ "ServiceStateException" ],
  "containingMethodsNum" : 50,
  "sourceCodeText" : "void testRecoveryFromOtherVersions() throws IOException\n{\r\n    final String user = \"someuser\";\r\n    final ApplicationId appId = ApplicationId.newInstance(12345, 1);\r\n    final File tmpDir = new File(System.getProperty(\"test.build.data\", System.getProperty(\"java.io.tmpdir\")), TestShuffleHandler.class.getName());\r\n    Configuration conf = new Configuration();\r\n    conf.setInt(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY, 0);\r\n    conf.setInt(ShuffleHandler.MAX_SHUFFLE_CONNECTIONS, 3);\r\n    ShuffleHandler shuffle = new ShuffleHandler();\r\n    AuxiliaryLocalPathHandler pathHandler = new TestAuxiliaryLocalPathHandler();\r\n    shuffle.setAuxiliaryLocalPathHandler(pathHandler);\r\n    conf.set(YarnConfiguration.NM_LOCAL_DIRS, ABS_LOG_DIR.getAbsolutePath());\r\n    shuffle.setRecoveryPath(new Path(tmpDir.toString()));\r\n    tmpDir.mkdirs();\r\n    try {\r\n        shuffle.init(conf);\r\n        shuffle.start();\r\n        DataOutputBuffer outputBuffer = new DataOutputBuffer();\r\n        outputBuffer.reset();\r\n        Token<JobTokenIdentifier> jt = new Token<JobTokenIdentifier>(\"identifier\".getBytes(), \"password\".getBytes(), new Text(user), new Text(\"shuffleService\"));\r\n        jt.write(outputBuffer);\r\n        shuffle.initializeApplication(new ApplicationInitializationContext(user, appId, ByteBuffer.wrap(outputBuffer.getData(), 0, outputBuffer.getLength())));\r\n        int rc = getShuffleResponseCode(shuffle, jt);\r\n        Assert.assertEquals(HttpURLConnection.HTTP_OK, rc);\r\n        shuffle.close();\r\n        shuffle = new ShuffleHandler();\r\n        shuffle.setAuxiliaryLocalPathHandler(pathHandler);\r\n        shuffle.setRecoveryPath(new Path(tmpDir.toString()));\r\n        shuffle.init(conf);\r\n        shuffle.start();\r\n        rc = getShuffleResponseCode(shuffle, jt);\r\n        Assert.assertEquals(HttpURLConnection.HTTP_OK, rc);\r\n        Version version = Version.newInstance(1, 0);\r\n        Assert.assertEquals(version, shuffle.getCurrentVersion());\r\n        Version version11 = Version.newInstance(1, 1);\r\n        shuffle.storeVersion(version11);\r\n        Assert.assertEquals(version11, shuffle.loadVersion());\r\n        shuffle.close();\r\n        shuffle = new ShuffleHandler();\r\n        shuffle.setAuxiliaryLocalPathHandler(pathHandler);\r\n        shuffle.setRecoveryPath(new Path(tmpDir.toString()));\r\n        shuffle.init(conf);\r\n        shuffle.start();\r\n        Assert.assertEquals(version, shuffle.loadVersion());\r\n        rc = getShuffleResponseCode(shuffle, jt);\r\n        Assert.assertEquals(HttpURLConnection.HTTP_OK, rc);\r\n        Version version21 = Version.newInstance(2, 1);\r\n        shuffle.storeVersion(version21);\r\n        Assert.assertEquals(version21, shuffle.loadVersion());\r\n        shuffle.close();\r\n        shuffle = new ShuffleHandler();\r\n        shuffle.setAuxiliaryLocalPathHandler(pathHandler);\r\n        shuffle.setRecoveryPath(new Path(tmpDir.toString()));\r\n        shuffle.init(conf);\r\n        try {\r\n            shuffle.start();\r\n            Assert.fail(\"Incompatible version, should expect fail here.\");\r\n        } catch (ServiceStateException e) {\r\n            Assert.assertTrue(\"Exception message mismatch\", e.getMessage().contains(\"Incompatible version for state DB schema:\"));\r\n        }\r\n    } finally {\r\n        if (shuffle != null) {\r\n            shuffle.close();\r\n        }\r\n        FileUtil.fullyDelete(tmpDir);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "getShuffleResponseCode",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "int getShuffleResponseCode(ShuffleHandler shuffle, Token<JobTokenIdentifier> jt) throws IOException\n{\r\n    URL url = new URL(\"http://127.0.0.1:\" + shuffle.getConfig().get(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY) + \"/mapOutput?job=job_12345_0001&reduce=0&map=attempt_12345_1_m_1_0\");\r\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\r\n    String encHash = SecureShuffleUtils.hashFromString(SecureShuffleUtils.buildMsgFrom(url), JobTokenSecretManager.createSecretKey(jt.getPassword()));\r\n    conn.addRequestProperty(SecureShuffleUtils.HTTP_HEADER_URL_HASH, encHash);\r\n    conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_NAME, ShuffleHeader.DEFAULT_HTTP_HEADER_NAME);\r\n    conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_VERSION, ShuffleHeader.DEFAULT_HTTP_HEADER_VERSION);\r\n    conn.connect();\r\n    int rc = conn.getResponseCode();\r\n    conn.disconnect();\r\n    return rc;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "testGetMapOutputInfo",
  "errType" : [ "EOFException" ],
  "containingMethodsNum" : 32,
  "sourceCodeText" : "void testGetMapOutputInfo() throws Exception\n{\r\n    final ArrayList<Throwable> failures = new ArrayList<Throwable>(1);\r\n    Configuration conf = new Configuration();\r\n    conf.setInt(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY, 0);\r\n    conf.setInt(ShuffleHandler.MAX_SHUFFLE_CONNECTIONS, 3);\r\n    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION, \"simple\");\r\n    UserGroupInformation.setConfiguration(conf);\r\n    conf.set(YarnConfiguration.NM_LOCAL_DIRS, ABS_LOG_DIR.getAbsolutePath());\r\n    ApplicationId appId = ApplicationId.newInstance(12345, 1);\r\n    String appAttemptId = \"attempt_12345_1_m_1_0\";\r\n    String user = \"randomUser\";\r\n    String reducerId = \"0\";\r\n    List<File> fileMap = new ArrayList<File>();\r\n    createShuffleHandlerFiles(ABS_LOG_DIR, user, appId.toString(), appAttemptId, conf, fileMap);\r\n    AuxiliaryLocalPathHandler pathHandler = new TestAuxiliaryLocalPathHandler();\r\n    ShuffleHandler shuffleHandler = new ShuffleHandler() {\r\n\r\n        @Override\r\n        protected Shuffle getShuffle(Configuration conf) {\r\n            return new Shuffle(conf) {\r\n\r\n                @Override\r\n                protected void populateHeaders(List<String> mapIds, String outputBaseStr, String user, int reduce, HttpRequest request, HttpResponse response, boolean keepAliveParam, Map<String, MapOutputInfo> infoMap) throws IOException {\r\n                    super.setResponseHeaders(response, keepAliveParam, 100);\r\n                }\r\n\r\n                @Override\r\n                protected void verifyRequest(String appid, ChannelHandlerContext ctx, HttpRequest request, HttpResponse response, URL requestUri) throws IOException {\r\n                }\r\n\r\n                @Override\r\n                protected void sendError(ChannelHandlerContext ctx, String message, HttpResponseStatus status) {\r\n                    if (failures.size() == 0) {\r\n                        failures.add(new Error(message));\r\n                        ctx.getChannel().close();\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                protected ChannelFuture sendMapOutput(ChannelHandlerContext ctx, Channel ch, String user, String mapId, int reduce, MapOutputInfo info) throws IOException {\r\n                    ShuffleHeader header = new ShuffleHeader(\"attempt_12345_1_m_1_0\", 5678, 5678, 1);\r\n                    DataOutputBuffer dob = new DataOutputBuffer();\r\n                    header.write(dob);\r\n                    return ch.write(wrappedBuffer(dob.getData(), 0, dob.getLength()));\r\n                }\r\n            };\r\n        }\r\n    };\r\n    shuffleHandler.setAuxiliaryLocalPathHandler(pathHandler);\r\n    shuffleHandler.init(conf);\r\n    try {\r\n        shuffleHandler.start();\r\n        DataOutputBuffer outputBuffer = new DataOutputBuffer();\r\n        outputBuffer.reset();\r\n        Token<JobTokenIdentifier> jt = new Token<JobTokenIdentifier>(\"identifier\".getBytes(), \"password\".getBytes(), new Text(user), new Text(\"shuffleService\"));\r\n        jt.write(outputBuffer);\r\n        shuffleHandler.initializeApplication(new ApplicationInitializationContext(user, appId, ByteBuffer.wrap(outputBuffer.getData(), 0, outputBuffer.getLength())));\r\n        URL url = new URL(\"http://127.0.0.1:\" + shuffleHandler.getConfig().get(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY) + \"/mapOutput?job=job_12345_0001&reduce=\" + reducerId + \"&map=attempt_12345_1_m_1_0\");\r\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\r\n        conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_NAME, ShuffleHeader.DEFAULT_HTTP_HEADER_NAME);\r\n        conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_VERSION, ShuffleHeader.DEFAULT_HTTP_HEADER_VERSION);\r\n        conn.connect();\r\n        try {\r\n            DataInputStream is = new DataInputStream(conn.getInputStream());\r\n            ShuffleHeader header = new ShuffleHeader();\r\n            header.readFields(is);\r\n            is.close();\r\n        } catch (EOFException e) {\r\n        }\r\n        Assert.assertEquals(\"sendError called due to shuffle error\", 0, failures.size());\r\n    } finally {\r\n        shuffleHandler.stop();\r\n        FileUtil.fullyDelete(ABS_LOG_DIR);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "testSendMapCount",
  "errType" : null,
  "containingMethodsNum" : 24,
  "sourceCodeText" : "void testSendMapCount() throws Exception\n{\r\n    final List<ShuffleHandler.ReduceMapFileCount> listenerList = new ArrayList<ShuffleHandler.ReduceMapFileCount>();\r\n    final ChannelHandlerContext mockCtx = mock(ChannelHandlerContext.class);\r\n    final MessageEvent mockEvt = mock(MessageEvent.class);\r\n    final Channel mockCh = mock(AbstractChannel.class);\r\n    final ChannelPipeline mockPipeline = mock(ChannelPipeline.class);\r\n    final HttpRequest mockHttpRequest = createMockHttpRequest();\r\n    final ChannelFuture mockFuture = createMockChannelFuture(mockCh, listenerList);\r\n    final ShuffleHandler.TimeoutHandler timerHandler = new ShuffleHandler.TimeoutHandler();\r\n    Mockito.doReturn(mockCh).when(mockCtx).getChannel();\r\n    when(mockCh.getPipeline()).thenReturn(mockPipeline);\r\n    when(mockPipeline.get(Mockito.any(String.class))).thenReturn(timerHandler);\r\n    when(mockCtx.getChannel()).thenReturn(mockCh);\r\n    Mockito.doReturn(mockFuture).when(mockCh).write(Mockito.any(Object.class));\r\n    when(mockCh.write(Object.class)).thenReturn(mockFuture);\r\n    Mockito.doReturn(mockCh).when(mockEvt).getChannel();\r\n    when(mockEvt.getChannel()).thenReturn(mockCh);\r\n    Mockito.doReturn(mockHttpRequest).when(mockEvt).getMessage();\r\n    final ShuffleHandler sh = new MockShuffleHandler();\r\n    Configuration conf = new Configuration();\r\n    sh.init(conf);\r\n    sh.start();\r\n    int maxOpenFiles = conf.getInt(ShuffleHandler.SHUFFLE_MAX_SESSION_OPEN_FILES, ShuffleHandler.DEFAULT_SHUFFLE_MAX_SESSION_OPEN_FILES);\r\n    sh.getShuffle(conf).messageReceived(mockCtx, mockEvt);\r\n    assertTrue(\"Number of Open files should not exceed the configured \" + \"value!-Not Expected\", listenerList.size() <= maxOpenFiles);\r\n    while (!listenerList.isEmpty()) {\r\n        listenerList.remove(0).operationComplete(mockFuture);\r\n        assertTrue(\"Number of Open files should not exceed the configured \" + \"value!-Not Expected\", listenerList.size() <= maxOpenFiles);\r\n    }\r\n    sh.close();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "createMockChannelFuture",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "ChannelFuture createMockChannelFuture(Channel mockCh, final List<ShuffleHandler.ReduceMapFileCount> listenerList)\n{\r\n    final ChannelFuture mockFuture = mock(ChannelFuture.class);\r\n    when(mockFuture.getChannel()).thenReturn(mockCh);\r\n    Mockito.doReturn(true).when(mockFuture).isSuccess();\r\n    Mockito.doAnswer(new Answer() {\r\n\r\n        @Override\r\n        public Object answer(InvocationOnMock invocation) throws Throwable {\r\n            if (invocation.getArguments()[0].getClass() == ShuffleHandler.ReduceMapFileCount.class)\r\n                listenerList.add((ShuffleHandler.ReduceMapFileCount) invocation.getArguments()[0]);\r\n            return null;\r\n        }\r\n    }).when(mockFuture).addListener(Mockito.any(ShuffleHandler.ReduceMapFileCount.class));\r\n    return mockFuture;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "createMockHttpRequest",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "HttpRequest createMockHttpRequest()\n{\r\n    HttpRequest mockHttpRequest = mock(HttpRequest.class);\r\n    Mockito.doReturn(HttpMethod.GET).when(mockHttpRequest).getMethod();\r\n    Mockito.doAnswer(new Answer() {\r\n\r\n        @Override\r\n        public Object answer(InvocationOnMock invocation) throws Throwable {\r\n            String uri = \"/mapOutput?job=job_12345_1&reduce=1\";\r\n            for (int i = 0; i < 100; i++) uri = uri.concat(\"&map=attempt_12345_1_m_\" + i + \"_0\");\r\n            return uri;\r\n        }\r\n    }).when(mockHttpRequest).getUri();\r\n    return mockHttpRequest;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "testDoubleClose",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void testDoubleClose() throws Exception\n{\r\n    File absoluteFile = new File(\"target\", TestFadvisedChunkedFile.class.getSimpleName()).getAbsoluteFile();\r\n    absoluteFile.deleteOnExit();\r\n    try {\r\n        try (RandomAccessFile f = new RandomAccessFile(absoluteFile.getAbsolutePath(), \"rw\")) {\r\n            FadvisedChunkedFile af = new FadvisedChunkedFile(f, 0, 5, 2, true, 10, null, \"foo\");\r\n            assertTrue(\"fd not valid\", f.getFD().valid());\r\n            af.close();\r\n            assertFalse(\"fd still valid\", f.getFD().valid());\r\n            af.close();\r\n            assertFalse(\"fd still valid\", f.getFD().valid());\r\n        }\r\n    } finally {\r\n        absoluteFile.delete();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "testCustomShuffleTransfer",
  "errType" : null,
  "containingMethodsNum" : 27,
  "sourceCodeText" : "void testCustomShuffleTransfer() throws IOException\n{\r\n    File absLogDir = new File(\"target\", TestFadvisedFileRegion.class.getSimpleName() + \"LocDir\").getAbsoluteFile();\r\n    String testDirPath = StringUtils.join(Path.SEPARATOR, new String[] { absLogDir.getAbsolutePath(), \"testCustomShuffleTransfer\" });\r\n    File testDir = new File(testDirPath);\r\n    testDir.mkdirs();\r\n    System.out.println(testDir.getAbsolutePath());\r\n    File inFile = new File(testDir, \"fileIn.out\");\r\n    File outFile = new File(testDir, \"fileOut.out\");\r\n    byte[] initBuff = new byte[FILE_SIZE];\r\n    Random rand = new Random();\r\n    rand.nextBytes(initBuff);\r\n    FileOutputStream out = new FileOutputStream(inFile);\r\n    try {\r\n        out.write(initBuff);\r\n    } finally {\r\n        IOUtils.cleanupWithLogger(LOG, out);\r\n    }\r\n    int position = 2 * 1024 * 1024;\r\n    int count = 4 * 1024 * 1024 - 1;\r\n    RandomAccessFile inputFile = null;\r\n    RandomAccessFile targetFile = null;\r\n    WritableByteChannel target = null;\r\n    FadvisedFileRegion fileRegion = null;\r\n    try {\r\n        inputFile = new RandomAccessFile(inFile.getAbsolutePath(), \"r\");\r\n        targetFile = new RandomAccessFile(outFile.getAbsolutePath(), \"rw\");\r\n        target = targetFile.getChannel();\r\n        Assert.assertEquals(FILE_SIZE, inputFile.length());\r\n        fileRegion = new FadvisedFileRegion(inputFile, position, count, false, 0, null, null, 1024, false);\r\n        customShuffleTransferCornerCases(fileRegion, target, count);\r\n        long pos = 0;\r\n        long size;\r\n        while ((size = fileRegion.customShuffleTransfer(target, pos)) > 0) {\r\n            pos += size;\r\n        }\r\n        Assert.assertEquals(count, (int) pos);\r\n        Assert.assertEquals(count, targetFile.length());\r\n    } finally {\r\n        if (fileRegion != null) {\r\n            fileRegion.releaseExternalResources();\r\n        }\r\n        IOUtils.cleanupWithLogger(LOG, target);\r\n        IOUtils.cleanupWithLogger(LOG, targetFile);\r\n        IOUtils.cleanupWithLogger(LOG, inputFile);\r\n    }\r\n    byte[] buff = new byte[FILE_SIZE];\r\n    FileInputStream in = new FileInputStream(outFile);\r\n    try {\r\n        int total = in.read(buff, 0, count);\r\n        Assert.assertEquals(count, total);\r\n        for (int i = 0; i < count; i++) {\r\n            Assert.assertEquals(initBuff[position + i], buff[i]);\r\n        }\r\n    } finally {\r\n        IOUtils.cleanupWithLogger(LOG, in);\r\n    }\r\n    inFile.delete();\r\n    outFile.delete();\r\n    testDir.delete();\r\n    absLogDir.delete();\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 3,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-mapreduce-project\\hadoop-mapreduce-client\\hadoop-mapreduce-client-shuffle\\src\\test\\java\\org\\apache\\hadoop\\mapred",
  "methodName" : "customShuffleTransferCornerCases",
  "errType" : [ "IllegalArgumentException", "Exception", "IllegalArgumentException", "Exception" ],
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void customShuffleTransferCornerCases(FadvisedFileRegion fileRegion, WritableByteChannel target, int count)\n{\r\n    try {\r\n        fileRegion.customShuffleTransfer(target, -1);\r\n        Assert.fail(\"Expected a IllegalArgumentException\");\r\n    } catch (IllegalArgumentException ie) {\r\n        LOG.info(\"Expected - illegal argument is passed.\");\r\n    } catch (Exception e) {\r\n        Assert.fail(\"Expected a IllegalArgumentException\");\r\n    }\r\n    try {\r\n        fileRegion.customShuffleTransfer(target, count + 1);\r\n        Assert.fail(\"Expected a IllegalArgumentException\");\r\n    } catch (IllegalArgumentException ie) {\r\n        LOG.info(\"Expected - illegal argument is passed.\");\r\n    } catch (Exception e) {\r\n        Assert.fail(\"Expected a IllegalArgumentException\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
} ]