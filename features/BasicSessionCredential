[ {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "calculateRequestLimit",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "long calculateRequestLimit(final long targetPos, final long length, final long contentLength, final long readahead)\n{\r\n    return Math.min(contentLength, length < 0 ? contentLength : targetPos + Math.max(readahead, length));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "reopen",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 12,
  "sourceCodeText" : "void reopen(final String reason, final long targetPos, final long length) throws IOException\n{\r\n    long startTime = System.currentTimeMillis();\r\n    long threadId = Thread.currentThread().getId();\r\n    if (wrappedStream != null) {\r\n        closeStream(\"reopen(\" + reason + \")\", contentRangeFinish);\r\n    }\r\n    contentRangeFinish = calculateRequestLimit(targetPos, length, contentLength, readAheadRange);\r\n    try {\r\n        GetObjectRequest request = new GetObjectRequest(bucket, key);\r\n        request.setRangeStart(targetPos);\r\n        request.setRangeEnd(contentRangeFinish);\r\n        if (fs.getSse().isSseCEnable()) {\r\n            request.setSseCHeader(fs.getSse().getSseCHeader());\r\n        }\r\n        wrappedStream = client.getObject(request).getObjectContent();\r\n        contentRangeStart = targetPos;\r\n        if (wrappedStream == null) {\r\n            throw new IOException(\"Null IO stream from reopen of (\" + reason + \") \" + uri);\r\n        }\r\n    } catch (ObsException e) {\r\n        throw translateException(\"Reopen at position \" + targetPos, uri, e);\r\n    }\r\n    this.streamCurrentPos = targetPos;\r\n    long endTime = System.currentTimeMillis();\r\n    LOG.debug(\"reopen({}) for {} range[{}-{}], length={},\" + \" streamPosition={}, nextReadPosition={}, thread={}, \" + \"timeUsedInMilliSec={}\", uri, reason, targetPos, contentRangeFinish, length, streamCurrentPos, nextReadPos, threadId, endTime - startTime);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getPos",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "long getPos()\n{\r\n    return nextReadPos < 0 ? 0 : nextReadPos;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "seek",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void seek(final long targetPos) throws IOException\n{\r\n    checkNotClosed();\r\n    if (targetPos < 0) {\r\n        throw new EOFException(FSExceptionMessages.NEGATIVE_SEEK + \" \" + targetPos);\r\n    }\r\n    if (this.contentLength <= 0) {\r\n        return;\r\n    }\r\n    nextReadPos = targetPos;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "seekQuietly",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void seekQuietly(final long positiveTargetPos)\n{\r\n    try {\r\n        seek(positiveTargetPos);\r\n    } catch (IOException ioe) {\r\n        LOG.debug(\"Ignoring IOE on seek of {} to {}\", uri, positiveTargetPos, ioe);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "seekInStream",
  "errType" : null,
  "containingMethodsNum" : 12,
  "sourceCodeText" : "void seekInStream(final long targetPos) throws IOException\n{\r\n    checkNotClosed();\r\n    if (wrappedStream == null) {\r\n        return;\r\n    }\r\n    long diff = targetPos - streamCurrentPos;\r\n    if (diff > 0) {\r\n        int available = wrappedStream.available();\r\n        long forwardSeekRange = Math.max(readAheadRange, available);\r\n        long remainingInCurrentRequest = remainingInCurrentRequest();\r\n        long forwardSeekLimit = Math.min(remainingInCurrentRequest, forwardSeekRange);\r\n        boolean skipForward = remainingInCurrentRequest > 0 && diff <= forwardSeekLimit;\r\n        if (skipForward) {\r\n            LOG.debug(\"Forward seek on {}, of {} bytes\", uri, diff);\r\n            long skippedOnce = wrappedStream.skip(diff);\r\n            while (diff > 0 && skippedOnce > 0) {\r\n                streamCurrentPos += skippedOnce;\r\n                diff -= skippedOnce;\r\n                incrementBytesRead(skippedOnce);\r\n                skippedOnce = wrappedStream.skip(diff);\r\n            }\r\n            if (streamCurrentPos == targetPos) {\r\n                return;\r\n            } else {\r\n                LOG.info(\"Failed to seek on {} to {}. Current position {}\", uri, targetPos, streamCurrentPos);\r\n            }\r\n        }\r\n    } else if (diff == 0 && remainingInCurrentRequest() > 0) {\r\n        return;\r\n    }\r\n    closeStream(\"seekInStream()\", this.contentRangeFinish);\r\n    streamCurrentPos = targetPos;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "seekToNewSource",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean seekToNewSource(final long targetPos)\n{\r\n    return false;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "lazySeek",
  "errType" : [ "IOException", "InterruptedException" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void lazySeek(final long targetPos, final long len) throws IOException\n{\r\n    for (int i = 0; i < SEEK_RETRY_TIME; i++) {\r\n        try {\r\n            seekInStream(targetPos);\r\n            if (wrappedStream == null) {\r\n                reopen(\"read from new offset\", targetPos, len);\r\n            }\r\n            break;\r\n        } catch (IOException e) {\r\n            if (wrappedStream != null) {\r\n                closeStream(\"lazySeek() seekInStream has exception \", this.contentRangeFinish);\r\n            }\r\n            Throwable cause = e.getCause();\r\n            if (cause instanceof ObsException) {\r\n                ObsException obsException = (ObsException) cause;\r\n                int status = obsException.getResponseCode();\r\n                switch(status) {\r\n                    case OBSCommonUtils.UNAUTHORIZED_CODE:\r\n                    case OBSCommonUtils.FORBIDDEN_CODE:\r\n                    case OBSCommonUtils.NOT_FOUND_CODE:\r\n                    case OBSCommonUtils.GONE_CODE:\r\n                    case OBSCommonUtils.EOF_CODE:\r\n                        throw e;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            LOG.warn(\"IOException occurred in lazySeek, retry: {}\", i, e);\r\n            if (i == SEEK_RETRY_TIME - 1) {\r\n                throw e;\r\n            }\r\n            try {\r\n                Thread.sleep(DELAY_TIME);\r\n            } catch (InterruptedException ie) {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "incrementBytesRead",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void incrementBytesRead(final long bytesRead)\n{\r\n    if (statistics != null && bytesRead > 0) {\r\n        statistics.incrementBytesRead(bytesRead);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "sleepInLock",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void sleepInLock() throws InterruptedException\n{\r\n    long start = System.currentTimeMillis();\r\n    long now = start;\r\n    while (now - start < OBSInputStream.DELAY_TIME) {\r\n        wait(start + OBSInputStream.DELAY_TIME - now);\r\n        now = System.currentTimeMillis();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "read",
  "errType" : [ "EOFException", "EOFException", "IOException", "InterruptedException" ],
  "containingMethodsNum" : 15,
  "sourceCodeText" : "int read() throws IOException\n{\r\n    long startTime = System.currentTimeMillis();\r\n    long threadId = Thread.currentThread().getId();\r\n    checkNotClosed();\r\n    if (this.contentLength == 0 || nextReadPos >= contentLength) {\r\n        return -1;\r\n    }\r\n    int byteRead = -1;\r\n    try {\r\n        lazySeek(nextReadPos, 1);\r\n    } catch (EOFException e) {\r\n        onReadFailure(e, 1);\r\n        return -1;\r\n    }\r\n    IOException exception = null;\r\n    for (int retryTime = 1; retryTime <= READ_RETRY_TIME; retryTime++) {\r\n        try {\r\n            byteRead = wrappedStream.read();\r\n            exception = null;\r\n            break;\r\n        } catch (EOFException e) {\r\n            onReadFailure(e, 1);\r\n            return -1;\r\n        } catch (IOException e) {\r\n            exception = e;\r\n            onReadFailure(e, 1);\r\n            LOG.warn(\"read of [{}] failed, retry time[{}], due to exception[{}]\", uri, retryTime, exception);\r\n            if (retryTime < READ_RETRY_TIME) {\r\n                try {\r\n                    sleepInLock();\r\n                } catch (InterruptedException ie) {\r\n                    LOG.error(\"read of [{}] failed, retry time[{}], due to \" + \"exception[{}]\", uri, retryTime, exception);\r\n                    throw exception;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (exception != null) {\r\n        LOG.error(\"read of [{}] failed, retry time[{}], due to exception[{}]\", uri, READ_RETRY_TIME, exception);\r\n        throw exception;\r\n    }\r\n    if (byteRead >= 0) {\r\n        streamCurrentPos++;\r\n        nextReadPos++;\r\n    }\r\n    if (byteRead >= 0) {\r\n        incrementBytesRead(1);\r\n    }\r\n    long endTime = System.currentTimeMillis();\r\n    LOG.debug(\"read-0arg uri:{}, contentLength:{}, position:{}, readValue:{}, \" + \"thread:{}, timeUsedMilliSec:{}\", uri, contentLength, byteRead >= 0 ? nextReadPos - 1 : nextReadPos, byteRead, threadId, endTime - startTime);\r\n    return byteRead;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 3,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "onReadFailure",
  "errType" : [ "OBSIOException", "InterruptedException" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void onReadFailure(final IOException ioe, final int length) throws IOException\n{\r\n    LOG.debug(\"Got exception while trying to read from stream {}\" + \" trying to recover: \" + ioe, uri);\r\n    int i = 1;\r\n    while (true) {\r\n        try {\r\n            reopen(\"failure recovery\", streamCurrentPos, length);\r\n            return;\r\n        } catch (OBSIOException e) {\r\n            LOG.warn(\"OBSIOException occurred in reopen for failure recovery, \" + \"the {} retry time\", i, e);\r\n            if (i == READ_RETRY_TIME) {\r\n                throw e;\r\n            }\r\n            try {\r\n                Thread.sleep(DELAY_TIME);\r\n            } catch (InterruptedException ie) {\r\n                throw e;\r\n            }\r\n        }\r\n        i++;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "read",
  "errType" : [ "EOFException", "EOFException", "IOException", "InterruptedException" ],
  "containingMethodsNum" : 18,
  "sourceCodeText" : "int read(final ByteBuffer byteBuffer) throws IOException\n{\r\n    long startTime = System.currentTimeMillis();\r\n    long threadId = Thread.currentThread().getId();\r\n    LOG.debug(\"read byteBuffer: {}\", byteBuffer.toString());\r\n    checkNotClosed();\r\n    int len = byteBuffer.remaining();\r\n    if (len == 0) {\r\n        return 0;\r\n    }\r\n    byte[] buf = new byte[len];\r\n    if (this.contentLength == 0 || nextReadPos >= contentLength) {\r\n        return -1;\r\n    }\r\n    try {\r\n        lazySeek(nextReadPos, len);\r\n    } catch (EOFException e) {\r\n        onReadFailure(e, len);\r\n        return -1;\r\n    }\r\n    int bytesRead = 0;\r\n    IOException exception = null;\r\n    for (int retryTime = 1; retryTime <= READ_RETRY_TIME; retryTime++) {\r\n        try {\r\n            bytesRead = tryToReadFromInputStream(wrappedStream, buf, 0, len);\r\n            if (bytesRead == -1) {\r\n                return -1;\r\n            }\r\n            exception = null;\r\n            break;\r\n        } catch (EOFException e) {\r\n            onReadFailure(e, len);\r\n            return -1;\r\n        } catch (IOException e) {\r\n            exception = e;\r\n            onReadFailure(e, len);\r\n            LOG.warn(\"read len[{}] of [{}] failed, retry time[{}], \" + \"due to exception[{}]\", len, uri, retryTime, exception);\r\n            if (retryTime < READ_RETRY_TIME) {\r\n                try {\r\n                    sleepInLock();\r\n                } catch (InterruptedException ie) {\r\n                    LOG.error(\"read len[{}] of [{}] failed, retry time[{}], \" + \"due to exception[{}]\", len, uri, retryTime, exception);\r\n                    throw exception;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (exception != null) {\r\n        LOG.error(\"read len[{}] of [{}] failed, retry time[{}], \" + \"due to exception[{}]\", len, uri, READ_RETRY_TIME, exception);\r\n        throw exception;\r\n    }\r\n    if (bytesRead > 0) {\r\n        streamCurrentPos += bytesRead;\r\n        nextReadPos += bytesRead;\r\n        byteBuffer.put(buf, 0, bytesRead);\r\n    }\r\n    incrementBytesRead(bytesRead);\r\n    long endTime = System.currentTimeMillis();\r\n    LOG.debug(\"Read-ByteBuffer uri:{}, contentLength:{}, destLen:{}, readLen:{}, \" + \"position:{}, thread:{}, timeUsedMilliSec:{}\", uri, contentLength, len, bytesRead, bytesRead >= 0 ? nextReadPos - bytesRead : nextReadPos, threadId, endTime - startTime);\r\n    return bytesRead;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 3,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "tryToReadFromInputStream",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "int tryToReadFromInputStream(final InputStream in, final byte[] buf, final int off, final int len) throws IOException\n{\r\n    int bytesRead = 0;\r\n    while (bytesRead < len) {\r\n        int bytes = in.read(buf, off + bytesRead, len - bytesRead);\r\n        if (bytes == -1) {\r\n            if (bytesRead == 0) {\r\n                return -1;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        bytesRead += bytes;\r\n    }\r\n    return bytesRead;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "read",
  "errType" : [ "EOFException", "EOFException", "IOException", "InterruptedException" ],
  "containingMethodsNum" : 16,
  "sourceCodeText" : "int read(@NotNull final byte[] buf, final int off, final int len) throws IOException\n{\r\n    long startTime = System.currentTimeMillis();\r\n    long threadId = Thread.currentThread().getId();\r\n    checkNotClosed();\r\n    validatePositionedReadArgs(nextReadPos, buf, off, len);\r\n    if (len == 0) {\r\n        return 0;\r\n    }\r\n    if (this.contentLength == 0 || nextReadPos >= contentLength) {\r\n        return -1;\r\n    }\r\n    try {\r\n        lazySeek(nextReadPos, len);\r\n    } catch (EOFException e) {\r\n        onReadFailure(e, len);\r\n        return -1;\r\n    }\r\n    int bytesRead = 0;\r\n    IOException exception = null;\r\n    for (int retryTime = 1; retryTime <= READ_RETRY_TIME; retryTime++) {\r\n        try {\r\n            bytesRead = tryToReadFromInputStream(wrappedStream, buf, off, len);\r\n            if (bytesRead == -1) {\r\n                return -1;\r\n            }\r\n            exception = null;\r\n            break;\r\n        } catch (EOFException e) {\r\n            onReadFailure(e, len);\r\n            return -1;\r\n        } catch (IOException e) {\r\n            exception = e;\r\n            onReadFailure(e, len);\r\n            LOG.warn(\"read offset[{}] len[{}] of [{}] failed, retry time[{}], \" + \"due to exception[{}]\", off, len, uri, retryTime, exception);\r\n            if (retryTime < READ_RETRY_TIME) {\r\n                try {\r\n                    sleepInLock();\r\n                } catch (InterruptedException ie) {\r\n                    LOG.error(\"read offset[{}] len[{}] of [{}] failed, \" + \"retry time[{}], due to exception[{}]\", off, len, uri, retryTime, exception);\r\n                    throw exception;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (exception != null) {\r\n        LOG.error(\"read offset[{}] len[{}] of [{}] failed, retry time[{}], \" + \"due to exception[{}]\", off, len, uri, READ_RETRY_TIME, exception);\r\n        throw exception;\r\n    }\r\n    if (bytesRead > 0) {\r\n        streamCurrentPos += bytesRead;\r\n        nextReadPos += bytesRead;\r\n    }\r\n    incrementBytesRead(bytesRead);\r\n    long endTime = System.currentTimeMillis();\r\n    LOG.debug(\"Read-3args uri:{}, contentLength:{}, destLen:{}, readLen:{}, \" + \"position:{}, thread:{}, timeUsedMilliSec:{}\", uri, contentLength, len, bytesRead, bytesRead >= 0 ? nextReadPos - bytesRead : nextReadPos, threadId, endTime - startTime);\r\n    return bytesRead;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 3,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "checkNotClosed",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void checkNotClosed() throws IOException\n{\r\n    if (closed) {\r\n        throw new IOException(uri + \": \" + FSExceptionMessages.STREAM_IS_CLOSED);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "close",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void close() throws IOException\n{\r\n    if (!closed) {\r\n        closed = true;\r\n        closeStream(\"close() operation\", this.contentRangeFinish);\r\n        super.close();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "closeStream",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void closeStream(final String reason, final long length) throws IOException\n{\r\n    if (wrappedStream != null) {\r\n        try {\r\n            wrappedStream.close();\r\n        } catch (IOException e) {\r\n            LOG.debug(\"When closing {} stream for {}\", uri, reason, e);\r\n            throw e;\r\n        }\r\n        LOG.debug(\"Stream {} : {}; streamPos={}, nextReadPos={},\" + \" request range {}-{} length={}\", uri, reason, streamCurrentPos, nextReadPos, contentRangeStart, contentRangeFinish, length);\r\n        wrappedStream = null;\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "available",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "int available() throws IOException\n{\r\n    checkNotClosed();\r\n    long remaining = remainingInFile();\r\n    if (remaining > Integer.MAX_VALUE) {\r\n        return Integer.MAX_VALUE;\r\n    }\r\n    return (int) remaining;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "remainingInFile",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "long remainingInFile()\n{\r\n    return this.contentLength - this.streamCurrentPos;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "remainingInCurrentRequest",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "long remainingInCurrentRequest()\n{\r\n    return this.contentRangeFinish - this.streamCurrentPos;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "markSupported",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean markSupported()\n{\r\n    return false;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "toString",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String toString()\n{\r\n    synchronized (this) {\r\n        return \"OBSInputStream{\" + uri + \" wrappedStream=\" + (wrappedStream != null ? \"open\" : \"closed\") + \" streamCurrentPos=\" + streamCurrentPos + \" nextReadPos=\" + nextReadPos + \" contentLength=\" + contentLength + \" contentRangeStart=\" + contentRangeStart + \" contentRangeFinish=\" + contentRangeFinish + \" remainingInCurrentRequest=\" + remainingInCurrentRequest() + '}';\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "readFully",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void readFully(final long position, final byte[] buffer, final int offset, final int length) throws IOException\n{\r\n    long startTime = System.currentTimeMillis();\r\n    long threadId = Thread.currentThread().getId();\r\n    checkNotClosed();\r\n    validatePositionedReadArgs(position, buffer, offset, length);\r\n    if (length == 0) {\r\n        return;\r\n    }\r\n    int nread = 0;\r\n    synchronized (this) {\r\n        long oldPos = getPos();\r\n        try {\r\n            seek(position);\r\n            while (nread < length) {\r\n                int nbytes = read(buffer, offset + nread, length - nread);\r\n                if (nbytes < 0) {\r\n                    throw new EOFException(FSExceptionMessages.EOF_IN_READ_FULLY);\r\n                }\r\n                nread += nbytes;\r\n            }\r\n        } finally {\r\n            seekQuietly(oldPos);\r\n        }\r\n    }\r\n    long endTime = System.currentTimeMillis();\r\n    LOG.debug(\"ReadFully uri:{}, contentLength:{}, destLen:{}, readLen:{}, \" + \"position:{}, thread:{}, timeUsedMilliSec:{}\", uri, contentLength, length, nread, position, threadId, endTime - startTime);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "read",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "int read(final long position, final byte[] buffer, final int offset, final int length) throws IOException\n{\r\n    int len = length;\r\n    checkNotClosed();\r\n    validatePositionedReadArgs(position, buffer, offset, len);\r\n    if (position < 0 || position >= contentLength) {\r\n        return -1;\r\n    }\r\n    if ((position + len) > contentLength) {\r\n        len = (int) (contentLength - position);\r\n    }\r\n    if (fs.isReadTransformEnabled()) {\r\n        return super.read(position, buffer, offset, len);\r\n    }\r\n    return randomReadWithNewInputStream(position, buffer, offset, len);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "randomReadWithNewInputStream",
  "errType" : [ "ObsException|IOException", "InterruptedException" ],
  "containingMethodsNum" : 16,
  "sourceCodeText" : "int randomReadWithNewInputStream(final long position, final byte[] buffer, final int offset, final int length) throws IOException\n{\r\n    long startTime = System.currentTimeMillis();\r\n    long threadId = Thread.currentThread().getId();\r\n    int bytesRead = 0;\r\n    InputStream inputStream = null;\r\n    IOException exception = null;\r\n    GetObjectRequest request = new GetObjectRequest(bucket, key);\r\n    request.setRangeStart(position);\r\n    request.setRangeEnd(position + length);\r\n    if (fs.getSse().isSseCEnable()) {\r\n        request.setSseCHeader(fs.getSse().getSseCHeader());\r\n    }\r\n    for (int retryTime = 1; retryTime <= READ_RETRY_TIME; retryTime++) {\r\n        try {\r\n            inputStream = client.getObject(request).getObjectContent();\r\n            if (inputStream == null) {\r\n                break;\r\n            }\r\n            bytesRead = tryToReadFromInputStream(inputStream, buffer, offset, length);\r\n            if (bytesRead == -1) {\r\n                return -1;\r\n            }\r\n            exception = null;\r\n            break;\r\n        } catch (ObsException | IOException e) {\r\n            if (e instanceof ObsException) {\r\n                exception = translateException(\"Read at position \" + position, uri, (ObsException) e);\r\n            } else {\r\n                exception = (IOException) e;\r\n            }\r\n            LOG.warn(\"read position[{}] destLen[{}] offset[{}] readLen[{}] \" + \"of [{}] failed, retry time[{}], due to \" + \"exception[{}] e[{}]\", position, length, offset, bytesRead, uri, retryTime, exception, e);\r\n            if (retryTime < READ_RETRY_TIME) {\r\n                try {\r\n                    Thread.sleep(DELAY_TIME);\r\n                } catch (InterruptedException ie) {\r\n                    LOG.error(\"read position[{}] destLen[{}] offset[{}] \" + \"readLen[{}] of [{}] failed, retry time[{}], \" + \"due to exception[{}] e[{}]\", position, length, offset, bytesRead, uri, retryTime, exception, e);\r\n                    throw exception;\r\n                }\r\n            }\r\n        } finally {\r\n            if (inputStream != null) {\r\n                inputStream.close();\r\n            }\r\n        }\r\n    }\r\n    if (inputStream == null || exception != null) {\r\n        LOG.error(\"read position[{}] destLen[{}] offset[{}] len[{}] failed, \" + \"retry time[{}], due to exception[{}]\", position, length, offset, bytesRead, READ_RETRY_TIME, exception);\r\n        throw new IOException(\"read failed of \" + uri + \", inputStream is \" + (inputStream == null ? \"null\" : \"not null\"), exception);\r\n    }\r\n    long endTime = System.currentTimeMillis();\r\n    LOG.debug(\"Read-4args uri:{}, contentLength:{}, destLen:{}, readLen:{}, \" + \"position:{}, thread:{}, timeUsedMilliSec:{}\", uri, contentLength, length, bytesRead, position, threadId, endTime - startTime);\r\n    return bytesRead;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "setReadahead",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void setReadahead(final Long newReadaheadRange)\n{\r\n    if (newReadaheadRange == null) {\r\n        this.readAheadRange = OBSConstants.DEFAULT_READAHEAD_RANGE;\r\n    } else {\r\n        Preconditions.checkArgument(newReadaheadRange >= 0, \"Negative readahead value\");\r\n        this.readAheadRange = newReadaheadRange;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "newPutRequest",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "PutObjectRequest newPutRequest(final String destKey, final InputStream inputStream, final long length)\n{\r\n    return OBSCommonUtils.newPutObjectRequest(owner, destKey, newObjectMetadata(length), inputStream);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "newPutRequest",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "PutObjectRequest newPutRequest(final String destKey, final File sourceFile)\n{\r\n    int length = (int) sourceFile.length();\r\n    return OBSCommonUtils.newPutObjectRequest(owner, destKey, newObjectMetadata(length), sourceFile);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "writeSuccessful",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void writeSuccessful(final String destKey)\n{\r\n    LOG.debug(\"Finished write to {}\", destKey);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "newObjectMetadata",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "ObjectMetadata newObjectMetadata(final long length)\n{\r\n    return OBSObjectBucketUtils.newObjectMetadata(length);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "initiateMultiPartUpload",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 9,
  "sourceCodeText" : "String initiateMultiPartUpload(final String destKey) throws IOException\n{\r\n    LOG.debug(\"Initiating Multipart upload\");\r\n    final InitiateMultipartUploadRequest initiateMPURequest = new InitiateMultipartUploadRequest(bucket, destKey);\r\n    initiateMPURequest.setAcl(owner.getCannedACL());\r\n    initiateMPURequest.setMetadata(newObjectMetadata(-1));\r\n    if (owner.getSse().isSseCEnable()) {\r\n        initiateMPURequest.setSseCHeader(owner.getSse().getSseCHeader());\r\n    } else if (owner.getSse().isSseKmsEnable()) {\r\n        initiateMPURequest.setSseKmsHeader(owner.getSse().getSseKmsHeader());\r\n    }\r\n    try {\r\n        return obs.initiateMultipartUpload(initiateMPURequest).getUploadId();\r\n    } catch (ObsException ace) {\r\n        throw OBSCommonUtils.translateException(\"Initiate MultiPartUpload\", destKey, ace);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "completeMultipartUpload",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "CompleteMultipartUploadResult completeMultipartUpload(final String destKey, final String uploadId, final List<PartEtag> partETags) throws ObsException\n{\r\n    Preconditions.checkNotNull(uploadId);\r\n    Preconditions.checkNotNull(partETags);\r\n    Preconditions.checkArgument(!partETags.isEmpty(), \"No partitions have been uploaded\");\r\n    LOG.debug(\"Completing multipart upload {} with {} parts\", uploadId, partETags.size());\r\n    return obs.completeMultipartUpload(new CompleteMultipartUploadRequest(bucket, destKey, uploadId, new ArrayList<>(partETags)));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "abortMultipartUpload",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void abortMultipartUpload(final String destKey, final String uploadId) throws ObsException\n{\r\n    LOG.debug(\"Aborting multipart upload {}\", uploadId);\r\n    obs.abortMultipartUpload(new AbortMultipartUploadRequest(bucket, destKey, uploadId));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "newUploadPartRequest",
  "errType" : null,
  "containingMethodsNum" : 13,
  "sourceCodeText" : "UploadPartRequest newUploadPartRequest(final String destKey, final String uploadId, final int partNumber, final int size, final File sourceFile)\n{\r\n    Preconditions.checkNotNull(uploadId);\r\n    Preconditions.checkArgument(sourceFile != null, \"Data source\");\r\n    Preconditions.checkArgument(size > 0, \"Invalid partition size %s\", size);\r\n    Preconditions.checkArgument(partNumber > 0 && partNumber <= PART_NUMBER);\r\n    LOG.debug(\"Creating part upload request for {} #{} size {}\", uploadId, partNumber, size);\r\n    UploadPartRequest request = new UploadPartRequest();\r\n    request.setUploadId(uploadId);\r\n    request.setBucketName(bucket);\r\n    request.setObjectKey(destKey);\r\n    request.setPartSize((long) size);\r\n    request.setPartNumber(partNumber);\r\n    request.setFile(sourceFile);\r\n    if (owner.getSse().isSseCEnable()) {\r\n        request.setSseCHeader(owner.getSse().getSseCHeader());\r\n    }\r\n    return request;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "newUploadPartRequest",
  "errType" : null,
  "containingMethodsNum" : 13,
  "sourceCodeText" : "UploadPartRequest newUploadPartRequest(final String destKey, final String uploadId, final int partNumber, final int size, final InputStream uploadStream)\n{\r\n    Preconditions.checkNotNull(uploadId);\r\n    Preconditions.checkArgument(uploadStream != null, \"Data source\");\r\n    Preconditions.checkArgument(size > 0, \"Invalid partition size %s\", size);\r\n    Preconditions.checkArgument(partNumber > 0 && partNumber <= PART_NUMBER);\r\n    LOG.debug(\"Creating part upload request for {} #{} size {}\", uploadId, partNumber, size);\r\n    UploadPartRequest request = new UploadPartRequest();\r\n    request.setUploadId(uploadId);\r\n    request.setBucketName(bucket);\r\n    request.setObjectKey(destKey);\r\n    request.setPartSize((long) size);\r\n    request.setPartNumber(partNumber);\r\n    request.setInput(uploadStream);\r\n    if (owner.getSse().isSseCEnable()) {\r\n        request.setSseCHeader(owner.getSse().getSseCHeader());\r\n    }\r\n    return request;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "toString",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String toString(final String destKey)\n{\r\n    return \"{bucket=\" + bucket + \", key='\" + destKey + '\\'' + '}';\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "putObject",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "PutObjectResult putObject(final PutObjectRequest putObjectRequest) throws IOException\n{\r\n    try {\r\n        return OBSCommonUtils.putObjectDirect(owner, putObjectRequest);\r\n    } catch (ObsException e) {\r\n        throw OBSCommonUtils.translateException(\"put\", putObjectRequest.getObjectKey(), e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "isSseCEnable",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean isSseCEnable()\n{\r\n    return sseCHeader != null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "isSseKmsEnable",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean isSseKmsEnable()\n{\r\n    return sseKmsHeader != null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getSseCHeader",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "SseCHeader getSseCHeader()\n{\r\n    return sseCHeader;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getSseKmsHeader",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "SseKmsHeader getSseKmsHeader()\n{\r\n    return sseKmsHeader;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getBucketFsStatus",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 5,
  "sourceCodeText" : "boolean getBucketFsStatus(final ObsClient obs, final String bucketName) throws FileNotFoundException, IOException\n{\r\n    try {\r\n        GetBucketFSStatusRequest getBucketFsStatusRequest = new GetBucketFSStatusRequest();\r\n        getBucketFsStatusRequest.setBucketName(bucketName);\r\n        GetBucketFSStatusResult getBucketFsStatusResult = obs.getBucketFSStatus(getBucketFsStatusRequest);\r\n        FSStatusEnum fsStatus = getBucketFsStatusResult.getStatus();\r\n        return fsStatus == FSStatusEnum.ENABLED;\r\n    } catch (ObsException e) {\r\n        LOG.error(e.toString());\r\n        throw translateException(\"getBucketFsStatus\", bucketName, e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "pathToKey",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "String pathToKey(final OBSFileSystem owner, final Path path)\n{\r\n    Path absolutePath = path;\r\n    if (!path.isAbsolute()) {\r\n        absolutePath = new Path(owner.getWorkingDirectory(), path);\r\n    }\r\n    if (absolutePath.toUri().getScheme() != null && absolutePath.toUri().getPath().isEmpty()) {\r\n        return \"\";\r\n    }\r\n    return absolutePath.toUri().getPath().substring(1);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "maybeAddTrailingSlash",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String maybeAddTrailingSlash(final String key)\n{\r\n    if (!StringUtils.isEmpty(key) && !key.endsWith(\"/\")) {\r\n        return key + '/';\r\n    } else {\r\n        return key;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "keyToPath",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Path keyToPath(final String key)\n{\r\n    return new Path(\"/\" + key);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "keyToQualifiedPath",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Path keyToQualifiedPath(final OBSFileSystem owner, final String key)\n{\r\n    return qualify(owner, keyToPath(key));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "qualify",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Path qualify(final OBSFileSystem owner, final Path path)\n{\r\n    return path.makeQualified(owner.getUri(), owner.getWorkingDirectory());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "maybeDeleteBeginningSlash",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "String maybeDeleteBeginningSlash(final String key)\n{\r\n    return !StringUtils.isEmpty(key) && key.startsWith(\"/\") ? key.substring(1) : key;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "maybeAddBeginningSlash",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String maybeAddBeginningSlash(final String key)\n{\r\n    return !StringUtils.isEmpty(key) && !key.startsWith(\"/\") ? \"/\" + key : key;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "translateException",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "IOException translateException(final String operation, final String path, final ObsException exception)\n{\r\n    String message = String.format(\"%s%s: status [%d] - request id [%s] \" + \"- error code [%s] - error message [%s] - trace :%s \", operation, path != null ? \" on \" + path : \"\", exception.getResponseCode(), exception.getErrorRequestId(), exception.getErrorCode(), exception.getErrorMessage(), exception);\r\n    IOException ioe;\r\n    int status = exception.getResponseCode();\r\n    switch(status) {\r\n        case MOVED_PERMANENTLY_CODE:\r\n            message = String.format(\"Received permanent redirect response, \" + \"status [%d] - request id [%s] - \" + \"error code [%s] - message [%s]\", exception.getResponseCode(), exception.getErrorRequestId(), exception.getErrorCode(), exception.getErrorMessage());\r\n            ioe = new OBSIOException(message, exception);\r\n            break;\r\n        case UNAUTHORIZED_CODE:\r\n        case FORBIDDEN_CODE:\r\n            ioe = new AccessDeniedException(path, null, message);\r\n            ioe.initCause(exception);\r\n            break;\r\n        case NOT_FOUND_CODE:\r\n        case GONE_CODE:\r\n            ioe = new FileNotFoundException(message);\r\n            ioe.initCause(exception);\r\n            break;\r\n        case EOF_CODE:\r\n            ioe = new EOFException(message);\r\n            break;\r\n        default:\r\n            ioe = new OBSIOException(message, exception);\r\n            break;\r\n    }\r\n    return ioe;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "blockRootDelete",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void blockRootDelete(final String bucket, final String key) throws InvalidRequestException\n{\r\n    if (key.isEmpty() || \"/\".equals(key)) {\r\n        throw new InvalidRequestException(\"Bucket \" + bucket + \" cannot be deleted\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "deleteObject",
  "errType" : [ "ObsException", "InterruptedException" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void deleteObject(final OBSFileSystem owner, final String key) throws IOException\n{\r\n    blockRootDelete(owner.getBucket(), key);\r\n    ObsException lastException = null;\r\n    for (int retryTime = 1; retryTime <= MAX_RETRY_TIME; retryTime++) {\r\n        try {\r\n            owner.getObsClient().deleteObject(owner.getBucket(), key);\r\n            owner.getSchemeStatistics().incrementWriteOps(1);\r\n            return;\r\n        } catch (ObsException e) {\r\n            lastException = e;\r\n            LOG.warn(\"Delete path failed with [{}], \" + \"retry time [{}] - request id [{}] - \" + \"error code [{}] - error message [{}]\", e.getResponseCode(), retryTime, e.getErrorRequestId(), e.getErrorCode(), e.getErrorMessage());\r\n            if (retryTime < MAX_RETRY_TIME) {\r\n                try {\r\n                    Thread.sleep(DELAY_TIME);\r\n                } catch (InterruptedException ie) {\r\n                    throw translateException(\"delete\", key, e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    throw translateException(String.format(\"retry max times [%s] delete failed\", MAX_RETRY_TIME), key, lastException);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "deleteObjects",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void deleteObjects(final OBSFileSystem owner, final DeleteObjectsRequest deleteRequest) throws IOException\n{\r\n    DeleteObjectsResult result;\r\n    deleteRequest.setQuiet(true);\r\n    try {\r\n        result = owner.getObsClient().deleteObjects(deleteRequest);\r\n        owner.getSchemeStatistics().incrementWriteOps(1);\r\n    } catch (ObsException e) {\r\n        LOG.warn(\"delete objects failed, request [{}], request id [{}] - \" + \"error code [{}] - error message [{}]\", deleteRequest, e.getErrorRequestId(), e.getErrorCode(), e.getErrorMessage());\r\n        for (KeyAndVersion keyAndVersion : deleteRequest.getKeyAndVersionsList()) {\r\n            deleteObject(owner, keyAndVersion.getKey());\r\n        }\r\n        return;\r\n    }\r\n    if (result != null) {\r\n        List<DeleteObjectsResult.ErrorResult> errorResults = result.getErrorResults();\r\n        if (!errorResults.isEmpty()) {\r\n            LOG.warn(\"bulk delete {} objects, {} failed, begin to delete \" + \"one by one.\", deleteRequest.getKeyAndVersionsList().size(), errorResults.size());\r\n            for (DeleteObjectsResult.ErrorResult errorResult : errorResults) {\r\n                deleteObject(owner, errorResult.getObjectKey());\r\n            }\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "newPutObjectRequest",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "PutObjectRequest newPutObjectRequest(final OBSFileSystem owner, final String key, final ObjectMetadata metadata, final File srcfile)\n{\r\n    Preconditions.checkNotNull(srcfile);\r\n    PutObjectRequest putObjectRequest = new PutObjectRequest(owner.getBucket(), key, srcfile);\r\n    putObjectRequest.setAcl(owner.getCannedACL());\r\n    putObjectRequest.setMetadata(metadata);\r\n    if (owner.getSse().isSseCEnable()) {\r\n        putObjectRequest.setSseCHeader(owner.getSse().getSseCHeader());\r\n    } else if (owner.getSse().isSseKmsEnable()) {\r\n        putObjectRequest.setSseKmsHeader(owner.getSse().getSseKmsHeader());\r\n    }\r\n    return putObjectRequest;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "newPutObjectRequest",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "PutObjectRequest newPutObjectRequest(final OBSFileSystem owner, final String key, final ObjectMetadata metadata, final InputStream inputStream)\n{\r\n    Preconditions.checkNotNull(inputStream);\r\n    PutObjectRequest putObjectRequest = new PutObjectRequest(owner.getBucket(), key, inputStream);\r\n    putObjectRequest.setAcl(owner.getCannedACL());\r\n    putObjectRequest.setMetadata(metadata);\r\n    if (owner.getSse().isSseCEnable()) {\r\n        putObjectRequest.setSseCHeader(owner.getSse().getSseCHeader());\r\n    } else if (owner.getSse().isSseKmsEnable()) {\r\n        putObjectRequest.setSseKmsHeader(owner.getSse().getSseKmsHeader());\r\n    }\r\n    return putObjectRequest;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "putObjectDirect",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "PutObjectResult putObjectDirect(final OBSFileSystem owner, final PutObjectRequest putObjectRequest) throws ObsException\n{\r\n    long len;\r\n    if (putObjectRequest.getFile() != null) {\r\n        len = putObjectRequest.getFile().length();\r\n    } else {\r\n        len = putObjectRequest.getMetadata().getContentLength();\r\n    }\r\n    PutObjectResult result = owner.getObsClient().putObject(putObjectRequest);\r\n    owner.getSchemeStatistics().incrementWriteOps(1);\r\n    owner.getSchemeStatistics().incrementBytesWritten(len);\r\n    return result;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "uploadPart",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "UploadPartResult uploadPart(final OBSFileSystem owner, final UploadPartRequest request) throws ObsException\n{\r\n    long len = request.getPartSize();\r\n    UploadPartResult uploadPartResult = owner.getObsClient().uploadPart(request);\r\n    owner.getSchemeStatistics().incrementWriteOps(1);\r\n    owner.getSchemeStatistics().incrementBytesWritten(len);\r\n    return uploadPartResult;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "removeKeys",
  "errType" : null,
  "containingMethodsNum" : 18,
  "sourceCodeText" : "void removeKeys(final OBSFileSystem owner, final List<KeyAndVersion> keysToDelete, final boolean clearKeys, final boolean checkRootDelete) throws IOException\n{\r\n    if (keysToDelete.isEmpty()) {\r\n        return;\r\n    }\r\n    if (checkRootDelete) {\r\n        for (KeyAndVersion keyVersion : keysToDelete) {\r\n            blockRootDelete(owner.getBucket(), keyVersion.getKey());\r\n        }\r\n    }\r\n    if (!owner.isEnableMultiObjectDelete() || keysToDelete.size() < owner.getMultiDeleteThreshold()) {\r\n        for (KeyAndVersion keyVersion : keysToDelete) {\r\n            deleteObject(owner, keyVersion.getKey());\r\n        }\r\n    } else if (keysToDelete.size() <= owner.getMaxEntriesToDelete()) {\r\n        DeleteObjectsRequest deleteObjectsRequest = new DeleteObjectsRequest(owner.getBucket());\r\n        deleteObjectsRequest.setKeyAndVersions(keysToDelete.toArray(new KeyAndVersion[0]));\r\n        deleteObjects(owner, deleteObjectsRequest);\r\n    } else {\r\n        List<KeyAndVersion> keys = new ArrayList<>(owner.getMaxEntriesToDelete());\r\n        for (KeyAndVersion key : keysToDelete) {\r\n            keys.add(key);\r\n            if (keys.size() == owner.getMaxEntriesToDelete()) {\r\n                removeKeys(owner, keys, true, false);\r\n            }\r\n        }\r\n        removeKeys(owner, keys, true, false);\r\n    }\r\n    if (clearKeys) {\r\n        keysToDelete.clear();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "translateException",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "IOException translateException(final String operation, final Path path, final ObsException exception)\n{\r\n    return translateException(operation, path.toString(), exception);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "innerListStatus",
  "errType" : null,
  "containingMethodsNum" : 13,
  "sourceCodeText" : "FileStatus[] innerListStatus(final OBSFileSystem owner, final Path f, final boolean recursive) throws FileNotFoundException, IOException, ObsException\n{\r\n    Path path = qualify(owner, f);\r\n    String key = pathToKey(owner, path);\r\n    List<FileStatus> result;\r\n    final FileStatus fileStatus = owner.getFileStatus(path);\r\n    if (fileStatus.isDirectory()) {\r\n        key = maybeAddTrailingSlash(key);\r\n        String delimiter = recursive ? null : \"/\";\r\n        ListObjectsRequest request = createListObjectsRequest(owner, key, delimiter);\r\n        LOG.debug(\"listStatus: doing listObjects for directory {} - recursive {}\", f, recursive);\r\n        OBSListing.FileStatusListingIterator files = owner.getObsListing().createFileStatusListingIterator(path, request, OBSListing.ACCEPT_ALL, new OBSListing.AcceptAllButSelfAndS3nDirs(path));\r\n        result = new ArrayList<>(files.getBatchSize());\r\n        while (files.hasNext()) {\r\n            result.add(files.next());\r\n        }\r\n        return result.toArray(new FileStatus[0]);\r\n    } else {\r\n        LOG.debug(\"Adding: rd (not a dir): {}\", path);\r\n        FileStatus[] stats = new FileStatus[1];\r\n        stats[0] = fileStatus;\r\n        return stats;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "createListObjectsRequest",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "ListObjectsRequest createListObjectsRequest(final OBSFileSystem owner, final String key, final String delimiter)\n{\r\n    return createListObjectsRequest(owner, key, delimiter, -1);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "createListObjectsRequest",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "ListObjectsRequest createListObjectsRequest(final OBSFileSystem owner, final String key, final String delimiter, final int maxKeyNum)\n{\r\n    ListObjectsRequest request = new ListObjectsRequest();\r\n    request.setBucketName(owner.getBucket());\r\n    if (maxKeyNum > 0 && maxKeyNum < owner.getMaxKeys()) {\r\n        request.setMaxKeys(maxKeyNum);\r\n    } else {\r\n        request.setMaxKeys(owner.getMaxKeys());\r\n    }\r\n    request.setPrefix(key);\r\n    if (delimiter != null) {\r\n        request.setDelimiter(delimiter);\r\n    }\r\n    return request;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "rejectRootDirectoryDelete",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean rejectRootDirectoryDelete(final String bucket, final boolean isEmptyDir, final boolean recursive) throws IOException\n{\r\n    LOG.info(\"obs delete the {} root directory of {}\", bucket, recursive);\r\n    if (isEmptyDir) {\r\n        return true;\r\n    }\r\n    if (recursive) {\r\n        return false;\r\n    } else {\r\n        throw new PathIOException(bucket, \"Cannot delete root path\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "innerMkdirs",
  "errType" : [ "FileNotFoundException", "FileNotFoundException" ],
  "containingMethodsNum" : 14,
  "sourceCodeText" : "boolean innerMkdirs(final OBSFileSystem owner, final Path path) throws IOException, FileAlreadyExistsException, ObsException\n{\r\n    LOG.debug(\"Making directory: {}\", path);\r\n    FileStatus fileStatus;\r\n    try {\r\n        fileStatus = owner.getFileStatus(path);\r\n        if (fileStatus.isDirectory()) {\r\n            return true;\r\n        } else {\r\n            throw new FileAlreadyExistsException(\"Path is a file: \" + path);\r\n        }\r\n    } catch (FileNotFoundException e) {\r\n        Path fPart = path.getParent();\r\n        do {\r\n            try {\r\n                fileStatus = owner.getFileStatus(fPart);\r\n                if (fileStatus.isDirectory()) {\r\n                    break;\r\n                }\r\n                if (fileStatus.isFile()) {\r\n                    throw new FileAlreadyExistsException(String.format(\"Can't make directory for path '%s'\" + \" since it is a file.\", fPart));\r\n                }\r\n            } catch (FileNotFoundException fnfe) {\r\n                LOG.debug(\"file {} not fount, but ignore.\", path);\r\n            }\r\n            fPart = fPart.getParent();\r\n        } while (fPart != null);\r\n        String key = pathToKey(owner, path);\r\n        if (owner.isFsBucket()) {\r\n            OBSPosixBucketUtils.fsCreateFolder(owner, key);\r\n        } else {\r\n            OBSObjectBucketUtils.createFakeDirectory(owner, key);\r\n        }\r\n        return true;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "listObjects",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "ObjectListing listObjects(final OBSFileSystem owner, final ListObjectsRequest request) throws IOException\n{\r\n    if (request.getDelimiter() == null && request.getMarker() == null && owner.isFsBucket() && owner.isObsClientDFSListEnable()) {\r\n        return OBSFsDFSListing.fsDFSListObjects(owner, request);\r\n    }\r\n    return commonListObjects(owner, request);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "commonListObjects",
  "errType" : [ "ObsException", "InterruptedException" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "ObjectListing commonListObjects(final OBSFileSystem owner, final ListObjectsRequest request)\n{\r\n    for (int retryTime = 1; retryTime < MAX_RETRY_TIME; retryTime++) {\r\n        try {\r\n            owner.getSchemeStatistics().incrementReadOps(1);\r\n            return owner.getObsClient().listObjects(request);\r\n        } catch (ObsException e) {\r\n            LOG.warn(\"Failed to commonListObjects for request[{}], retry \" + \"time [{}], due to exception[{}]\", request, retryTime, e);\r\n            try {\r\n                Thread.sleep(DELAY_TIME);\r\n            } catch (InterruptedException ie) {\r\n                LOG.error(\"Failed to commonListObjects for request[{}], \" + \"retry time [{}], due to exception[{}]\", request, retryTime, e);\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    owner.getSchemeStatistics().incrementReadOps(1);\r\n    return owner.getObsClient().listObjects(request);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "continueListObjects",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "ObjectListing continueListObjects(final OBSFileSystem owner, final ObjectListing objects) throws IOException\n{\r\n    if (objects.getDelimiter() == null && owner.isFsBucket() && owner.isObsClientDFSListEnable()) {\r\n        return OBSFsDFSListing.fsDFSContinueListObjects(owner, (OBSFsDFSListing) objects);\r\n    }\r\n    return commonContinueListObjects(owner, objects);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "commonContinueListObjects",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "ObjectListing commonContinueListObjects(final OBSFileSystem owner, final ObjectListing objects)\n{\r\n    String delimiter = objects.getDelimiter();\r\n    int maxKeyNum = objects.getMaxKeys();\r\n    ListObjectsRequest request = new ListObjectsRequest();\r\n    request.setMarker(objects.getNextMarker());\r\n    request.setBucketName(owner.getBucket());\r\n    request.setPrefix(objects.getPrefix());\r\n    if (maxKeyNum > 0 && maxKeyNum < owner.getMaxKeys()) {\r\n        request.setMaxKeys(maxKeyNum);\r\n    } else {\r\n        request.setMaxKeys(owner.getMaxKeys());\r\n    }\r\n    if (delimiter != null) {\r\n        request.setDelimiter(delimiter);\r\n    }\r\n    return commonContinueListObjects(owner, request);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "commonContinueListObjects",
  "errType" : [ "ObsException", "InterruptedException" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "ObjectListing commonContinueListObjects(final OBSFileSystem owner, final ListObjectsRequest request)\n{\r\n    for (int retryTime = 1; retryTime < MAX_RETRY_TIME; retryTime++) {\r\n        try {\r\n            owner.getSchemeStatistics().incrementReadOps(1);\r\n            return owner.getObsClient().listObjects(request);\r\n        } catch (ObsException e) {\r\n            LOG.warn(\"Continue list objects failed for request[{}], retry\" + \" time[{}], due to exception[{}]\", request, retryTime, e);\r\n            try {\r\n                Thread.sleep(DELAY_TIME);\r\n            } catch (InterruptedException ie) {\r\n                LOG.error(\"Continue list objects failed for request[{}], \" + \"retry time[{}], due to exception[{}]\", request, retryTime, e);\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    owner.getSchemeStatistics().incrementReadOps(1);\r\n    return owner.getObsClient().listObjects(request);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "objectRepresentsDirectory",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "boolean objectRepresentsDirectory(final String name, final long size)\n{\r\n    return !name.isEmpty() && name.charAt(name.length() - 1) == '/' && size == 0L;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "dateToLong",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "long dateToLong(final Date date)\n{\r\n    if (date == null) {\r\n        return 0L;\r\n    }\r\n    return date.getTime() / OBSConstants.SEC2MILLISEC_FACTOR * OBSConstants.SEC2MILLISEC_FACTOR;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "isFolderEmpty",
  "errType" : [ "ObsException", "InterruptedException" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "boolean isFolderEmpty(final OBSFileSystem owner, final String key) throws FileNotFoundException, ObsException\n{\r\n    for (int retryTime = 1; retryTime < MAX_RETRY_TIME; retryTime++) {\r\n        try {\r\n            return innerIsFolderEmpty(owner, key);\r\n        } catch (ObsException e) {\r\n            LOG.warn(\"Failed to check empty folder for [{}], retry time [{}], \" + \"exception [{}]\", key, retryTime, e);\r\n            try {\r\n                Thread.sleep(DELAY_TIME);\r\n            } catch (InterruptedException ie) {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    return innerIsFolderEmpty(owner, key);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "isFolderEmpty",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "boolean isFolderEmpty(final String key, final ObjectListing objects)\n{\r\n    int count = objects.getObjects().size();\r\n    if (count >= 2) {\r\n        return false;\r\n    } else if (count == 1 && !objects.getObjects().get(0).getObjectKey().equals(key)) {\r\n        return false;\r\n    }\r\n    count = objects.getCommonPrefixes().size();\r\n    if (count >= 2) {\r\n        return false;\r\n    } else {\r\n        return count != 1 || objects.getCommonPrefixes().get(0).equals(key);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "innerIsFolderEmpty",
  "errType" : null,
  "containingMethodsNum" : 23,
  "sourceCodeText" : "boolean innerIsFolderEmpty(final OBSFileSystem owner, final String key) throws FileNotFoundException, ObsException\n{\r\n    String obsKey = maybeAddTrailingSlash(key);\r\n    ListObjectsRequest request = new ListObjectsRequest();\r\n    request.setBucketName(owner.getBucket());\r\n    request.setPrefix(obsKey);\r\n    request.setDelimiter(\"/\");\r\n    request.setMaxKeys(MAX_KEYS_FOR_CHECK_FOLDER_EMPTY);\r\n    owner.getSchemeStatistics().incrementReadOps(1);\r\n    ObjectListing objects = owner.getObsClient().listObjects(request);\r\n    if (!objects.getCommonPrefixes().isEmpty() || !objects.getObjects().isEmpty()) {\r\n        if (isFolderEmpty(obsKey, objects)) {\r\n            LOG.debug(\"Found empty directory {}\", obsKey);\r\n            return true;\r\n        }\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Found path as directory (with /): {}/{}\", objects.getCommonPrefixes().size(), objects.getObjects().size());\r\n            for (ObsObject summary : objects.getObjects()) {\r\n                LOG.debug(\"Summary: {} {}\", summary.getObjectKey(), summary.getMetadata().getContentLength());\r\n            }\r\n            for (String prefix : objects.getCommonPrefixes()) {\r\n                LOG.debug(\"Prefix: {}\", prefix);\r\n            }\r\n        }\r\n        LOG.debug(\"Found non-empty directory {}\", obsKey);\r\n        return false;\r\n    } else if (obsKey.isEmpty()) {\r\n        LOG.debug(\"Found root directory\");\r\n        return true;\r\n    } else if (owner.isFsBucket()) {\r\n        LOG.debug(\"Found empty directory {}\", obsKey);\r\n        return true;\r\n    }\r\n    LOG.debug(\"Not Found: {}\", obsKey);\r\n    throw new FileNotFoundException(\"No such file or directory: \" + obsKey);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "toLocatedFileStatus",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "LocatedFileStatus toLocatedFileStatus(final OBSFileSystem owner, final FileStatus status) throws IOException\n{\r\n    return new LocatedFileStatus(status, status.isFile() ? owner.getFileBlockLocations(status, 0, status.getLen()) : null);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "newAppendFileRequest",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "WriteFileRequest newAppendFileRequest(final OBSFileSystem owner, final String key, final long recordPosition, final File tmpFile) throws IOException\n{\r\n    Preconditions.checkNotNull(key);\r\n    Preconditions.checkNotNull(tmpFile);\r\n    ObsFSAttribute obsFsAttribute;\r\n    try {\r\n        GetAttributeRequest getAttributeReq = new GetAttributeRequest(owner.getBucket(), key);\r\n        obsFsAttribute = owner.getObsClient().getAttribute(getAttributeReq);\r\n    } catch (ObsException e) {\r\n        throw translateException(\"GetAttributeRequest\", key, e);\r\n    }\r\n    long appendPosition = Math.max(recordPosition, obsFsAttribute.getContentLength());\r\n    if (recordPosition != obsFsAttribute.getContentLength()) {\r\n        LOG.warn(\"append url[{}] position[{}], file contentLength[{}] not\" + \" equal to recordPosition[{}].\", key, appendPosition, obsFsAttribute.getContentLength(), recordPosition);\r\n    }\r\n    WriteFileRequest writeFileReq = new WriteFileRequest(owner.getBucket(), key, tmpFile, appendPosition);\r\n    writeFileReq.setAcl(owner.getCannedACL());\r\n    return writeFileReq;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "newAppendFileRequest",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "WriteFileRequest newAppendFileRequest(final OBSFileSystem owner, final String key, final long recordPosition, final InputStream inputStream) throws IOException\n{\r\n    Preconditions.checkNotNull(key);\r\n    Preconditions.checkNotNull(inputStream);\r\n    ObsFSAttribute obsFsAttribute;\r\n    try {\r\n        GetAttributeRequest getAttributeReq = new GetAttributeRequest(owner.getBucket(), key);\r\n        obsFsAttribute = owner.getObsClient().getAttribute(getAttributeReq);\r\n    } catch (ObsException e) {\r\n        throw translateException(\"GetAttributeRequest\", key, e);\r\n    }\r\n    long appendPosition = Math.max(recordPosition, obsFsAttribute.getContentLength());\r\n    if (recordPosition != obsFsAttribute.getContentLength()) {\r\n        LOG.warn(\"append url[{}] position[{}], file contentLength[{}] not\" + \" equal to recordPosition[{}].\", key, appendPosition, obsFsAttribute.getContentLength(), recordPosition);\r\n    }\r\n    WriteFileRequest writeFileReq = new WriteFileRequest(owner.getBucket(), key, inputStream, appendPosition);\r\n    writeFileReq.setAcl(owner.getCannedACL());\r\n    return writeFileReq;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "appendFile",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void appendFile(final OBSFileSystem owner, final WriteFileRequest appendFileRequest) throws IOException\n{\r\n    long len = 0;\r\n    if (appendFileRequest.getFile() != null) {\r\n        len = appendFileRequest.getFile().length();\r\n    }\r\n    try {\r\n        LOG.debug(\"Append file, key {} position {} size {}\", appendFileRequest.getObjectKey(), appendFileRequest.getPosition(), len);\r\n        owner.getObsClient().writeFile(appendFileRequest);\r\n        owner.getSchemeStatistics().incrementWriteOps(1);\r\n        owner.getSchemeStatistics().incrementBytesWritten(len);\r\n    } catch (ObsException e) {\r\n        throw translateException(\"AppendFile\", appendFileRequest.getObjectKey(), e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "closeAll",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void closeAll(final java.io.Closeable... closeables)\n{\r\n    for (java.io.Closeable c : closeables) {\r\n        if (c != null) {\r\n            try {\r\n                if (LOG != null) {\r\n                    LOG.debug(\"Closing {}\", c);\r\n                }\r\n                c.close();\r\n            } catch (Exception e) {\r\n                if (LOG != null && LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Exception in closing {}\", c, e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "extractException",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "IOException extractException(final String operation, final String path, final ExecutionException ee)\n{\r\n    IOException ioe;\r\n    Throwable cause = ee.getCause();\r\n    if (cause instanceof ObsException) {\r\n        ioe = translateException(operation, path, (ObsException) cause);\r\n    } else if (cause instanceof IOException) {\r\n        ioe = (IOException) cause;\r\n    } else {\r\n        ioe = new IOException(operation + \" failed: \" + cause, cause);\r\n    }\r\n    return ioe;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "createFileStatus",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "OBSFileStatus createFileStatus(final Path keyPath, final ObsObject summary, final long blockSize, final String owner)\n{\r\n    if (objectRepresentsDirectory(summary.getObjectKey(), summary.getMetadata().getContentLength())) {\r\n        return new OBSFileStatus(keyPath, owner);\r\n    } else {\r\n        return new OBSFileStatus(summary.getMetadata().getContentLength(), dateToLong(summary.getMetadata().getLastModified()), keyPath, blockSize, owner);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getOBSAccessKeys",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "OBSLoginHelper.Login getOBSAccessKeys(final URI name, final Configuration conf) throws IOException\n{\r\n    OBSLoginHelper.Login login = OBSLoginHelper.extractLoginDetailsWithWarnings(name);\r\n    Configuration c = ProviderUtils.excludeIncompatibleCredentialProviders(conf, OBSFileSystem.class);\r\n    String accessKey = getPassword(c, OBSConstants.ACCESS_KEY, login.getUser());\r\n    String secretKey = getPassword(c, OBSConstants.SECRET_KEY, login.getPassword());\r\n    String sessionToken = getPassword(c, OBSConstants.SESSION_TOKEN, login.getToken());\r\n    return new OBSLoginHelper.Login(accessKey, secretKey, sessionToken);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getPassword",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String getPassword(final Configuration conf, final String key, final String val) throws IOException\n{\r\n    return StringUtils.isEmpty(val) ? lookupPassword(conf, key) : val;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "lookupPassword",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String lookupPassword(final Configuration conf, final String key) throws IOException\n{\r\n    try {\r\n        final char[] pass = conf.getPassword(key);\r\n        return pass != null ? new String(pass).trim() : \"\";\r\n    } catch (IOException ioe) {\r\n        throw new IOException(\"Cannot find password option \" + key, ioe);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "stringify",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String stringify(final ObsObject summary)\n{\r\n    return summary.getObjectKey() + \" size=\" + summary.getMetadata().getContentLength();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "intOption",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "int intOption(final Configuration conf, final String key, final int defVal, final int min)\n{\r\n    int v = conf.getInt(key, defVal);\r\n    Preconditions.checkArgument(v >= min, String.format(\"Value of %s: %d is below the minimum value %d\", key, v, min));\r\n    LOG.debug(\"Value of {} is {}\", key, v);\r\n    return v;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "longOption",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "long longOption(final Configuration conf, final String key, final long defVal, final long min)\n{\r\n    long v = conf.getLong(key, defVal);\r\n    Preconditions.checkArgument(v >= min, String.format(\"Value of %s: %d is below the minimum value %d\", key, v, min));\r\n    LOG.debug(\"Value of {} is {}\", key, v);\r\n    return v;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "longBytesOption",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "long longBytesOption(final Configuration conf, final String key, final long defVal, final long min)\n{\r\n    long v = conf.getLongBytes(key, defVal);\r\n    Preconditions.checkArgument(v >= min, String.format(\"Value of %s: %d is below the minimum value %d\", key, v, min));\r\n    LOG.debug(\"Value of {} is {}\", key, v);\r\n    return v;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getMultipartSizeProperty",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "long getMultipartSizeProperty(final Configuration conf, final String property, final long defVal)\n{\r\n    long partSize = conf.getLongBytes(property, defVal);\r\n    if (partSize < OBSConstants.MULTIPART_MIN_SIZE) {\r\n        LOG.warn(\"{} must be at least 5 MB; configured value is {}\", property, partSize);\r\n        partSize = OBSConstants.MULTIPART_MIN_SIZE;\r\n    }\r\n    return partSize;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "ensureOutputParameterInRange",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "int ensureOutputParameterInRange(final String name, final long size)\n{\r\n    if (size > Integer.MAX_VALUE) {\r\n        LOG.warn(\"obs: {} capped to ~2.14GB\" + \" (maximum allowed size with current output mechanism)\", name);\r\n        return Integer.MAX_VALUE;\r\n    } else {\r\n        return (int) size;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "propagateBucketOptions",
  "errType" : null,
  "containingMethodsNum" : 12,
  "sourceCodeText" : "Configuration propagateBucketOptions(final Configuration source, final String bucket)\n{\r\n    Preconditions.checkArgument(StringUtils.isNotEmpty(bucket), \"bucket\");\r\n    final String bucketPrefix = OBSConstants.FS_OBS_BUCKET_PREFIX + bucket + '.';\r\n    LOG.debug(\"Propagating entries under {}\", bucketPrefix);\r\n    final Configuration dest = new Configuration(source);\r\n    for (Map.Entry<String, String> entry : source) {\r\n        final String key = entry.getKey();\r\n        final String value = entry.getValue();\r\n        if (!key.startsWith(bucketPrefix) || bucketPrefix.equals(key)) {\r\n            continue;\r\n        }\r\n        final String stripped = key.substring(bucketPrefix.length());\r\n        if (stripped.startsWith(\"bucket.\") || \"impl\".equals(stripped)) {\r\n            LOG.debug(\"Ignoring bucket option {}\", key);\r\n        } else {\r\n            final String generic = OBSConstants.FS_OBS_PREFIX + stripped;\r\n            LOG.debug(\"Updating {}\", generic);\r\n            dest.set(generic, value, key);\r\n        }\r\n    }\r\n    return dest;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "patchSecurityCredentialProviders",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void patchSecurityCredentialProviders(final Configuration conf)\n{\r\n    Collection<String> customCredentials = conf.getStringCollection(OBSConstants.OBS_SECURITY_CREDENTIAL_PROVIDER_PATH);\r\n    Collection<String> hadoopCredentials = conf.getStringCollection(CREDENTIAL_PROVIDER_PATH);\r\n    if (!customCredentials.isEmpty()) {\r\n        List<String> all = Lists.newArrayList(customCredentials);\r\n        all.addAll(hadoopCredentials);\r\n        String joined = StringUtils.join(all, ',');\r\n        LOG.debug(\"Setting {} to {}\", CREDENTIAL_PROVIDER_PATH, joined);\r\n        conf.set(CREDENTIAL_PROVIDER_PATH, joined, \"patch of \" + OBSConstants.OBS_SECURITY_CREDENTIAL_PROVIDER_PATH);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "verifyBucketExists",
  "errType" : [ "ObsException", "InterruptedException" ],
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void verifyBucketExists(final OBSFileSystem owner) throws FileNotFoundException, IOException\n{\r\n    int retryTime = 1;\r\n    while (true) {\r\n        try {\r\n            if (!owner.getObsClient().headBucket(owner.getBucket())) {\r\n                throw new FileNotFoundException(\"Bucket \" + owner.getBucket() + \" does not exist\");\r\n            }\r\n            return;\r\n        } catch (ObsException e) {\r\n            LOG.warn(\"Failed to head bucket for [{}], retry time [{}], \" + \"exception [{}]\", owner.getBucket(), retryTime, translateException(\"doesBucketExist\", owner.getBucket(), e));\r\n            if (MAX_RETRY_TIME == retryTime) {\r\n                throw translateException(\"doesBucketExist\", owner.getBucket(), e);\r\n            }\r\n            try {\r\n                Thread.sleep(DELAY_TIME);\r\n            } catch (InterruptedException ie) {\r\n                throw e;\r\n            }\r\n        }\r\n        retryTime++;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "initMultipartUploads",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 14,
  "sourceCodeText" : "void initMultipartUploads(final OBSFileSystem owner, final Configuration conf) throws IOException\n{\r\n    boolean purgeExistingMultipart = conf.getBoolean(OBSConstants.PURGE_EXISTING_MULTIPART, OBSConstants.DEFAULT_PURGE_EXISTING_MULTIPART);\r\n    long purgeExistingMultipartAge = longOption(conf, OBSConstants.PURGE_EXISTING_MULTIPART_AGE, OBSConstants.DEFAULT_PURGE_EXISTING_MULTIPART_AGE, 0);\r\n    if (!purgeExistingMultipart) {\r\n        return;\r\n    }\r\n    final Date purgeBefore = new Date(new Date().getTime() - purgeExistingMultipartAge * 1000);\r\n    try {\r\n        ListMultipartUploadsRequest request = new ListMultipartUploadsRequest(owner.getBucket());\r\n        while (true) {\r\n            MultipartUploadListing uploadListing = owner.getObsClient().listMultipartUploads(request);\r\n            for (MultipartUpload upload : uploadListing.getMultipartTaskList()) {\r\n                if (upload.getInitiatedDate().compareTo(purgeBefore) < 0) {\r\n                    owner.getObsClient().abortMultipartUpload(new AbortMultipartUploadRequest(owner.getBucket(), upload.getObjectKey(), upload.getUploadId()));\r\n                }\r\n            }\r\n            if (!uploadListing.isTruncated()) {\r\n                break;\r\n            }\r\n            request.setUploadIdMarker(uploadListing.getNextUploadIdMarker());\r\n            request.setKeyMarker(uploadListing.getNextKeyMarker());\r\n        }\r\n    } catch (ObsException e) {\r\n        if (e.getResponseCode() == FORBIDDEN_CODE) {\r\n            LOG.debug(\"Failed to purging multipart uploads against {},\" + \" FS may be read only\", owner.getBucket(), e);\r\n        } else {\r\n            throw translateException(\"purging multipart uploads\", owner.getBucket(), e);\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "shutdownAll",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void shutdownAll(final ExecutorService... executors)\n{\r\n    for (ExecutorService exe : executors) {\r\n        if (exe != null) {\r\n            try {\r\n                if (LOG != null) {\r\n                    LOG.debug(\"Shutdown {}\", exe);\r\n                }\r\n                exe.shutdown();\r\n            } catch (Exception e) {\r\n                if (LOG != null && LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Exception in shutdown {}\", exe, e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "createBlockIfNeeded",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "OBSDataBlocks.DataBlock createBlockIfNeeded() throws IOException\n{\r\n    if (activeBlock == null) {\r\n        blockCount++;\r\n        if (blockCount >= OBSConstants.MAX_MULTIPART_COUNT) {\r\n            LOG.warn(\"Number of partitions in stream exceeds limit for OBS: \" + OBSConstants.MAX_MULTIPART_COUNT + \" write may fail.\");\r\n        }\r\n        activeBlock = blockFactory.create(blockCount, this.blockSize);\r\n    }\r\n    return activeBlock;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getActiveBlock",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "OBSDataBlocks.DataBlock getActiveBlock()\n{\r\n    return activeBlock;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "mockPutPartError",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void mockPutPartError(final boolean isException)\n{\r\n    this.mockUploadPartError = isException;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "hasActiveBlock",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean hasActiveBlock()\n{\r\n    return activeBlock != null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "clearActiveBlock",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void clearActiveBlock()\n{\r\n    if (activeBlock != null) {\r\n        LOG.debug(\"Clearing active block\");\r\n    }\r\n    activeBlock = null;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "checkOpen",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void checkOpen() throws IOException\n{\r\n    if (closed.get()) {\r\n        throw new IOException(\"Filesystem \" + writeOperationHelper.toString(key) + \" closed\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "flush",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void flush() throws IOException\n{\r\n    checkOpen();\r\n    OBSDataBlocks.DataBlock dataBlock = getActiveBlock();\r\n    if (dataBlock != null) {\r\n        dataBlock.flush();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "write",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void write(final int b) throws IOException\n{\r\n    singleCharWrite[0] = (byte) b;\r\n    write(singleCharWrite, 0, 1);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "write",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void write(@NotNull final byte[] source, final int offset, final int len) throws IOException\n{\r\n    if (hasException.get()) {\r\n        String closeWarning = String.format(\"write has error. bs : pre upload obs[%s] has error.\", key);\r\n        LOG.warn(closeWarning);\r\n        throw new IOException(closeWarning);\r\n    }\r\n    OBSDataBlocks.validateWriteArgs(source, offset, len);\r\n    checkOpen();\r\n    if (len == 0) {\r\n        return;\r\n    }\r\n    OBSDataBlocks.DataBlock block = createBlockIfNeeded();\r\n    int written = block.write(source, offset, len);\r\n    int remainingCapacity = block.remainingCapacity();\r\n    try {\r\n        innerWrite(source, offset, len, written, remainingCapacity);\r\n    } catch (IOException e) {\r\n        LOG.error(\"Write data for key {} of bucket {} error, error message {}\", key, fs.getBucket(), e.getMessage());\r\n        throw e;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "innerWrite",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void innerWrite(final byte[] source, final int offset, final int len, final int written, final int remainingCapacity) throws IOException\n{\r\n    if (written < len) {\r\n        LOG.debug(\"writing more data than block has capacity -triggering upload\");\r\n        if (appendAble.get()) {\r\n            LOG.debug(\"[Append] open stream and single write size {} \" + \"greater than buffer size {}, append buffer to obs.\", len, blockSize);\r\n            flushCurrentBlock();\r\n        } else {\r\n            uploadCurrentBlock();\r\n        }\r\n        this.write(source, offset + written, len - written);\r\n    } else {\r\n        if (remainingCapacity == 0) {\r\n            if (appendAble.get()) {\r\n                LOG.debug(\"[Append] open stream and already write size \" + \"equal to buffer size {}, append buffer to obs.\", blockSize);\r\n                flushCurrentBlock();\r\n            } else {\r\n                uploadCurrentBlock();\r\n            }\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "uploadCurrentBlock",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void uploadCurrentBlock() throws IOException\n{\r\n    Preconditions.checkState(hasActiveBlock(), \"No active block\");\r\n    LOG.debug(\"Writing block # {}\", blockCount);\r\n    try {\r\n        if (multiPartUpload == null) {\r\n            LOG.debug(\"Initiating Multipart upload\");\r\n            multiPartUpload = new MultiPartUpload();\r\n        }\r\n        multiPartUpload.uploadBlockAsync(getActiveBlock());\r\n    } catch (IOException e) {\r\n        hasException.set(true);\r\n        LOG.error(\"Upload current block on ({}/{}) failed.\", fs.getBucket(), key, e);\r\n        throw e;\r\n    } finally {\r\n        clearActiveBlock();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "close",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void close() throws IOException\n{\r\n    if (closed.getAndSet(true)) {\r\n        LOG.debug(\"Ignoring close() as stream is already closed\");\r\n        return;\r\n    }\r\n    if (hasException.get()) {\r\n        String closeWarning = String.format(\"closed has error. bs : pre write obs[%s] has error.\", key);\r\n        LOG.warn(closeWarning);\r\n        throw new IOException(closeWarning);\r\n    }\r\n    completeCurrentBlock();\r\n    clearHFlushOrSync();\r\n    writeOperationHelper.writeSuccessful(key);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "putObjectIfNeedAppend",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void putObjectIfNeedAppend() throws IOException\n{\r\n    if (appendAble.get() && fs.exists(OBSCommonUtils.keyToQualifiedPath(fs, key))) {\r\n        appendFsFile();\r\n    } else {\r\n        putObject();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "appendFsFile",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void appendFsFile() throws IOException\n{\r\n    LOG.debug(\"bucket is posix, to append file. key is {}\", key);\r\n    final OBSDataBlocks.DataBlock block = getActiveBlock();\r\n    WriteFileRequest writeFileReq;\r\n    if (block instanceof OBSDataBlocks.DiskBlock) {\r\n        writeFileReq = OBSCommonUtils.newAppendFileRequest(fs, key, objectLen, (File) block.startUpload());\r\n    } else {\r\n        writeFileReq = OBSCommonUtils.newAppendFileRequest(fs, key, objectLen, (InputStream) block.startUpload());\r\n    }\r\n    OBSCommonUtils.appendFile(fs, writeFileReq);\r\n    objectLen += block.dataSize();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "putObject",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void putObject() throws IOException\n{\r\n    LOG.debug(\"Executing regular upload for {}\", writeOperationHelper.toString(key));\r\n    final OBSDataBlocks.DataBlock block = getActiveBlock();\r\n    clearActiveBlock();\r\n    final int size = block.dataSize();\r\n    final PutObjectRequest putObjectRequest;\r\n    if (block instanceof OBSDataBlocks.DiskBlock) {\r\n        putObjectRequest = writeOperationHelper.newPutRequest(key, (File) block.startUpload());\r\n    } else {\r\n        putObjectRequest = writeOperationHelper.newPutRequest(key, (InputStream) block.startUpload(), size);\r\n    }\r\n    putObjectRequest.setAcl(fs.getCannedACL());\r\n    fs.getSchemeStatistics().incrementWriteOps(1);\r\n    try {\r\n        writeOperationHelper.putObject(putObjectRequest);\r\n    } finally {\r\n        OBSCommonUtils.closeAll(block);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "toString",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "String toString()\n{\r\n    final StringBuilder sb = new StringBuilder(\"OBSBlockOutputStream{\");\r\n    sb.append(writeOperationHelper.toString());\r\n    sb.append(\", blockSize=\").append(blockSize);\r\n    OBSDataBlocks.DataBlock block = activeBlock;\r\n    if (block != null) {\r\n        sb.append(\", activeBlock=\").append(block);\r\n    }\r\n    sb.append('}');\r\n    return sb.toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "sync",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void sync()\n{\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "hflush",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void hflush() throws IOException\n{\r\n    flushOrSync();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "flushOrSync",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void flushOrSync() throws IOException\n{\r\n    checkOpen();\r\n    if (hasException.get()) {\r\n        String flushWarning = String.format(\"flushOrSync has error. bs : pre write obs[%s] has error.\", key);\r\n        LOG.warn(flushWarning);\r\n        throw new IOException(flushWarning);\r\n    }\r\n    if (fs.isFsBucket()) {\r\n        flushCurrentBlock();\r\n        clearHFlushOrSync();\r\n    } else {\r\n        LOG.warn(\"not posix bucket, not support hflush or hsync.\");\r\n        flush();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "clearHFlushOrSync",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void clearHFlushOrSync()\n{\r\n    appendAble.set(true);\r\n    multiPartUpload = null;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "uploadWriteBlocks",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void uploadWriteBlocks(final OBSDataBlocks.DataBlock block, final boolean hasBlock) throws IOException\n{\r\n    if (multiPartUpload == null) {\r\n        if (hasBlock) {\r\n            putObjectIfNeedAppend();\r\n        }\r\n    } else {\r\n        if (hasBlock && block.hasData()) {\r\n            uploadCurrentBlock();\r\n        }\r\n        final List<PartEtag> partETags = multiPartUpload.waitForAllPartUploads();\r\n        multiPartUpload.complete(partETags);\r\n    }\r\n    LOG.debug(\"Upload complete for {}\", writeOperationHelper.toString(key));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "completeCurrentBlock",
  "errType" : [ "IOException", "Exception" ],
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void completeCurrentBlock() throws IOException\n{\r\n    OBSDataBlocks.DataBlock block = getActiveBlock();\r\n    boolean hasBlock = hasActiveBlock();\r\n    LOG.debug(\"{}: complete block #{}: current block= {}\", this, blockCount, hasBlock ? block : \"(none)\");\r\n    try {\r\n        uploadWriteBlocks(block, hasBlock);\r\n    } catch (IOException ioe) {\r\n        LOG.error(\"Upload data to obs error. io exception : {}\", ioe.getMessage());\r\n        throw ioe;\r\n    } catch (Exception e) {\r\n        LOG.error(\"Upload data to obs error. other exception : {}\", e.getMessage());\r\n        throw e;\r\n    } finally {\r\n        OBSCommonUtils.closeAll(block);\r\n        clearActiveBlock();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "flushCurrentBlock",
  "errType" : [ "IOException", "Exception" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void flushCurrentBlock() throws IOException\n{\r\n    OBSDataBlocks.DataBlock block = getActiveBlock();\r\n    boolean hasBlock = hasActiveBlock();\r\n    LOG.debug(\"{}: complete block #{}: current block= {}\", this, blockCount, hasBlock ? block : \"(none)\");\r\n    try {\r\n        uploadWriteBlocks(block, hasBlock);\r\n    } catch (IOException ioe) {\r\n        LOG.error(\"hflush data to obs error. io exception : {}\", ioe.getMessage());\r\n        hasException.set(true);\r\n        throw ioe;\r\n    } catch (Exception e) {\r\n        LOG.error(\"hflush data to obs error. other exception : {}\", e.getMessage());\r\n        hasException.set(true);\r\n        throw e;\r\n    } finally {\r\n        OBSCommonUtils.closeAll(block);\r\n        clearActiveBlock();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "hsync",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void hsync() throws IOException\n{\r\n    flushOrSync();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fsGetObjectKeyDepth",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "int fsGetObjectKeyDepth(final String key)\n{\r\n    int depth = 0;\r\n    for (int idx = key.indexOf('/'); idx >= 0; idx = key.indexOf('/', idx + 1)) {\r\n        depth++;\r\n    }\r\n    return key.endsWith(\"/\") ? depth - 1 : depth;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fsIsFolder",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean fsIsFolder(final ObsFSAttribute attr)\n{\r\n    final int ifDir = 0x004000;\r\n    int mode = attr.getMode();\r\n    if (mode < 0) {\r\n        return false;\r\n    }\r\n    return (mode & ifDir) != 0;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "renameBasedOnPosix",
  "errType" : [ "FileNotFoundException", "FileConflictException" ],
  "containingMethodsNum" : 25,
  "sourceCodeText" : "boolean renameBasedOnPosix(final OBSFileSystem owner, final Path src, final Path dst) throws IOException\n{\r\n    Path dstPath = dst;\r\n    String srcKey = OBSCommonUtils.pathToKey(owner, src);\r\n    String dstKey = OBSCommonUtils.pathToKey(owner, dstPath);\r\n    if (srcKey.isEmpty()) {\r\n        LOG.error(\"rename: src [{}] is root directory\", src);\r\n        return false;\r\n    }\r\n    try {\r\n        FileStatus dstStatus = owner.getFileStatus(dstPath);\r\n        if (dstStatus.isDirectory()) {\r\n            String newDstString = OBSCommonUtils.maybeAddTrailingSlash(dstPath.toString());\r\n            String filename = srcKey.substring(OBSCommonUtils.pathToKey(owner, src.getParent()).length() + 1);\r\n            dstPath = new Path(newDstString + filename);\r\n            dstKey = OBSCommonUtils.pathToKey(owner, dstPath);\r\n            LOG.debug(\"rename: dest is an existing directory and will be \" + \"changed to [{}]\", dstPath);\r\n            if (owner.exists(dstPath)) {\r\n                LOG.error(\"rename: failed to rename \" + src + \" to \" + dstPath + \" because destination exists\");\r\n                return false;\r\n            }\r\n        } else {\r\n            if (srcKey.equals(dstKey)) {\r\n                LOG.warn(\"rename: src and dest refer to the same \" + \"file or directory: {}\", dstPath);\r\n                return true;\r\n            } else {\r\n                LOG.error(\"rename: failed to rename \" + src + \" to \" + dstPath + \" because destination exists\");\r\n                return false;\r\n            }\r\n        }\r\n    } catch (FileNotFoundException e) {\r\n        LOG.debug(\"rename: dest [{}] does not exist\", dstPath);\r\n    } catch (FileConflictException e) {\r\n        Path parent = dstPath.getParent();\r\n        if (!OBSCommonUtils.pathToKey(owner, parent).isEmpty()) {\r\n            FileStatus dstParentStatus = owner.getFileStatus(parent);\r\n            if (!dstParentStatus.isDirectory()) {\r\n                throw new ParentNotDirectoryException(parent + \" is not a directory\");\r\n            }\r\n        }\r\n    }\r\n    if (dstKey.startsWith(srcKey) && (dstKey.equals(srcKey) || dstKey.charAt(srcKey.length()) == Path.SEPARATOR_CHAR)) {\r\n        LOG.error(\"rename: dest [{}] cannot be a descendant of src [{}]\", dstPath, src);\r\n        return false;\r\n    }\r\n    return innerFsRenameWithRetry(owner, src, dstPath, srcKey, dstKey);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "innerFsRenameWithRetry",
  "errType" : [ "FileNotFoundException", "IOException", "InterruptedException" ],
  "containingMethodsNum" : 11,
  "sourceCodeText" : "boolean innerFsRenameWithRetry(final OBSFileSystem owner, final Path src, final Path dst, final String srcKey, final String dstKey) throws IOException\n{\r\n    boolean renameResult = true;\r\n    int retryTime = 1;\r\n    while (retryTime <= OBSCommonUtils.MAX_RETRY_TIME) {\r\n        try {\r\n            LOG.debug(\"rename: {}-st rename from [{}] to [{}] ...\", retryTime, srcKey, dstKey);\r\n            innerFsRenameFile(owner, srcKey, dstKey);\r\n            renameResult = true;\r\n            break;\r\n        } catch (FileNotFoundException e) {\r\n            if (owner.exists(dst)) {\r\n                LOG.warn(\"rename: successfully {}-st rename src [{}] \" + \"to dest [{}] with SDK retry\", retryTime, src, dst, e);\r\n                renameResult = true;\r\n            } else {\r\n                LOG.error(\"rename: failed {}-st rename src [{}] to dest [{}]\", retryTime, src, dst, e);\r\n                renameResult = false;\r\n            }\r\n            break;\r\n        } catch (IOException e) {\r\n            if (retryTime == OBSCommonUtils.MAX_RETRY_TIME) {\r\n                LOG.error(\"rename: failed {}-st rename src [{}] to dest [{}]\", retryTime, src, dst, e);\r\n                throw e;\r\n            } else {\r\n                LOG.warn(\"rename: failed {}-st rename src [{}] to dest [{}]\", retryTime, src, dst, e);\r\n                if (owner.exists(dst) && owner.exists(src)) {\r\n                    LOG.warn(\"rename: failed {}-st rename src [{}] to \" + \"dest [{}] with SDK retry\", retryTime, src, dst, e);\r\n                    renameResult = false;\r\n                    break;\r\n                }\r\n                try {\r\n                    Thread.sleep(OBSCommonUtils.DELAY_TIME);\r\n                } catch (InterruptedException ie) {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        retryTime++;\r\n    }\r\n    return renameResult;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fsRenameToNewFolder",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void fsRenameToNewFolder(final OBSFileSystem owner, final String src, final String dst) throws IOException, ObsException\n{\r\n    LOG.debug(\"RenameFolder path {} to {}\", src, dst);\r\n    try {\r\n        RenameRequest renameObjectRequest = new RenameRequest();\r\n        renameObjectRequest.setBucketName(owner.getBucket());\r\n        renameObjectRequest.setObjectKey(src);\r\n        renameObjectRequest.setNewObjectKey(dst);\r\n        owner.getObsClient().renameFolder(renameObjectRequest);\r\n        owner.getSchemeStatistics().incrementWriteOps(1);\r\n    } catch (ObsException e) {\r\n        throw OBSCommonUtils.translateException(\"renameFile(\" + src + \", \" + dst + \")\", src, e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "innerFsRenameFile",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "void innerFsRenameFile(final OBSFileSystem owner, final String srcKey, final String dstKey) throws IOException\n{\r\n    LOG.debug(\"RenameFile path {} to {}\", srcKey, dstKey);\r\n    try {\r\n        final RenameRequest renameObjectRequest = new RenameRequest();\r\n        renameObjectRequest.setBucketName(owner.getBucket());\r\n        renameObjectRequest.setObjectKey(srcKey);\r\n        renameObjectRequest.setNewObjectKey(dstKey);\r\n        owner.getObsClient().renameFile(renameObjectRequest);\r\n        owner.getSchemeStatistics().incrementWriteOps(1);\r\n    } catch (ObsException e) {\r\n        if (e.getResponseCode() == OBSCommonUtils.NOT_FOUND_CODE) {\r\n            throw new FileNotFoundException(\"No such file or directory: \" + srcKey);\r\n        }\r\n        if (e.getResponseCode() == OBSCommonUtils.CONFLICT_CODE) {\r\n            throw new FileConflictException(\"File conflicts during rename, \" + e.getResponseStatus());\r\n        }\r\n        throw OBSCommonUtils.translateException(\"renameFile(\" + srcKey + \", \" + dstKey + \")\", srcKey, e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fsRenameToNewObject",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void fsRenameToNewObject(final OBSFileSystem owner, final String srcKey, final String dstKey) throws IOException\n{\r\n    String newSrcKey = srcKey;\r\n    String newdstKey = dstKey;\r\n    newSrcKey = OBSCommonUtils.maybeDeleteBeginningSlash(newSrcKey);\r\n    newdstKey = OBSCommonUtils.maybeDeleteBeginningSlash(newdstKey);\r\n    if (newSrcKey.endsWith(\"/\")) {\r\n        fsRenameToNewFolder(owner, newSrcKey, newdstKey);\r\n    } else {\r\n        innerFsRenameFile(owner, newSrcKey, newdstKey);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fsRemoveFile",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "int fsRemoveFile(final OBSFileSystem owner, final String sonObjectKey, final List<KeyAndVersion> files) throws IOException\n{\r\n    files.add(new KeyAndVersion(sonObjectKey));\r\n    if (files.size() == owner.getMaxEntriesToDelete()) {\r\n        OBSCommonUtils.removeKeys(owner, files, true, false);\r\n        return owner.getMaxEntriesToDelete();\r\n    }\r\n    return 0;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fsDelete",
  "errType" : null,
  "containingMethodsNum" : 20,
  "sourceCodeText" : "boolean fsDelete(final OBSFileSystem owner, final FileStatus status, final boolean recursive) throws IOException, ObsException\n{\r\n    long startTime = System.currentTimeMillis();\r\n    long threadId = Thread.currentThread().getId();\r\n    Path f = status.getPath();\r\n    String key = OBSCommonUtils.pathToKey(owner, f);\r\n    if (!status.isDirectory()) {\r\n        LOG.debug(\"delete: Path is a file\");\r\n        trashObjectIfNeed(owner, key);\r\n    } else {\r\n        LOG.debug(\"delete: Path is a directory: {} - recursive {}\", f, recursive);\r\n        key = OBSCommonUtils.maybeAddTrailingSlash(key);\r\n        boolean isEmptyDir = OBSCommonUtils.isFolderEmpty(owner, key);\r\n        if (key.equals(\"\")) {\r\n            return OBSCommonUtils.rejectRootDirectoryDelete(owner.getBucket(), isEmptyDir, recursive);\r\n        }\r\n        if (!recursive && !isEmptyDir) {\r\n            LOG.warn(\"delete: Path is not empty: {} - recursive {}\", f, recursive);\r\n            throw new PathIsNotEmptyDirectoryException(f.toString());\r\n        }\r\n        if (isEmptyDir) {\r\n            LOG.debug(\"delete: Deleting fake empty directory {} - recursive {}\", f, recursive);\r\n            OBSCommonUtils.deleteObject(owner, key);\r\n        } else {\r\n            LOG.debug(\"delete: Deleting objects for directory prefix {} to \" + \"delete - recursive {}\", f, recursive);\r\n            trashFolderIfNeed(owner, key, f);\r\n        }\r\n    }\r\n    long endTime = System.currentTimeMillis();\r\n    LOG.debug(\"delete Path:{} thread:{}, timeUsedInMilliSec:{}\", f, threadId, endTime - startTime);\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "trashObjectIfNeed",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void trashObjectIfNeed(final OBSFileSystem owner, final String key) throws ObsException, IOException\n{\r\n    if (needToTrash(owner, key)) {\r\n        mkTrash(owner, key);\r\n        StringBuilder sb = new StringBuilder(owner.getTrashDir());\r\n        sb.append(key);\r\n        if (owner.exists(new Path(sb.toString()))) {\r\n            SimpleDateFormat df = new SimpleDateFormat(\"-yyyyMMddHHmmss\");\r\n            sb.append(df.format(new Date()));\r\n        }\r\n        fsRenameToNewObject(owner, key, sb.toString());\r\n        LOG.debug(\"Moved: '\" + key + \"' to trash at: \" + sb.toString());\r\n    } else {\r\n        OBSCommonUtils.deleteObject(owner, key);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "trashFolderIfNeed",
  "errType" : null,
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void trashFolderIfNeed(final OBSFileSystem owner, final String key, final Path f) throws ObsException, IOException\n{\r\n    if (needToTrash(owner, key)) {\r\n        mkTrash(owner, key);\r\n        StringBuilder sb = new StringBuilder(owner.getTrashDir());\r\n        String subKey = OBSCommonUtils.maybeAddTrailingSlash(key);\r\n        sb.append(subKey);\r\n        if (owner.exists(new Path(sb.toString()))) {\r\n            SimpleDateFormat df = new SimpleDateFormat(\"-yyyyMMddHHmmss\");\r\n            sb.insert(sb.length() - 1, df.format(new Date()));\r\n        }\r\n        String srcKey = OBSCommonUtils.maybeDeleteBeginningSlash(key);\r\n        String dstKey = OBSCommonUtils.maybeDeleteBeginningSlash(sb.toString());\r\n        fsRenameToNewFolder(owner, srcKey, dstKey);\r\n        LOG.debug(\"Moved: '\" + key + \"' to trash at: \" + sb.toString());\r\n    } else {\r\n        if (owner.isEnableMultiObjectDeleteRecursion()) {\r\n            long delNum = fsRecursivelyDeleteDir(owner, key, true);\r\n            LOG.debug(\"Recursively delete {} files/dirs when deleting {}\", delNum, key);\r\n        } else {\r\n            fsNonRecursivelyDelete(owner, f);\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fsRecursivelyDeleteDir",
  "errType" : null,
  "containingMethodsNum" : 20,
  "sourceCodeText" : "long fsRecursivelyDeleteDir(final OBSFileSystem owner, final String parentKey, final boolean deleteParent) throws IOException\n{\r\n    long delNum = 0;\r\n    List<KeyAndVersion> subdirList = new ArrayList<>(owner.getMaxEntriesToDelete());\r\n    List<KeyAndVersion> fileList = new ArrayList<>(owner.getMaxEntriesToDelete());\r\n    ListObjectsRequest request = OBSCommonUtils.createListObjectsRequest(owner, parentKey, \"/\", owner.getMaxKeys());\r\n    ObjectListing objects = OBSCommonUtils.listObjects(owner, request);\r\n    while (true) {\r\n        for (String commonPrefix : objects.getCommonPrefixes()) {\r\n            if (commonPrefix.equals(parentKey)) {\r\n                continue;\r\n            }\r\n            delNum += fsRemoveSubdir(owner, commonPrefix, subdirList);\r\n        }\r\n        for (ObsObject sonObject : objects.getObjects()) {\r\n            String sonObjectKey = sonObject.getObjectKey();\r\n            if (sonObjectKey.equals(parentKey)) {\r\n                continue;\r\n            }\r\n            if (!sonObjectKey.endsWith(\"/\")) {\r\n                delNum += fsRemoveFile(owner, sonObjectKey, fileList);\r\n            } else {\r\n                delNum += fsRemoveSubdir(owner, sonObjectKey, subdirList);\r\n            }\r\n        }\r\n        if (!objects.isTruncated()) {\r\n            break;\r\n        }\r\n        objects = OBSCommonUtils.continueListObjects(owner, objects);\r\n    }\r\n    delNum += fileList.size();\r\n    OBSCommonUtils.removeKeys(owner, fileList, true, false);\r\n    delNum += subdirList.size();\r\n    OBSCommonUtils.removeKeys(owner, subdirList, true, false);\r\n    if (deleteParent) {\r\n        OBSCommonUtils.deleteObject(owner, parentKey);\r\n        delNum++;\r\n    }\r\n    return delNum;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "needToTrash",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "boolean needToTrash(final OBSFileSystem owner, final String key)\n{\r\n    String newKey = key;\r\n    newKey = OBSCommonUtils.maybeDeleteBeginningSlash(newKey);\r\n    if (owner.isEnableTrash() && newKey.startsWith(owner.getTrashDir())) {\r\n        return false;\r\n    }\r\n    return owner.isEnableTrash();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fsRemoveSubdir",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "int fsRemoveSubdir(final OBSFileSystem owner, final String subdirKey, final List<KeyAndVersion> subdirList) throws IOException\n{\r\n    fsRecursivelyDeleteDir(owner, subdirKey, false);\r\n    subdirList.add(new KeyAndVersion(subdirKey));\r\n    if (subdirList.size() == owner.getMaxEntriesToDelete()) {\r\n        OBSCommonUtils.removeKeys(owner, subdirList, true, false);\r\n        return owner.getMaxEntriesToDelete();\r\n    }\r\n    return 0;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "mkTrash",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void mkTrash(final OBSFileSystem owner, final String key) throws ObsException, IOException\n{\r\n    String newKey = key;\r\n    StringBuilder sb = new StringBuilder(owner.getTrashDir());\r\n    newKey = OBSCommonUtils.maybeAddTrailingSlash(newKey);\r\n    sb.append(newKey);\r\n    sb.deleteCharAt(sb.length() - 1);\r\n    sb.delete(sb.lastIndexOf(\"/\"), sb.length());\r\n    Path fastDeleteRecycleDirPath = new Path(sb.toString());\r\n    if (!owner.exists(fastDeleteRecycleDirPath)) {\r\n        owner.mkdirs(fastDeleteRecycleDirPath);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fsNonRecursivelyDelete",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void fsNonRecursivelyDelete(final OBSFileSystem owner, final Path parent) throws IOException, ObsException\n{\r\n    FileStatus[] arFileStatus = OBSCommonUtils.innerListStatus(owner, parent, true);\r\n    fsRemoveKeys(owner, arFileStatus);\r\n    OBSCommonUtils.deleteObject(owner, OBSCommonUtils.pathToKey(owner, parent));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fsRemoveKeys",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void fsRemoveKeys(final OBSFileSystem owner, final FileStatus[] arFileStatus) throws ObsException, IOException\n{\r\n    if (arFileStatus.length <= 0) {\r\n        return;\r\n    }\r\n    String key;\r\n    for (FileStatus fileStatus : arFileStatus) {\r\n        key = OBSCommonUtils.pathToKey(owner, fileStatus.getPath());\r\n        OBSCommonUtils.blockRootDelete(owner.getBucket(), key);\r\n    }\r\n    fsRemoveKeysByDepth(owner, arFileStatus);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fsRemoveKeysByDepth",
  "errType" : null,
  "containingMethodsNum" : 13,
  "sourceCodeText" : "void fsRemoveKeysByDepth(final OBSFileSystem owner, final FileStatus[] arFileStatus) throws ObsException, IOException\n{\r\n    if (arFileStatus.length <= 0) {\r\n        return;\r\n    }\r\n    String key;\r\n    int depth = Integer.MAX_VALUE;\r\n    List<KeyAndVersion> leafKeys = new ArrayList<>(owner.getMaxEntriesToDelete());\r\n    for (int idx = arFileStatus.length - 1; idx >= 0; idx--) {\r\n        if (leafKeys.size() >= owner.getMaxEntriesToDelete()) {\r\n            OBSCommonUtils.removeKeys(owner, leafKeys, true, false);\r\n        }\r\n        key = OBSCommonUtils.pathToKey(owner, arFileStatus[idx].getPath());\r\n        if (!arFileStatus[idx].isDirectory()) {\r\n            leafKeys.add(new KeyAndVersion(key, null));\r\n            continue;\r\n        }\r\n        int keyDepth = fsGetObjectKeyDepth(key);\r\n        if (keyDepth == depth) {\r\n            leafKeys.add(new KeyAndVersion(key, null));\r\n            continue;\r\n        }\r\n        if (keyDepth < depth) {\r\n            OBSCommonUtils.removeKeys(owner, leafKeys, true, false);\r\n            depth = keyDepth;\r\n            leafKeys.add(new KeyAndVersion(key, null));\r\n            continue;\r\n        }\r\n        LOG.warn(\"The objects list is invalid because it isn't sorted by\" + \" path depth.\");\r\n        throw new ObsException(\"System failure\");\r\n    }\r\n    OBSCommonUtils.removeKeys(owner, leafKeys, true, false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fsCreateFolder",
  "errType" : [ "ObsException", "InterruptedException" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void fsCreateFolder(final OBSFileSystem owner, final String objectName) throws ObsException\n{\r\n    for (int retryTime = 1; retryTime < OBSCommonUtils.MAX_RETRY_TIME; retryTime++) {\r\n        try {\r\n            innerFsCreateFolder(owner, objectName);\r\n            return;\r\n        } catch (ObsException e) {\r\n            LOG.warn(\"Failed to create folder [{}], retry time [{}], \" + \"exception [{}]\", objectName, retryTime, e);\r\n            try {\r\n                Thread.sleep(OBSCommonUtils.DELAY_TIME);\r\n            } catch (InterruptedException ie) {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    innerFsCreateFolder(owner, objectName);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "innerFsCreateFolder",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void innerFsCreateFolder(final OBSFileSystem owner, final String objectName) throws ObsException\n{\r\n    final NewFolderRequest newFolderRequest = new NewFolderRequest(owner.getBucket(), objectName);\r\n    newFolderRequest.setAcl(owner.getCannedACL());\r\n    long len = newFolderRequest.getObjectKey().length();\r\n    owner.getObsClient().newFolder(newFolderRequest);\r\n    owner.getSchemeStatistics().incrementWriteOps(1);\r\n    owner.getSchemeStatistics().incrementBytesWritten(len);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "innerFsGetObjectStatus",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 23,
  "sourceCodeText" : "OBSFileStatus innerFsGetObjectStatus(final OBSFileSystem owner, final Path f) throws IOException\n{\r\n    final Path path = OBSCommonUtils.qualify(owner, f);\r\n    String key = OBSCommonUtils.pathToKey(owner, path);\r\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\r\n    if (key.isEmpty()) {\r\n        LOG.debug(\"Found root directory\");\r\n        return new OBSFileStatus(path, owner.getUsername());\r\n    }\r\n    try {\r\n        final GetAttributeRequest getAttrRequest = new GetAttributeRequest(owner.getBucket(), key);\r\n        ObsFSAttribute meta = owner.getObsClient().getAttribute(getAttrRequest);\r\n        owner.getSchemeStatistics().incrementReadOps(1);\r\n        if (fsIsFolder(meta)) {\r\n            LOG.debug(\"Found file (with /): fake directory\");\r\n            return new OBSFileStatus(path, OBSCommonUtils.dateToLong(meta.getLastModified()), owner.getUsername());\r\n        } else {\r\n            LOG.debug(\"Found file (with /): real file? should not happen: {}\", key);\r\n            return new OBSFileStatus(meta.getContentLength(), OBSCommonUtils.dateToLong(meta.getLastModified()), path, owner.getDefaultBlockSize(path), owner.getUsername());\r\n        }\r\n    } catch (ObsException e) {\r\n        if (e.getResponseCode() == OBSCommonUtils.NOT_FOUND_CODE) {\r\n            LOG.debug(\"Not Found: {}\", path);\r\n            throw new FileNotFoundException(\"No such file or directory: \" + path);\r\n        }\r\n        if (e.getResponseCode() == OBSCommonUtils.CONFLICT_CODE) {\r\n            throw new FileConflictException(\"file conflicts: \" + e.getResponseStatus());\r\n        }\r\n        throw OBSCommonUtils.translateException(\"getFileStatus\", path, e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fsGetDirectoryContentSummary",
  "errType" : null,
  "containingMethodsNum" : 20,
  "sourceCodeText" : "ContentSummary fsGetDirectoryContentSummary(final OBSFileSystem owner, final String key) throws IOException\n{\r\n    String newKey = key;\r\n    newKey = OBSCommonUtils.maybeAddTrailingSlash(newKey);\r\n    long[] summary = { 0, 0, 1 };\r\n    LOG.debug(\"Summary key {}\", newKey);\r\n    ListObjectsRequest request = new ListObjectsRequest();\r\n    request.setBucketName(owner.getBucket());\r\n    request.setPrefix(newKey);\r\n    request.setMaxKeys(owner.getMaxKeys());\r\n    ObjectListing objects = OBSCommonUtils.listObjects(owner, request);\r\n    while (true) {\r\n        if (!objects.getCommonPrefixes().isEmpty() || !objects.getObjects().isEmpty()) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"Found path as directory (with /): {}/{}\", objects.getCommonPrefixes().size(), objects.getObjects().size());\r\n            }\r\n            for (String prefix : objects.getCommonPrefixes()) {\r\n                if (!prefix.equals(newKey)) {\r\n                    summary[2]++;\r\n                }\r\n            }\r\n            for (ObsObject obj : objects.getObjects()) {\r\n                if (!obj.getObjectKey().endsWith(\"/\")) {\r\n                    summary[0] += obj.getMetadata().getContentLength();\r\n                    summary[1] += 1;\r\n                } else if (!obj.getObjectKey().equals(newKey)) {\r\n                    summary[2]++;\r\n                }\r\n            }\r\n        }\r\n        if (!objects.isTruncated()) {\r\n            break;\r\n        }\r\n        objects = OBSCommonUtils.continueListObjects(owner, objects);\r\n    }\r\n    LOG.debug(String.format(\"file size [%d] - file count [%d] - directory count [%d] - \" + \"file path [%s]\", summary[0], summary[1], summary[2], newKey));\r\n    return new ContentSummary.Builder().length(summary[0]).fileCount(summary[1]).directoryCount(summary[2]).spaceConsumed(summary[0]).build();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "buildFSURI",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "URI buildFSURI(final URI uri)\n{\r\n    Objects.requireNonNull(uri, \"null uri\");\r\n    Objects.requireNonNull(uri.getScheme(), \"null uri.getScheme()\");\r\n    if (uri.getHost() == null && uri.getAuthority() != null) {\r\n        Objects.requireNonNull(uri.getHost(), \"null uri host.\" + \" This can be caused by unencoded / in the \" + \"password string\");\r\n    }\r\n    Objects.requireNonNull(uri.getHost(), \"null uri host.\");\r\n    return URI.create(uri.getScheme() + \"://\" + uri.getHost());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "toString",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String toString(final URI pathUri)\n{\r\n    return pathUri != null ? String.format(\"%s://%s/%s\", pathUri.getScheme(), pathUri.getHost(), pathUri.getPath()) : \"(null URI)\";\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "extractLoginDetailsWithWarnings",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "Login extractLoginDetailsWithWarnings(final URI name)\n{\r\n    Login login = extractLoginDetails(name);\r\n    if (login.hasLogin()) {\r\n        LOG.warn(LOGIN_WARNING);\r\n    }\r\n    return login;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "extractLoginDetails",
  "errType" : [ "UnsupportedEncodingException" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "Login extractLoginDetails(final URI name)\n{\r\n    try {\r\n        String authority = name.getAuthority();\r\n        if (authority == null) {\r\n            return Login.EMPTY;\r\n        }\r\n        int loginIndex = authority.indexOf('@');\r\n        if (loginIndex < 0) {\r\n            return Login.EMPTY;\r\n        }\r\n        String login = authority.substring(0, loginIndex);\r\n        int loginSplit = login.indexOf(':');\r\n        if (loginSplit > 0) {\r\n            String user = login.substring(0, loginSplit);\r\n            String encodedPassword = login.substring(loginSplit + 1);\r\n            if (encodedPassword.contains(PLUS_UNENCODED)) {\r\n                LOG.warn(PLUS_WARNING);\r\n                encodedPassword = encodedPassword.replaceAll(\"\\\\\" + PLUS_UNENCODED, PLUS_ENCODED);\r\n            }\r\n            String password = URLDecoder.decode(encodedPassword, \"UTF-8\");\r\n            return new Login(user, password);\r\n        } else if (loginSplit == 0) {\r\n            return Login.EMPTY;\r\n        } else {\r\n            return new Login(login, \"\");\r\n        }\r\n    } catch (UnsupportedEncodingException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "canonicalizeUri",
  "errType" : [ "URISyntaxException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "URI canonicalizeUri(final URI uri, final int defaultPort)\n{\r\n    URI newUri = uri;\r\n    if (uri.getPort() == -1 && defaultPort > 0) {\r\n        try {\r\n            newUri = new URI(newUri.getScheme(), null, newUri.getHost(), defaultPort, newUri.getPath(), newUri.getQuery(), newUri.getFragment());\r\n        } catch (URISyntaxException e) {\r\n            throw new AssertionError(\"Valid URI became unparseable: \" + newUri);\r\n        }\r\n    }\r\n    return newUri;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "checkPath",
  "errType" : null,
  "containingMethodsNum" : 13,
  "sourceCodeText" : "void checkPath(final Configuration conf, final URI fsUri, final Path path, final int defaultPort)\n{\r\n    URI pathUri = path.toUri();\r\n    String thatScheme = pathUri.getScheme();\r\n    if (thatScheme == null) {\r\n        return;\r\n    }\r\n    URI thisUri = canonicalizeUri(fsUri, defaultPort);\r\n    String thisScheme = thisUri.getScheme();\r\n    if (equalsIgnoreCase(thisScheme, thatScheme)) {\r\n        String thisHost = thisUri.getHost();\r\n        String thatHost = pathUri.getHost();\r\n        if (thatHost == null && thisHost != null) {\r\n            URI defaultUri = FileSystem.getDefaultUri(conf);\r\n            if (equalsIgnoreCase(thisScheme, defaultUri.getScheme())) {\r\n                pathUri = defaultUri;\r\n            } else {\r\n                pathUri = null;\r\n            }\r\n        }\r\n        if (pathUri != null) {\r\n            pathUri = canonicalizeUri(pathUri, defaultPort);\r\n            thatHost = pathUri.getHost();\r\n            if (equalsIgnoreCase(thisHost, thatHost)) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"Wrong FS \" + OBSLoginHelper.toString(pathUri) + \" -expected \" + fsUri);\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "renameBasedOnObject",
  "errType" : [ "FileNotFoundException" ],
  "containingMethodsNum" : 31,
  "sourceCodeText" : "boolean renameBasedOnObject(final OBSFileSystem owner, final Path src, final Path dst) throws RenameFailedException, FileNotFoundException, IOException, ObsException\n{\r\n    String srcKey = OBSCommonUtils.pathToKey(owner, src);\r\n    String dstKey = OBSCommonUtils.pathToKey(owner, dst);\r\n    if (srcKey.isEmpty()) {\r\n        LOG.error(\"rename: src [{}] is root directory\", src);\r\n        throw new IOException(src + \" is root directory\");\r\n    }\r\n    FileStatus srcStatus = owner.getFileStatus(src);\r\n    FileStatus dstStatus;\r\n    try {\r\n        dstStatus = owner.getFileStatus(dst);\r\n        if (dstStatus.isDirectory()) {\r\n            String newDstKey = OBSCommonUtils.maybeAddTrailingSlash(dstKey);\r\n            String filename = srcKey.substring(OBSCommonUtils.pathToKey(owner, src.getParent()).length() + 1);\r\n            newDstKey = newDstKey + filename;\r\n            dstKey = newDstKey;\r\n            dstStatus = owner.getFileStatus(OBSCommonUtils.keyToPath(dstKey));\r\n            if (dstStatus.isDirectory()) {\r\n                throw new RenameFailedException(src, dst, \"new destination is an existed directory\").withExitCode(false);\r\n            } else {\r\n                throw new RenameFailedException(src, dst, \"new destination is an existed file\").withExitCode(false);\r\n            }\r\n        } else {\r\n            if (srcKey.equals(dstKey)) {\r\n                LOG.warn(\"rename: src and dest refer to the same file or\" + \" directory: {}\", dst);\r\n                return true;\r\n            } else {\r\n                throw new RenameFailedException(src, dst, \"destination is an existed file\").withExitCode(false);\r\n            }\r\n        }\r\n    } catch (FileNotFoundException e) {\r\n        LOG.debug(\"rename: destination path {} not found\", dst);\r\n        checkDestinationParent(owner, src, dst);\r\n    }\r\n    if (dstKey.startsWith(srcKey) && dstKey.charAt(srcKey.length()) == Path.SEPARATOR_CHAR) {\r\n        LOG.error(\"rename: dest [{}] cannot be a descendant of src [{}]\", dst, src);\r\n        return false;\r\n    }\r\n    if (srcStatus.isFile()) {\r\n        LOG.debug(\"rename: renaming file {} to {}\", src, dst);\r\n        renameFile(owner, srcKey, dstKey, srcStatus);\r\n    } else {\r\n        LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\r\n        dstKey = OBSCommonUtils.maybeAddTrailingSlash(dstKey);\r\n        srcKey = OBSCommonUtils.maybeAddTrailingSlash(srcKey);\r\n        renameFolder(owner, srcKey, dstKey);\r\n    }\r\n    if (src.getParent() != dst.getParent()) {\r\n        createFakeDirectoryIfNecessary(owner, src.getParent());\r\n    }\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "checkDestinationParent",
  "errType" : [ "FileNotFoundException" ],
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void checkDestinationParent(final OBSFileSystem owner, final Path src, final Path dst) throws IOException\n{\r\n    Path parent = dst.getParent();\r\n    if (!OBSCommonUtils.pathToKey(owner, parent).isEmpty()) {\r\n        try {\r\n            FileStatus dstParentStatus = owner.getFileStatus(dst.getParent());\r\n            if (!dstParentStatus.isDirectory()) {\r\n                throw new ParentNotDirectoryException(\"destination parent [\" + dst.getParent() + \"] is not a directory\");\r\n            }\r\n        } catch (FileNotFoundException e2) {\r\n            throw new RenameFailedException(src, dst, \"destination has no parent \");\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "renameFile",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void renameFile(final OBSFileSystem owner, final String srcKey, final String dstKey, final FileStatus srcStatus) throws IOException\n{\r\n    long startTime = System.nanoTime();\r\n    copyFile(owner, srcKey, dstKey, srcStatus.getLen());\r\n    objectDelete(owner, srcStatus, false);\r\n    if (LOG.isDebugEnabled()) {\r\n        long delay = System.nanoTime() - startTime;\r\n        LOG.debug(\"OBSFileSystem rename: \" + \", {src=\" + srcKey + \", dst=\" + dstKey + \", delay=\" + delay + \"}\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "objectDelete",
  "errType" : null,
  "containingMethodsNum" : 18,
  "sourceCodeText" : "boolean objectDelete(final OBSFileSystem owner, final FileStatus status, final boolean recursive) throws IOException\n{\r\n    Path f = status.getPath();\r\n    String key = OBSCommonUtils.pathToKey(owner, f);\r\n    if (status.isDirectory()) {\r\n        LOG.debug(\"delete: Path is a directory: {} - recursive {}\", f, recursive);\r\n        key = OBSCommonUtils.maybeAddTrailingSlash(key);\r\n        if (!key.endsWith(\"/\")) {\r\n            key = key + \"/\";\r\n        }\r\n        boolean isEmptyDir = OBSCommonUtils.isFolderEmpty(owner, key);\r\n        if (key.equals(\"/\")) {\r\n            return OBSCommonUtils.rejectRootDirectoryDelete(owner.getBucket(), isEmptyDir, recursive);\r\n        }\r\n        if (!recursive && !isEmptyDir) {\r\n            throw new PathIsNotEmptyDirectoryException(f.toString());\r\n        }\r\n        if (isEmptyDir) {\r\n            LOG.debug(\"delete: Deleting fake empty directory {} - recursive {}\", f, recursive);\r\n            OBSCommonUtils.deleteObject(owner, key);\r\n        } else {\r\n            LOG.debug(\"delete: Deleting objects for directory prefix {} \" + \"- recursive {}\", f, recursive);\r\n            deleteNonEmptyDir(owner, recursive, key);\r\n        }\r\n    } else {\r\n        LOG.debug(\"delete: Path is a file\");\r\n        OBSCommonUtils.deleteObject(owner, key);\r\n    }\r\n    Path parent = f.getParent();\r\n    if (parent != null) {\r\n        createFakeDirectoryIfNecessary(owner, parent);\r\n    }\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "renameFolder",
  "errType" : null,
  "containingMethodsNum" : 27,
  "sourceCodeText" : "void renameFolder(final OBSFileSystem owner, final String srcKey, final String dstKey) throws IOException\n{\r\n    long startTime = System.nanoTime();\r\n    List<KeyAndVersion> keysToDelete = new ArrayList<>();\r\n    createFakeDirectory(owner, dstKey);\r\n    ListObjectsRequest request = new ListObjectsRequest();\r\n    request.setBucketName(owner.getBucket());\r\n    request.setPrefix(srcKey);\r\n    request.setMaxKeys(owner.getMaxKeys());\r\n    ObjectListing objects = OBSCommonUtils.listObjects(owner, request);\r\n    List<Future<CopyObjectResult>> copyfutures = new LinkedList<>();\r\n    while (true) {\r\n        for (ObsObject summary : objects.getObjects()) {\r\n            if (summary.getObjectKey().equals(srcKey)) {\r\n                continue;\r\n            }\r\n            keysToDelete.add(new KeyAndVersion(summary.getObjectKey()));\r\n            String newDstKey = dstKey + summary.getObjectKey().substring(srcKey.length());\r\n            copyfutures.add(copyFileAsync(owner, summary.getObjectKey(), newDstKey, summary.getMetadata().getContentLength()));\r\n            if (keysToDelete.size() == owner.getMaxEntriesToDelete()) {\r\n                waitAllCopyFinished(copyfutures);\r\n                copyfutures.clear();\r\n            }\r\n        }\r\n        if (!objects.isTruncated()) {\r\n            if (!keysToDelete.isEmpty()) {\r\n                waitAllCopyFinished(copyfutures);\r\n                copyfutures.clear();\r\n            }\r\n            break;\r\n        }\r\n        objects = OBSCommonUtils.continueListObjects(owner, objects);\r\n    }\r\n    keysToDelete.add(new KeyAndVersion(srcKey));\r\n    DeleteObjectsRequest deleteObjectsRequest = new DeleteObjectsRequest(owner.getBucket());\r\n    deleteObjectsRequest.setKeyAndVersions(keysToDelete.toArray(new KeyAndVersion[0]));\r\n    OBSCommonUtils.deleteObjects(owner, deleteObjectsRequest);\r\n    if (LOG.isDebugEnabled()) {\r\n        long delay = System.nanoTime() - startTime;\r\n        LOG.debug(\"OBSFileSystem rename: \" + \", {src=\" + srcKey + \", dst=\" + dstKey + \", delay=\" + delay + \"}\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "waitAllCopyFinished",
  "errType" : [ "InterruptedException", "ExecutionException" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void waitAllCopyFinished(final List<Future<CopyObjectResult>> copyFutures) throws IOException\n{\r\n    try {\r\n        for (Future<CopyObjectResult> copyFuture : copyFutures) {\r\n            copyFuture.get();\r\n        }\r\n    } catch (InterruptedException e) {\r\n        LOG.warn(\"Interrupted while copying objects (copy)\");\r\n        throw new InterruptedIOException(\"Interrupted while copying objects (copy)\");\r\n    } catch (ExecutionException e) {\r\n        for (Future<CopyObjectResult> future : copyFutures) {\r\n            future.cancel(true);\r\n        }\r\n        throw OBSCommonUtils.extractException(\"waitAllCopyFinished\", copyFutures.toString(), e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getObjectMetadata",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "ObjectMetadata getObjectMetadata(final OBSFileSystem owner, final String key)\n{\r\n    GetObjectMetadataRequest request = new GetObjectMetadataRequest();\r\n    request.setBucketName(owner.getBucket());\r\n    request.setObjectKey(key);\r\n    if (owner.getSse().isSseCEnable()) {\r\n        request.setSseCHeader(owner.getSse().getSseCHeader());\r\n    }\r\n    ObjectMetadata meta = owner.getObsClient().getObjectMetadata(request);\r\n    owner.getSchemeStatistics().incrementReadOps(1);\r\n    return meta;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "newObjectMetadata",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "ObjectMetadata newObjectMetadata(final long length)\n{\r\n    final ObjectMetadata om = new ObjectMetadata();\r\n    if (length >= 0) {\r\n        om.setContentLength(length);\r\n    }\r\n    return om;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "deleteNonEmptyDir",
  "errType" : null,
  "containingMethodsNum" : 14,
  "sourceCodeText" : "void deleteNonEmptyDir(final OBSFileSystem owner, final boolean recursive, final String key) throws IOException\n{\r\n    String delimiter = recursive ? null : \"/\";\r\n    ListObjectsRequest request = OBSCommonUtils.createListObjectsRequest(owner, key, delimiter);\r\n    ObjectListing objects = OBSCommonUtils.listObjects(owner, request);\r\n    List<KeyAndVersion> keys = new ArrayList<>(objects.getObjects().size());\r\n    while (true) {\r\n        for (ObsObject summary : objects.getObjects()) {\r\n            if (summary.getObjectKey().equals(key)) {\r\n                continue;\r\n            }\r\n            keys.add(new KeyAndVersion(summary.getObjectKey()));\r\n            LOG.debug(\"Got object to delete {}\", summary.getObjectKey());\r\n            if (keys.size() == owner.getMaxEntriesToDelete()) {\r\n                OBSCommonUtils.removeKeys(owner, keys, true, true);\r\n            }\r\n        }\r\n        if (!objects.isTruncated()) {\r\n            keys.add(new KeyAndVersion(key));\r\n            OBSCommonUtils.removeKeys(owner, keys, false, true);\r\n            break;\r\n        }\r\n        objects = OBSCommonUtils.continueListObjects(owner, objects);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "createFakeDirectoryIfNecessary",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void createFakeDirectoryIfNecessary(final OBSFileSystem owner, final Path f) throws IOException, ObsException\n{\r\n    String key = OBSCommonUtils.pathToKey(owner, f);\r\n    if (!key.isEmpty() && !owner.exists(f)) {\r\n        LOG.debug(\"Creating new fake directory at {}\", f);\r\n        createFakeDirectory(owner, key);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "createFakeDirectory",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void createFakeDirectory(final OBSFileSystem owner, final String objectName) throws ObsException, IOException\n{\r\n    String newObjectName = objectName;\r\n    newObjectName = OBSCommonUtils.maybeAddTrailingSlash(newObjectName);\r\n    createEmptyObject(owner, newObjectName);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "createEmptyObject",
  "errType" : [ "ObsException", "InterruptedException" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void createEmptyObject(final OBSFileSystem owner, final String objectName) throws ObsException, IOException\n{\r\n    for (int retryTime = 1; retryTime < OBSCommonUtils.MAX_RETRY_TIME; retryTime++) {\r\n        try {\r\n            innerCreateEmptyObject(owner, objectName);\r\n            return;\r\n        } catch (ObsException e) {\r\n            LOG.warn(\"Failed to create empty object [{}], retry time [{}], \" + \"exception [{}]\", objectName, retryTime, e);\r\n            try {\r\n                Thread.sleep(OBSCommonUtils.DELAY_TIME);\r\n            } catch (InterruptedException ie) {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    innerCreateEmptyObject(owner, objectName);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "innerCreateEmptyObject",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void innerCreateEmptyObject(final OBSFileSystem owner, final String objectName) throws ObsException, IOException\n{\r\n    final InputStream im = new InputStream() {\r\n\r\n        @Override\r\n        public int read() {\r\n            return -1;\r\n        }\r\n    };\r\n    PutObjectRequest putObjectRequest = OBSCommonUtils.newPutObjectRequest(owner, objectName, newObjectMetadata(0L), im);\r\n    long len;\r\n    if (putObjectRequest.getFile() != null) {\r\n        len = putObjectRequest.getFile().length();\r\n    } else {\r\n        len = putObjectRequest.getMetadata().getContentLength();\r\n    }\r\n    try {\r\n        owner.getObsClient().putObject(putObjectRequest);\r\n        owner.getSchemeStatistics().incrementWriteOps(1);\r\n        owner.getSchemeStatistics().incrementBytesWritten(len);\r\n    } finally {\r\n        im.close();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "copyFile",
  "errType" : [ "InterruptedIOException", "IOException", "InterruptedException" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void copyFile(final OBSFileSystem owner, final String srcKey, final String dstKey, final long size) throws IOException, InterruptedIOException\n{\r\n    for (int retryTime = 1; retryTime < OBSCommonUtils.MAX_RETRY_TIME; retryTime++) {\r\n        try {\r\n            innerCopyFile(owner, srcKey, dstKey, size);\r\n            return;\r\n        } catch (InterruptedIOException e) {\r\n            throw e;\r\n        } catch (IOException e) {\r\n            LOG.warn(\"Failed to copy file from [{}] to [{}] with size [{}], \" + \"retry time [{}], exception [{}]\", srcKey, dstKey, size, retryTime, e);\r\n            try {\r\n                Thread.sleep(OBSCommonUtils.DELAY_TIME);\r\n            } catch (InterruptedException ie) {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    innerCopyFile(owner, srcKey, dstKey, size);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "innerCopyFile",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 29,
  "sourceCodeText" : "void innerCopyFile(final OBSFileSystem owner, final String srcKey, final String dstKey, final long size) throws IOException\n{\r\n    LOG.debug(\"copyFile {} -> {} \", srcKey, dstKey);\r\n    try {\r\n        if (size > owner.getCopyPartSize()) {\r\n            InitiateMultipartUploadRequest request = new InitiateMultipartUploadRequest(owner.getBucket(), dstKey);\r\n            request.setAcl(owner.getCannedACL());\r\n            if (owner.getSse().isSseCEnable()) {\r\n                request.setSseCHeader(owner.getSse().getSseCHeader());\r\n            } else if (owner.getSse().isSseKmsEnable()) {\r\n                request.setSseKmsHeader(owner.getSse().getSseKmsHeader());\r\n            }\r\n            InitiateMultipartUploadResult result = owner.getObsClient().initiateMultipartUpload(request);\r\n            final String uploadId = result.getUploadId();\r\n            LOG.debug(\"Multipart copy file, uploadId: {}\", uploadId);\r\n            long partCount = calPartCount(owner.getCopyPartSize(), size);\r\n            final List<PartEtag> partEtags = getCopyFilePartEtags(owner, srcKey, dstKey, size, uploadId, partCount);\r\n            CompleteMultipartUploadRequest completeMultipartUploadRequest = new CompleteMultipartUploadRequest(owner.getBucket(), dstKey, uploadId, partEtags);\r\n            owner.getObsClient().completeMultipartUpload(completeMultipartUploadRequest);\r\n        } else {\r\n            ObjectMetadata srcom = getObjectMetadata(owner, srcKey);\r\n            ObjectMetadata dstom = cloneObjectMetadata(srcom);\r\n            final CopyObjectRequest copyObjectRequest = new CopyObjectRequest(owner.getBucket(), srcKey, owner.getBucket(), dstKey);\r\n            copyObjectRequest.setAcl(owner.getCannedACL());\r\n            copyObjectRequest.setNewObjectMetadata(dstom);\r\n            if (owner.getSse().isSseCEnable()) {\r\n                copyObjectRequest.setSseCHeader(owner.getSse().getSseCHeader());\r\n                copyObjectRequest.setSseCHeaderSource(owner.getSse().getSseCHeader());\r\n            } else if (owner.getSse().isSseKmsEnable()) {\r\n                copyObjectRequest.setSseKmsHeader(owner.getSse().getSseKmsHeader());\r\n            }\r\n            owner.getObsClient().copyObject(copyObjectRequest);\r\n        }\r\n        owner.getSchemeStatistics().incrementWriteOps(1);\r\n    } catch (ObsException e) {\r\n        throw OBSCommonUtils.translateException(\"copyFile(\" + srcKey + \", \" + dstKey + \")\", srcKey, e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "calPartCount",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "int calPartCount(final long partSize, final long cloudSize)\n{\r\n    long partCount = cloudSize % partSize == 0 ? cloudSize / partSize : cloudSize / partSize + 1;\r\n    return (int) partCount;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getCopyFilePartEtags",
  "errType" : [ "InterruptedException", "ExecutionException" ],
  "containingMethodsNum" : 9,
  "sourceCodeText" : "List<PartEtag> getCopyFilePartEtags(final OBSFileSystem owner, final String srcKey, final String dstKey, final long objectSize, final String uploadId, final long partCount) throws IOException\n{\r\n    final List<PartEtag> partEtags = Collections.synchronizedList(new ArrayList<>());\r\n    final List<Future<?>> partCopyFutures = new ArrayList<>();\r\n    submitCopyPartTasks(owner, srcKey, dstKey, objectSize, uploadId, partCount, partEtags, partCopyFutures);\r\n    try {\r\n        for (Future<?> partCopyFuture : partCopyFutures) {\r\n            partCopyFuture.get();\r\n        }\r\n    } catch (InterruptedException e) {\r\n        LOG.warn(\"Interrupted while copying objects (copy)\");\r\n        throw new InterruptedIOException(\"Interrupted while copying objects (copy)\");\r\n    } catch (ExecutionException e) {\r\n        LOG.error(\"Multipart copy file exception.\", e);\r\n        for (Future<?> future : partCopyFutures) {\r\n            future.cancel(true);\r\n        }\r\n        owner.getObsClient().abortMultipartUpload(new AbortMultipartUploadRequest(owner.getBucket(), dstKey, uploadId));\r\n        throw OBSCommonUtils.extractException(\"Multi-part copy with id '\" + uploadId + \"' from \" + srcKey + \"to \" + dstKey, dstKey, e);\r\n    }\r\n    partEtags.sort(Comparator.comparingInt(PartEtag::getPartNumber));\r\n    return partEtags;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "submitCopyPartTasks",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void submitCopyPartTasks(final OBSFileSystem owner, final String srcKey, final String dstKey, final long objectSize, final String uploadId, final long partCount, final List<PartEtag> partEtags, final List<Future<?>> partCopyFutures)\n{\r\n    for (int i = 0; i < partCount; i++) {\r\n        final long rangeStart = i * owner.getCopyPartSize();\r\n        final long rangeEnd = (i + 1 == partCount) ? objectSize - 1 : rangeStart + owner.getCopyPartSize() - 1;\r\n        final int partNumber = i + 1;\r\n        partCopyFutures.add(owner.getBoundedCopyPartThreadPool().submit(() -> {\r\n            CopyPartRequest request = new CopyPartRequest();\r\n            request.setUploadId(uploadId);\r\n            request.setSourceBucketName(owner.getBucket());\r\n            request.setSourceObjectKey(srcKey);\r\n            request.setDestinationBucketName(owner.getBucket());\r\n            request.setDestinationObjectKey(dstKey);\r\n            request.setByteRangeStart(rangeStart);\r\n            request.setByteRangeEnd(rangeEnd);\r\n            request.setPartNumber(partNumber);\r\n            if (owner.getSse().isSseCEnable()) {\r\n                request.setSseCHeaderSource(owner.getSse().getSseCHeader());\r\n                request.setSseCHeaderDestination(owner.getSse().getSseCHeader());\r\n            }\r\n            CopyPartResult result = owner.getObsClient().copyPart(request);\r\n            partEtags.add(new PartEtag(result.getEtag(), result.getPartNumber()));\r\n            LOG.debug(\"Multipart copy file, uploadId: {}, Part#{} done.\", uploadId, partNumber);\r\n        }));\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "cloneObjectMetadata",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "ObjectMetadata cloneObjectMetadata(final ObjectMetadata source)\n{\r\n    ObjectMetadata ret = newObjectMetadata(source.getContentLength());\r\n    if (source.getContentEncoding() != null) {\r\n        ret.setContentEncoding(source.getContentEncoding());\r\n    }\r\n    return ret;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "innerGetObjectStatus",
  "errType" : [ "ObsException", "ObsException", "ObsException" ],
  "containingMethodsNum" : 33,
  "sourceCodeText" : "OBSFileStatus innerGetObjectStatus(final OBSFileSystem owner, final Path f) throws IOException\n{\r\n    final Path path = OBSCommonUtils.qualify(owner, f);\r\n    String key = OBSCommonUtils.pathToKey(owner, path);\r\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\r\n    if (!StringUtils.isEmpty(key)) {\r\n        try {\r\n            ObjectMetadata meta = getObjectMetadata(owner, key);\r\n            if (OBSCommonUtils.objectRepresentsDirectory(key, meta.getContentLength())) {\r\n                LOG.debug(\"Found exact file: fake directory\");\r\n                return new OBSFileStatus(path, owner.getUsername());\r\n            } else {\r\n                LOG.debug(\"Found exact file: normal file\");\r\n                return new OBSFileStatus(meta.getContentLength(), OBSCommonUtils.dateToLong(meta.getLastModified()), path, owner.getDefaultBlockSize(path), owner.getUsername());\r\n            }\r\n        } catch (ObsException e) {\r\n            if (e.getResponseCode() != OBSCommonUtils.NOT_FOUND_CODE) {\r\n                throw OBSCommonUtils.translateException(\"getFileStatus\", path, e);\r\n            }\r\n        }\r\n        if (!key.endsWith(\"/\")) {\r\n            String newKey = key + \"/\";\r\n            try {\r\n                ObjectMetadata meta = getObjectMetadata(owner, newKey);\r\n                if (OBSCommonUtils.objectRepresentsDirectory(newKey, meta.getContentLength())) {\r\n                    LOG.debug(\"Found file (with /): fake directory\");\r\n                    return new OBSFileStatus(path, owner.getUsername());\r\n                } else {\r\n                    LOG.debug(\"Found file (with /): real file? should not \" + \"happen: {}\", key);\r\n                    return new OBSFileStatus(meta.getContentLength(), OBSCommonUtils.dateToLong(meta.getLastModified()), path, owner.getDefaultBlockSize(path), owner.getUsername());\r\n                }\r\n            } catch (ObsException e) {\r\n                if (e.getResponseCode() != OBSCommonUtils.NOT_FOUND_CODE) {\r\n                    throw OBSCommonUtils.translateException(\"getFileStatus\", newKey, e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        boolean isEmpty = OBSCommonUtils.innerIsFolderEmpty(owner, key);\r\n        LOG.debug(\"Is dir ({}) empty? {}\", path, isEmpty);\r\n        return new OBSFileStatus(path, owner.getUsername());\r\n    } catch (ObsException e) {\r\n        if (e.getResponseCode() != OBSCommonUtils.NOT_FOUND_CODE) {\r\n            throw OBSCommonUtils.translateException(\"getFileStatus\", key, e);\r\n        }\r\n    }\r\n    LOG.debug(\"Not Found: {}\", path);\r\n    throw new FileNotFoundException(\"No such file or directory: \" + path);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 3,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getDirectoryContentSummary",
  "errType" : null,
  "containingMethodsNum" : 23,
  "sourceCodeText" : "ContentSummary getDirectoryContentSummary(final OBSFileSystem owner, final String key) throws IOException\n{\r\n    String newKey = key;\r\n    newKey = OBSCommonUtils.maybeAddTrailingSlash(newKey);\r\n    long[] summary = { 0, 0, 1 };\r\n    LOG.debug(\"Summary key {}\", newKey);\r\n    ListObjectsRequest request = new ListObjectsRequest();\r\n    request.setBucketName(owner.getBucket());\r\n    request.setPrefix(newKey);\r\n    Set<String> directories = new TreeSet<>();\r\n    request.setMaxKeys(owner.getMaxKeys());\r\n    ObjectListing objects = OBSCommonUtils.listObjects(owner, request);\r\n    while (true) {\r\n        if (!objects.getCommonPrefixes().isEmpty() || !objects.getObjects().isEmpty()) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"Found path as directory (with /): {}/{}\", objects.getCommonPrefixes().size(), objects.getObjects().size());\r\n            }\r\n            for (String prefix : objects.getCommonPrefixes()) {\r\n                LOG.debug(\"Objects in folder [\" + prefix + \"]:\");\r\n                getDirectories(prefix, newKey, directories);\r\n            }\r\n            for (ObsObject obj : objects.getObjects()) {\r\n                LOG.debug(\"Summary: {} {}\", obj.getObjectKey(), obj.getMetadata().getContentLength());\r\n                if (!obj.getObjectKey().endsWith(\"/\")) {\r\n                    summary[0] += obj.getMetadata().getContentLength();\r\n                    summary[1] += 1;\r\n                }\r\n                getDirectories(obj.getObjectKey(), newKey, directories);\r\n            }\r\n        }\r\n        if (!objects.isTruncated()) {\r\n            break;\r\n        }\r\n        objects = OBSCommonUtils.continueListObjects(owner, objects);\r\n    }\r\n    summary[2] += directories.size();\r\n    LOG.debug(String.format(\"file size [%d] - file count [%d] - directory count [%d] - \" + \"file path [%s]\", summary[0], summary[1], summary[2], newKey));\r\n    return new ContentSummary.Builder().length(summary[0]).fileCount(summary[1]).directoryCount(summary[2]).spaceConsumed(summary[0]).build();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getDirectories",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void getDirectories(final String key, final String sourceKey, final Set<String> directories)\n{\r\n    Path p = new Path(key);\r\n    Path sourcePath = new Path(sourceKey);\r\n    if (key.endsWith(\"/\") && p.compareTo(sourcePath) > 0) {\r\n        directories.add(p.toString());\r\n    }\r\n    while (p.compareTo(sourcePath) > 0) {\r\n        Optional<Path> parent = p.getOptionalParentPath();\r\n        if (!parent.isPresent()) {\r\n            break;\r\n        }\r\n        p = parent.get();\r\n        if (p.compareTo(sourcePath) == 0) {\r\n            break;\r\n        }\r\n        directories.add(p.toString());\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "copyFileAsync",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Future<CopyObjectResult> copyFileAsync(final OBSFileSystem owner, final String srcKey, final String dstKey, final long size)\n{\r\n    return owner.getBoundedCopyThreadPool().submit(() -> {\r\n        copyFile(owner, srcKey, dstKey, size);\r\n        return null;\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "validateWriteArgs",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void validateWriteArgs(final byte[] b, final int off, final int len)\n{\r\n    Preconditions.checkNotNull(b);\r\n    if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {\r\n        throw new IndexOutOfBoundsException(\"write (b[\" + b.length + \"], \" + off + \", \" + len + ')');\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "createFactory",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "BlockFactory createFactory(final OBSFileSystem owner, final String name)\n{\r\n    switch(name) {\r\n        case OBSConstants.FAST_UPLOAD_BUFFER_ARRAY:\r\n            return new ByteArrayBlockFactory(owner);\r\n        case OBSConstants.FAST_UPLOAD_BUFFER_DISK:\r\n            return new DiskBlockFactory(owner);\r\n        case OBSConstants.FAST_UPLOAD_BYTEBUFFER:\r\n            return new ByteBufferBlockFactory(owner);\r\n        default:\r\n            throw new IllegalArgumentException(\"Unsupported block buffer\" + \" \\\"\" + name + '\"');\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "initialize",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 41,
  "sourceCodeText" : "void initialize(final URI name, final Configuration originalConf) throws IOException\n{\r\n    uri = URI.create(name.getScheme() + \"://\" + name.getAuthority());\r\n    bucket = name.getAuthority();\r\n    Configuration conf = OBSCommonUtils.propagateBucketOptions(originalConf, bucket);\r\n    OBSCommonUtils.patchSecurityCredentialProviders(conf);\r\n    super.initialize(name, conf);\r\n    setConf(conf);\r\n    try {\r\n        username = UserGroupInformation.getCurrentUser().getShortUserName();\r\n        workingDir = new Path(\"/user\", username).makeQualified(this.uri, this.getWorkingDirectory());\r\n        Class<? extends OBSClientFactory> obsClientFactoryClass = conf.getClass(OBSConstants.OBS_CLIENT_FACTORY_IMPL, OBSConstants.DEFAULT_OBS_CLIENT_FACTORY_IMPL, OBSClientFactory.class);\r\n        obs = ReflectionUtils.newInstance(obsClientFactoryClass, conf).createObsClient(name);\r\n        sse = new SseWrapper(conf);\r\n        OBSCommonUtils.verifyBucketExists(this);\r\n        enablePosix = OBSCommonUtils.getBucketFsStatus(obs, bucket);\r\n        maxKeys = OBSCommonUtils.intOption(conf, OBSConstants.MAX_PAGING_KEYS, OBSConstants.DEFAULT_MAX_PAGING_KEYS, 1);\r\n        obsListing = new OBSListing(this);\r\n        partSize = OBSCommonUtils.getMultipartSizeProperty(conf, OBSConstants.MULTIPART_SIZE, OBSConstants.DEFAULT_MULTIPART_SIZE);\r\n        blockSize = OBSCommonUtils.longBytesOption(conf, OBSConstants.FS_OBS_BLOCK_SIZE, OBSConstants.DEFAULT_FS_OBS_BLOCK_SIZE, 1);\r\n        enableMultiObjectDelete = conf.getBoolean(OBSConstants.ENABLE_MULTI_DELETE, true);\r\n        maxEntriesToDelete = conf.getInt(OBSConstants.MULTI_DELETE_MAX_NUMBER, OBSConstants.DEFAULT_MULTI_DELETE_MAX_NUMBER);\r\n        enableMultiObjectDeleteRecursion = conf.getBoolean(OBSConstants.MULTI_DELETE_RECURSION, true);\r\n        obsContentSummaryEnable = conf.getBoolean(OBSConstants.OBS_CONTENT_SUMMARY_ENABLE, true);\r\n        readAheadRange = OBSCommonUtils.longBytesOption(conf, OBSConstants.READAHEAD_RANGE, OBSConstants.DEFAULT_READAHEAD_RANGE, 0);\r\n        readTransformEnable = conf.getBoolean(OBSConstants.READ_TRANSFORM_ENABLE, true);\r\n        multiDeleteThreshold = conf.getInt(OBSConstants.MULTI_DELETE_THRESHOLD, OBSConstants.MULTI_DELETE_DEFAULT_THRESHOLD);\r\n        initThreadPools(conf);\r\n        writeHelper = new OBSWriteOperationHelper(this);\r\n        initCannedAcls(conf);\r\n        OBSCommonUtils.initMultipartUploads(this, conf);\r\n        String blockOutputBuffer = conf.getTrimmed(OBSConstants.FAST_UPLOAD_BUFFER, OBSConstants.FAST_UPLOAD_BUFFER_DISK);\r\n        partSize = OBSCommonUtils.ensureOutputParameterInRange(OBSConstants.MULTIPART_SIZE, partSize);\r\n        blockFactory = OBSDataBlocks.createFactory(this, blockOutputBuffer);\r\n        blockOutputActiveBlocks = OBSCommonUtils.intOption(conf, OBSConstants.FAST_UPLOAD_ACTIVE_BLOCKS, OBSConstants.DEFAULT_FAST_UPLOAD_ACTIVE_BLOCKS, 1);\r\n        LOG.debug(\"Using OBSBlockOutputStream with buffer = {}; block={};\" + \" queue limit={}\", blockOutputBuffer, partSize, blockOutputActiveBlocks);\r\n        enableTrash = conf.getBoolean(OBSConstants.TRASH_ENABLE, OBSConstants.DEFAULT_TRASH);\r\n        if (enableTrash) {\r\n            if (!isFsBucket()) {\r\n                String errorMsg = String.format(\"The bucket [%s] is not posix. not supported for \" + \"trash.\", bucket);\r\n                LOG.warn(errorMsg);\r\n                enableTrash = false;\r\n                trashDir = null;\r\n            } else {\r\n                trashDir = conf.get(OBSConstants.TRASH_DIR);\r\n                if (StringUtils.isEmpty(trashDir)) {\r\n                    String errorMsg = String.format(\"The trash feature(fs.obs.trash.enable) is \" + \"enabled, but the \" + \"configuration(fs.obs.trash.dir [%s]) \" + \"is empty.\", trashDir);\r\n                    LOG.error(errorMsg);\r\n                    throw new ObsException(errorMsg);\r\n                }\r\n                trashDir = OBSCommonUtils.maybeAddBeginningSlash(trashDir);\r\n                trashDir = OBSCommonUtils.maybeAddTrailingSlash(trashDir);\r\n            }\r\n        }\r\n    } catch (ObsException e) {\r\n        throw OBSCommonUtils.translateException(\"initializing \", new Path(name), e);\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "initThreadPools",
  "errType" : null,
  "containingMethodsNum" : 30,
  "sourceCodeText" : "void initThreadPools(final Configuration conf)\n{\r\n    long keepAliveTime = OBSCommonUtils.longOption(conf, OBSConstants.KEEPALIVE_TIME, OBSConstants.DEFAULT_KEEPALIVE_TIME, 0);\r\n    int maxThreads = conf.getInt(OBSConstants.MAX_THREADS, OBSConstants.DEFAULT_MAX_THREADS);\r\n    if (maxThreads < 2) {\r\n        LOG.warn(OBSConstants.MAX_THREADS + \" must be at least 2: forcing to 2.\");\r\n        maxThreads = 2;\r\n    }\r\n    int totalTasks = OBSCommonUtils.intOption(conf, OBSConstants.MAX_TOTAL_TASKS, OBSConstants.DEFAULT_MAX_TOTAL_TASKS, 1);\r\n    boundedMultipartUploadThreadPool = BlockingThreadPoolExecutorService.newInstance(maxThreads, maxThreads + totalTasks, keepAliveTime, TimeUnit.SECONDS, \"obs-transfer-shared\");\r\n    int maxDeleteThreads = conf.getInt(OBSConstants.MAX_DELETE_THREADS, OBSConstants.DEFAULT_MAX_DELETE_THREADS);\r\n    if (maxDeleteThreads < 2) {\r\n        LOG.warn(OBSConstants.MAX_DELETE_THREADS + \" must be at least 2: forcing to 2.\");\r\n        maxDeleteThreads = 2;\r\n    }\r\n    int coreDeleteThreads = (int) Math.ceil(maxDeleteThreads / 2.0);\r\n    boundedDeleteThreadPool = new ThreadPoolExecutor(coreDeleteThreads, maxDeleteThreads, keepAliveTime, TimeUnit.SECONDS, new LinkedBlockingQueue<>(), BlockingThreadPoolExecutorService.newDaemonThreadFactory(\"obs-delete-transfer-shared\"));\r\n    boundedDeleteThreadPool.allowCoreThreadTimeOut(true);\r\n    if (enablePosix) {\r\n        obsClientDFSListEnable = conf.getBoolean(OBSConstants.OBS_CLIENT_DFS_LIST_ENABLE, true);\r\n        if (obsClientDFSListEnable) {\r\n            int coreListThreads = conf.getInt(OBSConstants.CORE_LIST_THREADS, OBSConstants.DEFAULT_CORE_LIST_THREADS);\r\n            int maxListThreads = conf.getInt(OBSConstants.MAX_LIST_THREADS, OBSConstants.DEFAULT_MAX_LIST_THREADS);\r\n            int listWorkQueueCapacity = conf.getInt(OBSConstants.LIST_WORK_QUEUE_CAPACITY, OBSConstants.DEFAULT_LIST_WORK_QUEUE_CAPACITY);\r\n            listParallelFactor = conf.getInt(OBSConstants.LIST_PARALLEL_FACTOR, OBSConstants.DEFAULT_LIST_PARALLEL_FACTOR);\r\n            if (listParallelFactor < 1) {\r\n                LOG.warn(OBSConstants.LIST_PARALLEL_FACTOR + \" must be at least 1: forcing to 1.\");\r\n                listParallelFactor = 1;\r\n            }\r\n            boundedListThreadPool = new ThreadPoolExecutor(coreListThreads, maxListThreads, keepAliveTime, TimeUnit.SECONDS, new LinkedBlockingQueue<>(listWorkQueueCapacity), BlockingThreadPoolExecutorService.newDaemonThreadFactory(\"obs-list-transfer-shared\"));\r\n            boundedListThreadPool.allowCoreThreadTimeOut(true);\r\n        }\r\n    } else {\r\n        int maxCopyThreads = conf.getInt(OBSConstants.MAX_COPY_THREADS, OBSConstants.DEFAULT_MAX_COPY_THREADS);\r\n        if (maxCopyThreads < 2) {\r\n            LOG.warn(OBSConstants.MAX_COPY_THREADS + \" must be at least 2: forcing to 2.\");\r\n            maxCopyThreads = 2;\r\n        }\r\n        int coreCopyThreads = (int) Math.ceil(maxCopyThreads / 2.0);\r\n        boundedCopyThreadPool = new ThreadPoolExecutor(coreCopyThreads, maxCopyThreads, keepAliveTime, TimeUnit.SECONDS, new LinkedBlockingQueue<>(), BlockingThreadPoolExecutorService.newDaemonThreadFactory(\"obs-copy-transfer-shared\"));\r\n        boundedCopyThreadPool.allowCoreThreadTimeOut(true);\r\n        copyPartSize = OBSCommonUtils.longOption(conf, OBSConstants.COPY_PART_SIZE, OBSConstants.DEFAULT_COPY_PART_SIZE, 0);\r\n        if (copyPartSize > OBSConstants.MAX_COPY_PART_SIZE) {\r\n            LOG.warn(\"obs: {} capped to ~5GB (maximum allowed part size with \" + \"current output mechanism)\", OBSConstants.COPY_PART_SIZE);\r\n            copyPartSize = OBSConstants.MAX_COPY_PART_SIZE;\r\n        }\r\n        int maxCopyPartThreads = conf.getInt(OBSConstants.MAX_COPY_PART_THREADS, OBSConstants.DEFAULT_MAX_COPY_PART_THREADS);\r\n        if (maxCopyPartThreads < 2) {\r\n            LOG.warn(OBSConstants.MAX_COPY_PART_THREADS + \" must be at least 2: forcing to 2.\");\r\n            maxCopyPartThreads = 2;\r\n        }\r\n        int coreCopyPartThreads = (int) Math.ceil(maxCopyPartThreads / 2.0);\r\n        boundedCopyPartThreadPool = new ThreadPoolExecutor(coreCopyPartThreads, maxCopyPartThreads, keepAliveTime, TimeUnit.SECONDS, new LinkedBlockingQueue<>(), BlockingThreadPoolExecutorService.newDaemonThreadFactory(\"obs-copy-part-transfer-shared\"));\r\n        boundedCopyPartThreadPool.allowCoreThreadTimeOut(true);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "isFsBucket",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean isFsBucket()\n{\r\n    return enablePosix;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "isReadTransformEnabled",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean isReadTransformEnabled()\n{\r\n    return readTransformEnable;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "initCannedAcls",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void initCannedAcls(final Configuration conf)\n{\r\n    String cannedACLName = conf.get(OBSConstants.CANNED_ACL, OBSConstants.DEFAULT_CANNED_ACL);\r\n    if (!cannedACLName.isEmpty()) {\r\n        switch(cannedACLName) {\r\n            case \"Private\":\r\n            case \"PublicRead\":\r\n            case \"PublicReadWrite\":\r\n            case \"AuthenticatedRead\":\r\n            case \"LogDeliveryWrite\":\r\n            case \"BucketOwnerRead\":\r\n            case \"BucketOwnerFullControl\":\r\n                cannedACL = new AccessControlList();\r\n                break;\r\n            default:\r\n                cannedACL = null;\r\n        }\r\n    } else {\r\n        cannedACL = null;\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getCannedACL",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "AccessControlList getCannedACL()\n{\r\n    return cannedACL;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getScheme",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getScheme()\n{\r\n    return \"obs\";\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getUri",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "URI getUri()\n{\r\n    return uri;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getDefaultPort",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "int getDefaultPort()\n{\r\n    return OBSConstants.OBS_DEFAULT_PORT;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getObsClient",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "ObsClient getObsClient()\n{\r\n    return obs;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getReadAheadRange",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "long getReadAheadRange()\n{\r\n    return readAheadRange;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getBucket",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getBucket()\n{\r\n    return bucket;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "checkPath",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void checkPath(final Path path)\n{\r\n    OBSLoginHelper.checkPath(getConf(), getUri(), path, getDefaultPort());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "canonicalizeUri",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "URI canonicalizeUri(final URI rawUri)\n{\r\n    return OBSLoginHelper.canonicalizeUri(rawUri, getDefaultPort());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "open",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "FSDataInputStream open(final Path f, final int bufferSize) throws IOException\n{\r\n    LOG.debug(\"Opening '{}' for reading.\", f);\r\n    final FileStatus fileStatus = getFileStatus(f);\r\n    if (fileStatus.isDirectory()) {\r\n        throw new FileNotFoundException(\"Can't open \" + f + \" because it is a directory\");\r\n    }\r\n    return new FSDataInputStream(new OBSInputStream(bucket, OBSCommonUtils.pathToKey(this, f), fileStatus.getLen(), obs, statistics, readAheadRange, this));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "create",
  "errType" : [ "FileNotFoundException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "FSDataOutputStream create(final Path f, final FsPermission permission, final boolean overwrite, final int bufferSize, final short replication, final long blkSize, final Progressable progress) throws IOException\n{\r\n    String key = OBSCommonUtils.pathToKey(this, f);\r\n    FileStatus status;\r\n    long objectLen = 0;\r\n    try {\r\n        status = getFileStatus(f);\r\n        objectLen = status.getLen();\r\n        if (status.isDirectory()) {\r\n            throw new FileAlreadyExistsException(f + \" is a directory\");\r\n        }\r\n        if (!overwrite) {\r\n            throw new FileAlreadyExistsException(f + \" already exists\");\r\n        }\r\n        LOG.debug(\"create: Overwriting file {}\", f);\r\n    } catch (FileNotFoundException e) {\r\n        LOG.debug(\"create: Creating new file {}\", f);\r\n    }\r\n    return new FSDataOutputStream(new OBSBlockOutputStream(this, key, objectLen, new SemaphoredDelegatingExecutor(boundedMultipartUploadThreadPool, blockOutputActiveBlocks, true), false), null);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getPartSize",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "long getPartSize()\n{\r\n    return partSize;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getBlockFactory",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "OBSDataBlocks.BlockFactory getBlockFactory()\n{\r\n    return blockFactory;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getWriteHelper",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "OBSWriteOperationHelper getWriteHelper()\n{\r\n    return writeHelper;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "create",
  "errType" : [ "FileNotFoundException" ],
  "containingMethodsNum" : 9,
  "sourceCodeText" : "FSDataOutputStream create(final Path f, final FsPermission permission, final EnumSet<CreateFlag> flags, final int bufferSize, final short replication, final long blkSize, final Progressable progress, final ChecksumOpt checksumOpt) throws IOException\n{\r\n    LOG.debug(\"create: Creating new file {}, flags:{}, isFsBucket:{}\", f, flags, isFsBucket());\r\n    if (null != flags && flags.contains(CreateFlag.APPEND)) {\r\n        if (!isFsBucket()) {\r\n            throw new UnsupportedOperationException(\"non-posix bucket. Append is not supported by \" + \"OBSFileSystem\");\r\n        }\r\n        String key = OBSCommonUtils.pathToKey(this, f);\r\n        FileStatus status;\r\n        long objectLen = 0;\r\n        try {\r\n            status = getFileStatus(f);\r\n            objectLen = status.getLen();\r\n            if (status.isDirectory()) {\r\n                throw new FileAlreadyExistsException(f + \" is a directory\");\r\n            }\r\n        } catch (FileNotFoundException e) {\r\n            LOG.debug(\"FileNotFoundException, create: Creating new file {}\", f);\r\n        }\r\n        return new FSDataOutputStream(new OBSBlockOutputStream(this, key, objectLen, new SemaphoredDelegatingExecutor(boundedMultipartUploadThreadPool, blockOutputActiveBlocks, true), true), null);\r\n    } else {\r\n        return create(f, permission, flags == null || flags.contains(CreateFlag.OVERWRITE), bufferSize, replication, blkSize, progress);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "createNonRecursive",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "FSDataOutputStream createNonRecursive(final Path path, final FsPermission permission, final EnumSet<CreateFlag> flags, final int bufferSize, final short replication, final long blkSize, final Progressable progress) throws IOException\n{\r\n    Path parent = path.getParent();\r\n    if (parent != null && !getFileStatus(parent).isDirectory()) {\r\n        throw new FileAlreadyExistsException(\"Not a directory: \" + parent);\r\n    }\r\n    return create(path, permission, flags.contains(CreateFlag.OVERWRITE), bufferSize, replication, blkSize, progress);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "append",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "FSDataOutputStream append(final Path f, final int bufferSize, final Progressable progress) throws IOException\n{\r\n    if (!isFsBucket()) {\r\n        throw new UnsupportedOperationException(\"non-posix bucket. Append is not supported \" + \"by OBSFileSystem\");\r\n    }\r\n    LOG.debug(\"append: Append file {}.\", f);\r\n    String key = OBSCommonUtils.pathToKey(this, f);\r\n    FileStatus status = getFileStatus(f);\r\n    long objectLen = status.getLen();\r\n    if (status.isDirectory()) {\r\n        throw new FileAlreadyExistsException(f + \" is a directory\");\r\n    }\r\n    return new FSDataOutputStream(new OBSBlockOutputStream(this, key, objectLen, new SemaphoredDelegatingExecutor(boundedMultipartUploadThreadPool, blockOutputActiveBlocks, true), true), null);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "exists",
  "errType" : [ "FileNotFoundException|FileConflictException" ],
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean exists(final Path f) throws IOException\n{\r\n    try {\r\n        return getFileStatus(f) != null;\r\n    } catch (FileNotFoundException | FileConflictException e) {\r\n        return false;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "rename",
  "errType" : [ "ObsException", "RenameFailedException", "FileNotFoundException" ],
  "containingMethodsNum" : 11,
  "sourceCodeText" : "boolean rename(final Path src, final Path dst) throws IOException\n{\r\n    long startTime = System.currentTimeMillis();\r\n    long threadId = Thread.currentThread().getId();\r\n    LOG.debug(\"Rename path {} to {} start\", src, dst);\r\n    try {\r\n        if (enablePosix) {\r\n            return OBSPosixBucketUtils.renameBasedOnPosix(this, src, dst);\r\n        } else {\r\n            return OBSObjectBucketUtils.renameBasedOnObject(this, src, dst);\r\n        }\r\n    } catch (ObsException e) {\r\n        throw OBSCommonUtils.translateException(\"rename(\" + src + \", \" + dst + \")\", src, e);\r\n    } catch (RenameFailedException e) {\r\n        LOG.error(e.getMessage());\r\n        return e.getExitCode();\r\n    } catch (FileNotFoundException e) {\r\n        LOG.error(e.toString());\r\n        return false;\r\n    } finally {\r\n        long endTime = System.currentTimeMillis();\r\n        LOG.debug(\"Rename path {} to {} finished, thread:{}, \" + \"timeUsedInMilliSec:{}.\", src, dst, threadId, endTime - startTime);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getMaxEntriesToDelete",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "int getMaxEntriesToDelete()\n{\r\n    return maxEntriesToDelete;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getListParallelFactor",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "int getListParallelFactor()\n{\r\n    return listParallelFactor;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getBoundedListThreadPool",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "ThreadPoolExecutor getBoundedListThreadPool()\n{\r\n    return boundedListThreadPool;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "isObsClientDFSListEnable",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean isObsClientDFSListEnable()\n{\r\n    return obsClientDFSListEnable;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getSchemeStatistics",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Statistics getSchemeStatistics()\n{\r\n    return statistics;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getMultiDeleteThreshold",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "int getMultiDeleteThreshold()\n{\r\n    return multiDeleteThreshold;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "isEnableMultiObjectDelete",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean isEnableMultiObjectDelete()\n{\r\n    return enableMultiObjectDelete;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "delete",
  "errType" : [ "FileNotFoundException", "ObsException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "boolean delete(final Path f, final boolean recursive) throws IOException\n{\r\n    try {\r\n        FileStatus status = getFileStatus(f);\r\n        LOG.debug(\"delete: path {} - recursive {}\", status.getPath(), recursive);\r\n        if (enablePosix) {\r\n            return OBSPosixBucketUtils.fsDelete(this, status, recursive);\r\n        }\r\n        return OBSObjectBucketUtils.objectDelete(this, status, recursive);\r\n    } catch (FileNotFoundException e) {\r\n        LOG.warn(\"Couldn't delete {} - does not exist\", f);\r\n        return false;\r\n    } catch (ObsException e) {\r\n        throw OBSCommonUtils.translateException(\"delete\", f, e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "isEnableTrash",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean isEnableTrash()\n{\r\n    return enableTrash;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getTrashDir",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getTrashDir()\n{\r\n    return trashDir;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "isEnableMultiObjectDeleteRecursion",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean isEnableMultiObjectDeleteRecursion()\n{\r\n    return enableMultiObjectDeleteRecursion;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "listStatus",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "FileStatus[] listStatus(final Path f) throws FileNotFoundException, IOException\n{\r\n    long startTime = System.currentTimeMillis();\r\n    long threadId = Thread.currentThread().getId();\r\n    try {\r\n        FileStatus[] statuses = OBSCommonUtils.innerListStatus(this, f, false);\r\n        long endTime = System.currentTimeMillis();\r\n        LOG.debug(\"List status for path:{}, thread:{}, timeUsedInMilliSec:{}\", f, threadId, endTime - startTime);\r\n        return statuses;\r\n    } catch (ObsException e) {\r\n        throw OBSCommonUtils.translateException(\"listStatus\", f, e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "listStatus",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "FileStatus[] listStatus(final Path f, final boolean recursive) throws FileNotFoundException, IOException\n{\r\n    long startTime = System.currentTimeMillis();\r\n    long threadId = Thread.currentThread().getId();\r\n    try {\r\n        FileStatus[] statuses = OBSCommonUtils.innerListStatus(this, f, recursive);\r\n        long endTime = System.currentTimeMillis();\r\n        LOG.debug(\"List status for path:{}, thread:{}, timeUsedInMilliSec:{}\", f, threadId, endTime - startTime);\r\n        return statuses;\r\n    } catch (ObsException e) {\r\n        throw OBSCommonUtils.translateException(\"listStatus with recursive flag[\" + (recursive ? \"true] \" : \"false] \"), f, e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getObsListing",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "OBSListing getObsListing()\n{\r\n    return obsListing;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getWorkingDirectory",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Path getWorkingDirectory()\n{\r\n    return workingDir;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "setWorkingDirectory",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void setWorkingDirectory(final Path newDir)\n{\r\n    workingDir = newDir;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getUsername",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getUsername()\n{\r\n    return username;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "mkdirs",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "boolean mkdirs(final Path path, final FsPermission permission) throws IOException, FileAlreadyExistsException\n{\r\n    try {\r\n        return OBSCommonUtils.innerMkdirs(this, path);\r\n    } catch (ObsException e) {\r\n        throw OBSCommonUtils.translateException(\"mkdirs\", path, e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getFileStatus",
  "errType" : [ "FileNotFoundException|FileConflictException", "IOException", "InterruptedException" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "FileStatus getFileStatus(final Path f) throws FileNotFoundException, IOException\n{\r\n    for (int retryTime = 1; retryTime < OBSCommonUtils.MAX_RETRY_TIME; retryTime++) {\r\n        try {\r\n            return innerGetFileStatus(f);\r\n        } catch (FileNotFoundException | FileConflictException e) {\r\n            throw e;\r\n        } catch (IOException e) {\r\n            LOG.warn(\"Failed to get file status for [{}], retry time [{}], \" + \"exception [{}]\", f, retryTime, e);\r\n            try {\r\n                Thread.sleep(OBSCommonUtils.DELAY_TIME);\r\n            } catch (InterruptedException ie) {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    return innerGetFileStatus(f);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "innerGetFileStatus",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "OBSFileStatus innerGetFileStatus(final Path f) throws IOException\n{\r\n    if (enablePosix) {\r\n        return OBSPosixBucketUtils.innerFsGetObjectStatus(this, f);\r\n    }\r\n    return OBSObjectBucketUtils.innerGetObjectStatus(this, f);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getContentSummary",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "ContentSummary getContentSummary(final Path f) throws FileNotFoundException, IOException\n{\r\n    if (!obsContentSummaryEnable) {\r\n        return super.getContentSummary(f);\r\n    }\r\n    FileStatus status = getFileStatus(f);\r\n    if (status.isFile()) {\r\n        long length = status.getLen();\r\n        return new ContentSummary.Builder().length(length).fileCount(1).directoryCount(0).spaceConsumed(length).build();\r\n    }\r\n    if (enablePosix) {\r\n        return OBSPosixBucketUtils.fsGetDirectoryContentSummary(this, OBSCommonUtils.pathToKey(this, f));\r\n    } else {\r\n        return OBSObjectBucketUtils.getDirectoryContentSummary(this, OBSCommonUtils.pathToKey(this, f));\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "copyFromLocalFile",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void copyFromLocalFile(final boolean delSrc, final boolean overwrite, final Path src, final Path dst) throws FileAlreadyExistsException, IOException\n{\r\n    try {\r\n        super.copyFromLocalFile(delSrc, overwrite, src, dst);\r\n    } catch (ObsException e) {\r\n        throw OBSCommonUtils.translateException(\"copyFromLocalFile(\" + src + \", \" + dst + \")\", src, e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "close",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void close() throws IOException\n{\r\n    LOG.debug(\"This Filesystem closed by user, clear resource.\");\r\n    if (closed.getAndSet(true)) {\r\n        return;\r\n    }\r\n    try {\r\n        super.close();\r\n    } finally {\r\n        OBSCommonUtils.shutdownAll(boundedMultipartUploadThreadPool, boundedCopyThreadPool, boundedDeleteThreadPool, boundedCopyPartThreadPool, boundedListThreadPool);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getCanonicalServiceName",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getCanonicalServiceName()\n{\r\n    return null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getCopyPartSize",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "long getCopyPartSize()\n{\r\n    return copyPartSize;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getBoundedCopyPartThreadPool",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "ThreadPoolExecutor getBoundedCopyPartThreadPool()\n{\r\n    return boundedCopyPartThreadPool;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getBoundedCopyThreadPool",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "ThreadPoolExecutor getBoundedCopyThreadPool()\n{\r\n    return boundedCopyThreadPool;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getDefaultBlockSize",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "long getDefaultBlockSize()\n{\r\n    return blockSize;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getDefaultBlockSize",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "long getDefaultBlockSize(final Path f)\n{\r\n    return blockSize;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "toString",
  "errType" : null,
  "containingMethodsNum" : 14,
  "sourceCodeText" : "String toString()\n{\r\n    final StringBuilder sb = new StringBuilder(\"OBSFileSystem{\");\r\n    sb.append(\"uri=\").append(uri);\r\n    sb.append(\", workingDir=\").append(workingDir);\r\n    sb.append(\", partSize=\").append(partSize);\r\n    sb.append(\", enableMultiObjectsDelete=\").append(enableMultiObjectDelete);\r\n    sb.append(\", maxKeys=\").append(maxKeys);\r\n    if (cannedACL != null) {\r\n        sb.append(\", cannedACL=\").append(cannedACL.toString());\r\n    }\r\n    sb.append(\", readAheadRange=\").append(readAheadRange);\r\n    sb.append(\", blockSize=\").append(getDefaultBlockSize());\r\n    if (blockFactory != null) {\r\n        sb.append(\", blockFactory=\").append(blockFactory);\r\n    }\r\n    sb.append(\", boundedMultipartUploadThreadPool=\").append(boundedMultipartUploadThreadPool);\r\n    sb.append(\", statistics {\").append(statistics).append(\"}\");\r\n    sb.append(\", metrics {\").append(\"}\");\r\n    sb.append('}');\r\n    return sb.toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getMaxKeys",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "int getMaxKeys()\n{\r\n    return maxKeys;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "listFiles",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 11,
  "sourceCodeText" : "RemoteIterator<LocatedFileStatus> listFiles(final Path f, final boolean recursive) throws FileNotFoundException, IOException\n{\r\n    Path path = OBSCommonUtils.qualify(this, f);\r\n    LOG.debug(\"listFiles({}, {})\", path, recursive);\r\n    try {\r\n        final FileStatus fileStatus = getFileStatus(path);\r\n        if (fileStatus.isFile()) {\r\n            LOG.debug(\"Path is a file\");\r\n            return new OBSListing.SingleStatusRemoteIterator(OBSCommonUtils.toLocatedFileStatus(this, fileStatus));\r\n        } else {\r\n            LOG.debug(\"listFiles: doing listFiles of directory {} - recursive {}\", path, recursive);\r\n            String key = OBSCommonUtils.maybeAddTrailingSlash(OBSCommonUtils.pathToKey(this, path));\r\n            String delimiter = recursive ? null : \"/\";\r\n            LOG.debug(\"Requesting all entries under {} with delimiter '{}'\", key, delimiter);\r\n            return obsListing.createLocatedFileStatusIterator(obsListing.createFileStatusListingIterator(path, OBSCommonUtils.createListObjectsRequest(this, key, delimiter), OBSListing.ACCEPT_ALL, new OBSListing.AcceptFilesOnly(path)));\r\n        }\r\n    } catch (ObsException e) {\r\n        throw OBSCommonUtils.translateException(\"listFiles\", path, e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "listLocatedStatus",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "RemoteIterator<LocatedFileStatus> listLocatedStatus(final Path f) throws FileNotFoundException, IOException\n{\r\n    return listLocatedStatus(f, OBSListing.ACCEPT_ALL);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "listLocatedStatus",
  "errType" : [ "ObsException" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "RemoteIterator<LocatedFileStatus> listLocatedStatus(final Path f, final PathFilter filter) throws FileNotFoundException, IOException\n{\r\n    Path path = OBSCommonUtils.qualify(this, f);\r\n    LOG.debug(\"listLocatedStatus({}, {}\", path, filter);\r\n    try {\r\n        final FileStatus fileStatus = getFileStatus(path);\r\n        if (fileStatus.isFile()) {\r\n            LOG.debug(\"Path is a file\");\r\n            return new OBSListing.SingleStatusRemoteIterator(filter.accept(path) ? OBSCommonUtils.toLocatedFileStatus(this, fileStatus) : null);\r\n        } else {\r\n            String key = OBSCommonUtils.maybeAddTrailingSlash(OBSCommonUtils.pathToKey(this, path));\r\n            return obsListing.createLocatedFileStatusIterator(obsListing.createFileStatusListingIterator(path, OBSCommonUtils.createListObjectsRequest(this, key, \"/\"), filter, new OBSListing.AcceptAllButSelfAndS3nDirs(path)));\r\n        }\r\n    } catch (ObsException e) {\r\n        throw OBSCommonUtils.translateException(\"listLocatedStatus\", path, e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getSse",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "SseWrapper getSse()\n{\r\n    return sse;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "increaseLevelStats",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void increaseLevelStats(final List<LevelStats> levelStatsList, final int level, final boolean isDir)\n{\r\n    int currMaxLevel = levelStatsList.size() - 1;\r\n    if (currMaxLevel < level) {\r\n        for (int i = 0; i < level - currMaxLevel; i++) {\r\n            levelStatsList.add(new LevelStats(currMaxLevel + 1 + i));\r\n        }\r\n    }\r\n    if (isDir) {\r\n        levelStatsList.get(level).increaseDirNum();\r\n    } else {\r\n        levelStatsList.get(level).increaseFileNum();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fsDFSListNextBatch",
  "errType" : null,
  "containingMethodsNum" : 15,
  "sourceCodeText" : "String fsDFSListNextBatch(final OBSFileSystem owner, final Stack<ListEntity> listStack, final Queue<ListEntity> resultQueue, final String marker, final int maxKeyNum, final List<ObsObject> objectSummaries, final List<LevelStats> levelStatsList) throws IOException\n{\r\n    if (marker != null) {\r\n        if (resultQueue.isEmpty()) {\r\n            throw new IllegalArgumentException(\"result queue is empty, but marker is not empty: \" + marker);\r\n        } else if (resultQueue.peek().getType() == ListEntityType.LIST_TAIL) {\r\n            throw new RuntimeException(\"cannot put list tail (\" + resultQueue.peek() + \") into result queue\");\r\n        } else if (!marker.equals(resultQueue.peek().getType() == ListEntityType.COMMON_PREFIX ? resultQueue.peek().getCommonPrefix() : resultQueue.peek().getObjectSummary().getObjectKey())) {\r\n            throw new IllegalArgumentException(\"marker (\" + marker + \") does not match with result queue peek (\" + resultQueue.peek() + \")\");\r\n        }\r\n    }\r\n    int resultNum = fetchListResultLocally(owner.getBucket(), resultQueue, maxKeyNum, objectSummaries, levelStatsList);\r\n    fetchListResultRemotely(owner, listStack, resultQueue, maxKeyNum, objectSummaries, levelStatsList, resultNum);\r\n    if (!listStack.empty() && resultQueue.isEmpty()) {\r\n        throw new RuntimeException(\"result queue is empty, but list stack is not empty: \" + listStack);\r\n    }\r\n    String nextMarker = null;\r\n    if (!resultQueue.isEmpty()) {\r\n        if (resultQueue.peek().getType() == ListEntityType.LIST_TAIL) {\r\n            throw new RuntimeException(\"cannot put list tail (\" + resultQueue.peek() + \") into result queue\");\r\n        } else {\r\n            nextMarker = resultQueue.peek().getType() == ListEntityType.COMMON_PREFIX ? resultQueue.peek().getCommonPrefix() : resultQueue.peek().getObjectSummary().getObjectKey();\r\n        }\r\n    }\r\n    return nextMarker;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fetchListResultRemotely",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void fetchListResultRemotely(final OBSFileSystem owner, final Stack<ListEntity> listStack, final Queue<ListEntity> resultQueue, final int maxKeyNum, final List<ObsObject> objectSummaries, final List<LevelStats> levelStatsList, final int resultNum) throws IOException\n{\r\n    int newResultNum = resultNum;\r\n    while (!listStack.empty() && (newResultNum < maxKeyNum || resultQueue.isEmpty())) {\r\n        List<ListObjectsRequest> oneLevelListRequests = new ArrayList<>();\r\n        List<Future<ObjectListing>> oneLevelListFutures = new ArrayList<>();\r\n        List<Integer> levels = new ArrayList<>();\r\n        List<ObjectListing> oneLevelObjectListings = new ArrayList<>();\r\n        submitOneLevelListTasks(owner, listStack, maxKeyNum, oneLevelListRequests, oneLevelListFutures, levels);\r\n        waitForOneLevelListTasksFinished(oneLevelListRequests, oneLevelListFutures, oneLevelObjectListings);\r\n        newResultNum = handleOneLevelListTaskResult(resultQueue, maxKeyNum, objectSummaries, levelStatsList, newResultNum, oneLevelListRequests, levels, oneLevelObjectListings);\r\n        addNewListStackEntities(listStack, oneLevelListRequests, levels, oneLevelObjectListings);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "handleOneLevelListTaskResult",
  "errType" : null,
  "containingMethodsNum" : 18,
  "sourceCodeText" : "int handleOneLevelListTaskResult(final Queue<ListEntity> resultQueue, final int maxKeyNum, final List<ObsObject> objectSummaries, final List<LevelStats> levelStatsList, final int resultNum, final List<ListObjectsRequest> oneLevelListRequests, final List<Integer> levels, final List<ObjectListing> oneLevelObjectListings)\n{\r\n    int newResultNum = resultNum;\r\n    for (int i = 0; i < oneLevelObjectListings.size(); i++) {\r\n        LOG.debug(\"one level listing with prefix=\" + oneLevelListRequests.get(i).getPrefix() + \", marker=\" + (oneLevelListRequests.get(i).getMarker() != null ? oneLevelListRequests.get(i).getMarker() : \"\"));\r\n        ObjectListing oneLevelObjectListing = oneLevelObjectListings.get(i);\r\n        LOG.debug(\"# of CommonPrefixes/Objects: {}/{}\", oneLevelObjectListing.getCommonPrefixes().size(), oneLevelObjectListing.getObjects().size());\r\n        if (oneLevelObjectListing.getCommonPrefixes().isEmpty() && oneLevelObjectListing.getObjects().isEmpty()) {\r\n            continue;\r\n        }\r\n        for (String commonPrefix : oneLevelObjectListing.getCommonPrefixes()) {\r\n            if (commonPrefix.equals(oneLevelListRequests.get(i).getPrefix())) {\r\n                continue;\r\n            }\r\n            LOG.debug(\"common prefix: \" + commonPrefix);\r\n            if (newResultNum < maxKeyNum) {\r\n                addCommonPrefixIntoObjectList(oneLevelListRequests.get(i).getBucketName(), objectSummaries, commonPrefix);\r\n                increaseLevelStats(levelStatsList, levels.get(i), true);\r\n                newResultNum++;\r\n            } else {\r\n                resultQueue.add(new ListEntity(commonPrefix, levels.get(i)));\r\n            }\r\n        }\r\n        for (ObsObject obj : oneLevelObjectListing.getObjects()) {\r\n            if (obj.getObjectKey().equals(oneLevelListRequests.get(i).getPrefix())) {\r\n                continue;\r\n            }\r\n            LOG.debug(\"object: {}, size: {}\", obj.getObjectKey(), obj.getMetadata().getContentLength());\r\n            if (newResultNum < maxKeyNum) {\r\n                objectSummaries.add(obj);\r\n                increaseLevelStats(levelStatsList, levels.get(i), obj.getObjectKey().endsWith(\"/\"));\r\n                newResultNum++;\r\n            } else {\r\n                resultQueue.add(new ListEntity(obj, levels.get(i)));\r\n            }\r\n        }\r\n    }\r\n    return newResultNum;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "waitForOneLevelListTasksFinished",
  "errType" : [ "InterruptedException", "ExecutionException" ],
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void waitForOneLevelListTasksFinished(final List<ListObjectsRequest> oneLevelListRequests, final List<Future<ObjectListing>> oneLevelListFutures, final List<ObjectListing> oneLevelObjectListings) throws IOException\n{\r\n    for (int i = 0; i < oneLevelListFutures.size(); i++) {\r\n        try {\r\n            oneLevelObjectListings.add(oneLevelListFutures.get(i).get());\r\n        } catch (InterruptedException e) {\r\n            LOG.warn(\"Interrupted while listing using DFS, prefix=\" + oneLevelListRequests.get(i).getPrefix() + \", marker=\" + (oneLevelListRequests.get(i).getMarker() != null ? oneLevelListRequests.get(i).getMarker() : \"\"));\r\n            throw new InterruptedIOException(\"Interrupted while listing using DFS, prefix=\" + oneLevelListRequests.get(i).getPrefix() + \", marker=\" + (oneLevelListRequests.get(i).getMarker() != null ? oneLevelListRequests.get(i).getMarker() : \"\"));\r\n        } catch (ExecutionException e) {\r\n            LOG.error(\"Exception while listing using DFS, prefix=\" + oneLevelListRequests.get(i).getPrefix() + \", marker=\" + (oneLevelListRequests.get(i).getMarker() != null ? oneLevelListRequests.get(i).getMarker() : \"\"), e);\r\n            for (Future<ObjectListing> future : oneLevelListFutures) {\r\n                future.cancel(true);\r\n            }\r\n            throw OBSCommonUtils.extractException(\"Listing using DFS with exception, marker=\" + (oneLevelListRequests.get(i).getMarker() != null ? oneLevelListRequests.get(i).getMarker() : \"\"), oneLevelListRequests.get(i).getPrefix(), e);\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "submitOneLevelListTasks",
  "errType" : null,
  "containingMethodsNum" : 20,
  "sourceCodeText" : "void submitOneLevelListTasks(final OBSFileSystem owner, final Stack<ListEntity> listStack, final int maxKeyNum, final List<ListObjectsRequest> oneLevelListRequests, final List<Future<ObjectListing>> oneLevelListFutures, final List<Integer> levels)\n{\r\n    for (int i = 0; i < owner.getListParallelFactor() && !listStack.empty(); i++) {\r\n        ListEntity listEntity = listStack.pop();\r\n        if (listEntity.getType() == ListEntityType.LIST_TAIL) {\r\n            if (listEntity.getNextMarker() != null) {\r\n                ListObjectsRequest oneLevelListRequest = new ListObjectsRequest();\r\n                oneLevelListRequest.setBucketName(owner.getBucket());\r\n                oneLevelListRequest.setPrefix(listEntity.getPrefix());\r\n                oneLevelListRequest.setMarker(listEntity.getNextMarker());\r\n                oneLevelListRequest.setMaxKeys(Math.min(maxKeyNum, owner.getMaxKeys()));\r\n                oneLevelListRequest.setDelimiter(\"/\");\r\n                oneLevelListRequests.add(oneLevelListRequest);\r\n                oneLevelListFutures.add(owner.getBoundedListThreadPool().submit(() -> OBSCommonUtils.commonContinueListObjects(owner, oneLevelListRequest)));\r\n                levels.add(listEntity.getLevel());\r\n            }\r\n            break;\r\n        } else {\r\n            String oneLevelListPrefix = listEntity.getType() == ListEntityType.COMMON_PREFIX ? listEntity.getCommonPrefix() : listEntity.getObjectSummary().getObjectKey();\r\n            ListObjectsRequest oneLevelListRequest = OBSCommonUtils.createListObjectsRequest(owner, oneLevelListPrefix, \"/\", maxKeyNum);\r\n            oneLevelListRequests.add(oneLevelListRequest);\r\n            oneLevelListFutures.add(owner.getBoundedListThreadPool().submit(() -> OBSCommonUtils.commonListObjects(owner, oneLevelListRequest)));\r\n            levels.add(listEntity.getLevel() + 1);\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "addNewListStackEntities",
  "errType" : null,
  "containingMethodsNum" : 16,
  "sourceCodeText" : "void addNewListStackEntities(final Stack<ListEntity> listStack, final List<ListObjectsRequest> oneLevelListRequests, final List<Integer> levels, final List<ObjectListing> oneLevelObjectListings)\n{\r\n    for (int i = oneLevelObjectListings.size() - 1; i >= 0; i--) {\r\n        ObjectListing oneLevelObjectListing = oneLevelObjectListings.get(i);\r\n        if (oneLevelObjectListing.getCommonPrefixes().isEmpty() && oneLevelObjectListing.getObjects().isEmpty()) {\r\n            continue;\r\n        }\r\n        listStack.push(new ListEntity(oneLevelObjectListing.getPrefix(), oneLevelObjectListing.isTruncated() ? oneLevelObjectListing.getNextMarker() : null, levels.get(i)));\r\n        ListIterator<String> commonPrefixListIterator = oneLevelObjectListing.getCommonPrefixes().listIterator(oneLevelObjectListing.getCommonPrefixes().size());\r\n        while (commonPrefixListIterator.hasPrevious()) {\r\n            String commonPrefix = commonPrefixListIterator.previous();\r\n            if (commonPrefix.equals(oneLevelListRequests.get(i).getPrefix())) {\r\n                continue;\r\n            }\r\n            listStack.push(new ListEntity(commonPrefix, levels.get(i)));\r\n        }\r\n        ListIterator<ObsObject> objectSummaryListIterator = oneLevelObjectListing.getObjects().listIterator(oneLevelObjectListing.getObjects().size());\r\n        while (objectSummaryListIterator.hasPrevious()) {\r\n            ObsObject objectSummary = objectSummaryListIterator.previous();\r\n            if (objectSummary.getObjectKey().equals(oneLevelListRequests.get(i).getPrefix())) {\r\n                continue;\r\n            }\r\n            if (objectSummary.getObjectKey().endsWith(\"/\")) {\r\n                listStack.push(new ListEntity(objectSummary, levels.get(i)));\r\n            }\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fetchListResultLocally",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "int fetchListResultLocally(final String bucketName, final Queue<ListEntity> resultQueue, final int maxKeyNum, final List<ObsObject> objectSummaries, final List<LevelStats> levelStatsList)\n{\r\n    int resultNum = 0;\r\n    while (!resultQueue.isEmpty() && resultNum < maxKeyNum) {\r\n        ListEntity listEntity = resultQueue.poll();\r\n        if (listEntity.getType() == ListEntityType.LIST_TAIL) {\r\n            throw new RuntimeException(\"cannot put list tail (\" + listEntity + \") into result queue\");\r\n        } else if (listEntity.getType() == ListEntityType.COMMON_PREFIX) {\r\n            addCommonPrefixIntoObjectList(bucketName, objectSummaries, listEntity.getCommonPrefix());\r\n            increaseLevelStats(levelStatsList, listEntity.getLevel(), true);\r\n            resultNum++;\r\n        } else {\r\n            objectSummaries.add(listEntity.getObjectSummary());\r\n            increaseLevelStats(levelStatsList, listEntity.getLevel(), listEntity.getObjectSummary().getObjectKey().endsWith(\"/\"));\r\n            resultNum++;\r\n        }\r\n    }\r\n    return resultNum;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "addCommonPrefixIntoObjectList",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void addCommonPrefixIntoObjectList(final String bucketName, final List<ObsObject> objectSummaries, final String commonPrefix)\n{\r\n    ObsObject objectSummary = new ObsObject();\r\n    ObjectMetadata objectMetadata = new ObjectMetadata();\r\n    objectMetadata.setContentLength(0L);\r\n    objectSummary.setBucketName(bucketName);\r\n    objectSummary.setObjectKey(commonPrefix);\r\n    objectSummary.setMetadata(objectMetadata);\r\n    objectSummaries.add(objectSummary);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fsDFSListObjects",
  "errType" : null,
  "containingMethodsNum" : 13,
  "sourceCodeText" : "OBSFsDFSListing fsDFSListObjects(final OBSFileSystem owner, final ListObjectsRequest request) throws IOException\n{\r\n    List<ObsObject> objectSummaries = new ArrayList<>();\r\n    List<String> commonPrefixes = new ArrayList<>();\r\n    String bucketName = owner.getBucket();\r\n    String prefix = request.getPrefix();\r\n    int maxKeyNum = request.getMaxKeys();\r\n    if (request.getDelimiter() != null) {\r\n        throw new IllegalArgumentException(\"illegal delimiter: \" + request.getDelimiter());\r\n    }\r\n    if (request.getMarker() != null) {\r\n        throw new IllegalArgumentException(\"illegal marker: \" + request.getMarker());\r\n    }\r\n    Stack<ListEntity> listStack = new Stack<>();\r\n    Queue<ListEntity> resultQueue = new LinkedList<>();\r\n    List<LevelStats> levelStatsList = new ArrayList<>();\r\n    listStack.push(new ListEntity(prefix, 0));\r\n    increaseLevelStats(levelStatsList, 0, true);\r\n    String nextMarker = fsDFSListNextBatch(owner, listStack, resultQueue, null, maxKeyNum, objectSummaries, levelStatsList);\r\n    if (nextMarker == null) {\r\n        StringBuilder levelStatsStringBuilder = new StringBuilder();\r\n        levelStatsStringBuilder.append(\"bucketName=\").append(bucketName).append(\", prefix=\").append(prefix).append(\": \");\r\n        for (LevelStats levelStats : levelStatsList) {\r\n            levelStatsStringBuilder.append(\"level=\").append(levelStats.getLevel()).append(\", dirNum=\").append(levelStats.getDirNum()).append(\", fileNum=\").append(levelStats.getFileNum()).append(\"; \");\r\n        }\r\n        LOG.debug(\"[list level statistics info] \" + levelStatsStringBuilder.toString());\r\n    }\r\n    return new OBSFsDFSListing(request, objectSummaries, commonPrefixes, nextMarker, listStack, resultQueue, levelStatsList);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "fsDFSContinueListObjects",
  "errType" : null,
  "containingMethodsNum" : 13,
  "sourceCodeText" : "OBSFsDFSListing fsDFSContinueListObjects(final OBSFileSystem owner, final OBSFsDFSListing obsFsDFSListing) throws IOException\n{\r\n    List<ObsObject> objectSummaries = new ArrayList<>();\r\n    List<String> commonPrefixes = new ArrayList<>();\r\n    String bucketName = owner.getBucket();\r\n    String prefix = obsFsDFSListing.getPrefix();\r\n    String marker = obsFsDFSListing.getNextMarker();\r\n    int maxKeyNum = obsFsDFSListing.getMaxKeys();\r\n    if (obsFsDFSListing.getDelimiter() != null) {\r\n        throw new IllegalArgumentException(\"illegal delimiter: \" + obsFsDFSListing.getDelimiter());\r\n    }\r\n    Stack<ListEntity> listStack = obsFsDFSListing.getListStack();\r\n    Queue<ListEntity> resultQueue = obsFsDFSListing.getResultQueue();\r\n    List<LevelStats> levelStatsList = obsFsDFSListing.getLevelStatsList();\r\n    String nextMarker = fsDFSListNextBatch(owner, listStack, resultQueue, marker, maxKeyNum, objectSummaries, levelStatsList);\r\n    if (nextMarker == null) {\r\n        StringBuilder levelStatsStringBuilder = new StringBuilder();\r\n        levelStatsStringBuilder.append(\"bucketName=\").append(bucketName).append(\", prefix=\").append(prefix).append(\": \");\r\n        for (LevelStats levelStats : levelStatsList) {\r\n            levelStatsStringBuilder.append(\"level=\").append(levelStats.getLevel()).append(\", dirNum=\").append(levelStats.getDirNum()).append(\", fileNum=\").append(levelStats.getFileNum()).append(\"; \");\r\n        }\r\n        LOG.debug(\"[list level statistics info] \" + levelStatsStringBuilder.toString());\r\n    }\r\n    return new OBSFsDFSListing(obsFsDFSListing, objectSummaries, commonPrefixes, nextMarker, listStack, resultQueue, levelStatsList);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getListStack",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Stack<ListEntity> getListStack()\n{\r\n    return listStack;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getResultQueue",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Queue<ListEntity> getResultQueue()\n{\r\n    return resultQueue;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getLevelStatsList",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "List<LevelStats> getLevelStatsList()\n{\r\n    return levelStatsList;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "createFileStatusListingIterator",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "FileStatusListingIterator createFileStatusListingIterator(final Path listPath, final ListObjectsRequest request, final PathFilter filter, final FileStatusAcceptor acceptor) throws IOException\n{\r\n    return new FileStatusListingIterator(new ObjectListingIterator(listPath, request), filter, acceptor);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "createLocatedFileStatusIterator",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "LocatedFileStatusIterator createLocatedFileStatusIterator(final RemoteIterator<FileStatus> statusIterator)\n{\r\n    return new LocatedFileStatusIterator(statusIterator);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getExitCode",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean getExitCode()\n{\r\n    return exitCode;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "withExitCode",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "RenameFailedException withExitCode(final boolean code)\n{\r\n    this.exitCode = code;\r\n    return this;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getUriDefaultPort",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "int getUriDefaultPort()\n{\r\n    return OBSConstants.OBS_DEFAULT_PORT;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getCause",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "ObsException getCause()\n{\r\n    return (ObsException) super.getCause();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "getMessage",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String getMessage()\n{\r\n    return operation + \": \" + getCause().getErrorMessage() + \", detailMessage: \" + super.getMessage();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "initConnectionSettings",
  "errType" : null,
  "containingMethodsNum" : 25,
  "sourceCodeText" : "void initConnectionSettings(final Configuration conf, final ExtObsConfiguration obsConf)\n{\r\n    obsConf.setMaxConnections(OBSCommonUtils.intOption(conf, OBSConstants.MAXIMUM_CONNECTIONS, OBSConstants.DEFAULT_MAXIMUM_CONNECTIONS, 1));\r\n    boolean secureConnections = conf.getBoolean(OBSConstants.SECURE_CONNECTIONS, OBSConstants.DEFAULT_SECURE_CONNECTIONS);\r\n    obsConf.setHttpsOnly(secureConnections);\r\n    obsConf.setMaxErrorRetry(OBSCommonUtils.intOption(conf, OBSConstants.MAX_ERROR_RETRIES, OBSConstants.DEFAULT_MAX_ERROR_RETRIES, 0));\r\n    obsConf.setConnectionTimeout(OBSCommonUtils.intOption(conf, OBSConstants.ESTABLISH_TIMEOUT, OBSConstants.DEFAULT_ESTABLISH_TIMEOUT, 0));\r\n    obsConf.setSocketTimeout(OBSCommonUtils.intOption(conf, OBSConstants.SOCKET_TIMEOUT, OBSConstants.DEFAULT_SOCKET_TIMEOUT, 0));\r\n    obsConf.setIdleConnectionTime(OBSCommonUtils.intOption(conf, OBSConstants.IDLE_CONNECTION_TIME, OBSConstants.DEFAULT_IDLE_CONNECTION_TIME, 1));\r\n    obsConf.setMaxIdleConnections(OBSCommonUtils.intOption(conf, OBSConstants.MAX_IDLE_CONNECTIONS, OBSConstants.DEFAULT_MAX_IDLE_CONNECTIONS, 1));\r\n    obsConf.setReadBufferSize(OBSCommonUtils.intOption(conf, OBSConstants.READ_BUFFER_SIZE, OBSConstants.DEFAULT_READ_BUFFER_SIZE, -1));\r\n    obsConf.setWriteBufferSize(OBSCommonUtils.intOption(conf, OBSConstants.WRITE_BUFFER_SIZE, OBSConstants.DEFAULT_WRITE_BUFFER_SIZE, -1));\r\n    obsConf.setUploadStreamRetryBufferSize(OBSCommonUtils.intOption(conf, OBSConstants.UPLOAD_STREAM_RETRY_SIZE, OBSConstants.DEFAULT_UPLOAD_STREAM_RETRY_SIZE, 1));\r\n    obsConf.setSocketReadBufferSize(OBSCommonUtils.intOption(conf, OBSConstants.SOCKET_RECV_BUFFER, OBSConstants.DEFAULT_SOCKET_RECV_BUFFER, -1));\r\n    obsConf.setSocketWriteBufferSize(OBSCommonUtils.intOption(conf, OBSConstants.SOCKET_SEND_BUFFER, OBSConstants.DEFAULT_SOCKET_SEND_BUFFER, -1));\r\n    obsConf.setKeepAlive(conf.getBoolean(OBSConstants.KEEP_ALIVE, OBSConstants.DEFAULT_KEEP_ALIVE));\r\n    obsConf.setValidateCertificate(conf.getBoolean(OBSConstants.VALIDATE_CERTIFICATE, OBSConstants.DEFAULT_VALIDATE_CERTIFICATE));\r\n    obsConf.setVerifyResponseContentType(conf.getBoolean(OBSConstants.VERIFY_RESPONSE_CONTENT_TYPE, OBSConstants.DEFAULT_VERIFY_RESPONSE_CONTENT_TYPE));\r\n    obsConf.setCname(conf.getBoolean(OBSConstants.CNAME, OBSConstants.DEFAULT_CNAME));\r\n    obsConf.setIsStrictHostnameVerification(conf.getBoolean(OBSConstants.STRICT_HOSTNAME_VERIFICATION, OBSConstants.DEFAULT_STRICT_HOSTNAME_VERIFICATION));\r\n    obsConf.setAuthTypeNegotiation(conf.getBoolean(OBSConstants.SDK_AUTH_TYPE_NEGOTIATION_ENABLE, OBSConstants.DEFAULT_SDK_AUTH_TYPE_NEGOTIATION_ENABLE));\r\n    if (!obsConf.isAuthTypeNegotiation()) {\r\n        obsConf.setAuthType(AuthTypeEnum.OBS);\r\n    }\r\n    obsConf.retryOnConnectionFailureInOkhttp(conf.getBoolean(OBSConstants.SDK_RETRY_ON_CONNECTION_FAILURE_ENABLE, OBSConstants.DEFAULT_SDK_RETRY_ON_CONNECTION_FAILURE_ENABLE));\r\n    int retryTime = conf.getInt(OBSConstants.SDK_RETRY_TIMES_ON_UNEXPECTED_END_EXCEPTION, OBSConstants.DEFAULT_SDK_RETRY_TIMES_ON_UNEXPECTED_END_EXCEPTION);\r\n    if (retryTime > 0 && retryTime < OBSConstants.DEFAULT_MAX_SDK_CONNECTION_RETRY_TIMES || !obsConf.isRetryOnConnectionFailureInOkhttp() && retryTime < 0) {\r\n        retryTime = OBSConstants.DEFAULT_MAX_SDK_CONNECTION_RETRY_TIMES;\r\n    }\r\n    obsConf.setMaxRetryOnUnexpectedEndException(retryTime);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "initProxySupport",
  "errType" : null,
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void initProxySupport(final Configuration conf, final ExtObsConfiguration obsConf) throws IllegalArgumentException, IOException\n{\r\n    String proxyHost = conf.getTrimmed(OBSConstants.PROXY_HOST, \"\");\r\n    int proxyPort = conf.getInt(OBSConstants.PROXY_PORT, -1);\r\n    if (!proxyHost.isEmpty() && proxyPort < 0) {\r\n        if (conf.getBoolean(OBSConstants.SECURE_CONNECTIONS, OBSConstants.DEFAULT_SECURE_CONNECTIONS)) {\r\n            LOG.warn(\"Proxy host set without port. Using HTTPS default \" + OBSConstants.DEFAULT_HTTPS_PORT);\r\n            obsConf.getHttpProxy().setProxyPort(OBSConstants.DEFAULT_HTTPS_PORT);\r\n        } else {\r\n            LOG.warn(\"Proxy host set without port. Using HTTP default \" + OBSConstants.DEFAULT_HTTP_PORT);\r\n            obsConf.getHttpProxy().setProxyPort(OBSConstants.DEFAULT_HTTP_PORT);\r\n        }\r\n    }\r\n    String proxyUsername = conf.getTrimmed(OBSConstants.PROXY_USERNAME);\r\n    String proxyPassword = null;\r\n    char[] proxyPass = conf.getPassword(OBSConstants.PROXY_PASSWORD);\r\n    if (proxyPass != null) {\r\n        proxyPassword = new String(proxyPass).trim();\r\n    }\r\n    if ((proxyUsername == null) != (proxyPassword == null)) {\r\n        String msg = \"Proxy error: \" + OBSConstants.PROXY_USERNAME + \" or \" + OBSConstants.PROXY_PASSWORD + \" set without the other.\";\r\n        LOG.error(msg);\r\n        throw new IllegalArgumentException(msg);\r\n    }\r\n    obsConf.setHttpProxy(proxyHost, proxyPort, proxyUsername, proxyPassword);\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"Using proxy server {}:{} as user {} on \" + \"domain {} as workstation {}\", obsConf.getHttpProxy().getProxyAddr(), obsConf.getHttpProxy().getProxyPort(), obsConf.getHttpProxy().getProxyUName(), obsConf.getHttpProxy().getDomain(), obsConf.getHttpProxy().getWorkstation());\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "createHuaweiObsClient",
  "errType" : [ "RuntimeException", "NoSuchMethodException|SecurityException|IllegalAccessException|InstantiationException|InvocationTargetException" ],
  "containingMethodsNum" : 14,
  "sourceCodeText" : "ObsClient createHuaweiObsClient(final Configuration conf, final ObsConfiguration obsConf, final URI name) throws IOException\n{\r\n    Class<?> credentialsProviderClass;\r\n    BasicSessionCredential credentialsProvider;\r\n    ObsClient obsClient;\r\n    try {\r\n        credentialsProviderClass = conf.getClass(OBSConstants.OBS_CREDENTIALS_PROVIDER, null);\r\n    } catch (RuntimeException e) {\r\n        Throwable c = e.getCause() != null ? e.getCause() : e;\r\n        throw new IOException(\"From option \" + OBSConstants.OBS_CREDENTIALS_PROVIDER + ' ' + c, c);\r\n    }\r\n    if (credentialsProviderClass == null) {\r\n        return createObsClientWithoutCredentialsProvider(conf, obsConf, name);\r\n    }\r\n    try {\r\n        Constructor<?> cons = credentialsProviderClass.getDeclaredConstructor(URI.class, Configuration.class);\r\n        credentialsProvider = (BasicSessionCredential) cons.newInstance(name, conf);\r\n    } catch (NoSuchMethodException | SecurityException | IllegalAccessException | InstantiationException | InvocationTargetException e) {\r\n        Throwable c = e.getCause() != null ? e.getCause() : e;\r\n        throw new IOException(\"From option \" + OBSConstants.OBS_CREDENTIALS_PROVIDER + ' ' + c, c);\r\n    }\r\n    String sessionToken = credentialsProvider.getSessionToken();\r\n    String ak = credentialsProvider.getOBSAccessKeyId();\r\n    String sk = credentialsProvider.getOBSSecretKey();\r\n    String endPoint = conf.getTrimmed(OBSConstants.ENDPOINT, \"\");\r\n    obsConf.setEndPoint(endPoint);\r\n    if (sessionToken != null && sessionToken.length() != 0) {\r\n        obsClient = new ObsClient(ak, sk, sessionToken, obsConf);\r\n    } else {\r\n        obsClient = new ObsClient(ak, sk, obsConf);\r\n    }\r\n    return obsClient;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "createObsClientWithoutCredentialsProvider",
  "errType" : [ "RuntimeException", "NoSuchMethodException|IllegalAccessException|InstantiationException|InvocationTargetException|RuntimeException" ],
  "containingMethodsNum" : 18,
  "sourceCodeText" : "ObsClient createObsClientWithoutCredentialsProvider(final Configuration conf, final ObsConfiguration obsConf, final URI name) throws IOException\n{\r\n    ObsClient obsClient;\r\n    OBSLoginHelper.Login creds = OBSCommonUtils.getOBSAccessKeys(name, conf);\r\n    String ak = creds.getUser();\r\n    String sk = creds.getPassword();\r\n    String token = creds.getToken();\r\n    String endPoint = conf.getTrimmed(OBSConstants.ENDPOINT, \"\");\r\n    obsConf.setEndPoint(endPoint);\r\n    if (!StringUtils.isEmpty(ak) || !StringUtils.isEmpty(sk)) {\r\n        obsClient = new ObsClient(ak, sk, token, obsConf);\r\n        return obsClient;\r\n    }\r\n    Class<?> securityProviderClass;\r\n    try {\r\n        securityProviderClass = conf.getClass(OBSConstants.OBS_SECURITY_PROVIDER, null);\r\n        LOG.info(\"From option {} get {}\", OBSConstants.OBS_SECURITY_PROVIDER, securityProviderClass);\r\n    } catch (RuntimeException e) {\r\n        Throwable c = e.getCause() != null ? e.getCause() : e;\r\n        throw new IOException(\"From option \" + OBSConstants.OBS_SECURITY_PROVIDER + ' ' + c, c);\r\n    }\r\n    if (securityProviderClass == null) {\r\n        obsClient = new ObsClient(ak, sk, token, obsConf);\r\n        return obsClient;\r\n    }\r\n    IObsCredentialsProvider securityProvider;\r\n    try {\r\n        Optional<Constructor> cons = tryGetConstructor(securityProviderClass, new Class[] { URI.class, Configuration.class });\r\n        if (cons.isPresent()) {\r\n            securityProvider = (IObsCredentialsProvider) cons.get().newInstance(name, conf);\r\n        } else {\r\n            securityProvider = (IObsCredentialsProvider) securityProviderClass.getDeclaredConstructor().newInstance();\r\n        }\r\n    } catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException | RuntimeException e) {\r\n        Throwable c = e.getCause() != null ? e.getCause() : e;\r\n        throw new IOException(\"From option \" + OBSConstants.OBS_SECURITY_PROVIDER + ' ' + c, c);\r\n    }\r\n    obsClient = new ObsClient(securityProvider, obsConf);\r\n    return obsClient;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "tryGetConstructor",
  "errType" : [ "NoSuchMethodException" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "Optional<Constructor> tryGetConstructor(final Class mainClss, final Class[] args)\n{\r\n    try {\r\n        Constructor constructor = mainClss.getDeclaredConstructor(args);\r\n        return Optional.ofNullable(constructor);\r\n    } catch (NoSuchMethodException e) {\r\n        return Optional.empty();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-cloud-storage-project\\hadoop-huaweicloud\\src\\main\\java\\org\\apache\\hadoop\\fs\\obs",
  "methodName" : "createObsClient",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "ObsClient createObsClient(final URI name) throws IOException\n{\r\n    Configuration conf = getConf();\r\n    ExtObsConfiguration obsConf = new ExtObsConfiguration();\r\n    initConnectionSettings(conf, obsConf);\r\n    initProxySupport(conf, obsConf);\r\n    return createHuaweiObsClient(conf, obsConf, name);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
} ]