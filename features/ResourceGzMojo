[ {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\resourcegz",
  "methodName" : "execute",
  "errType" : [ "Throwable" ],
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void execute() throws MojoExecutionException, MojoFailureException\n{\r\n    try {\r\n        Path inputDir = new File(inputDirectory).toPath();\r\n        File outputDir = new File(outputDirectory);\r\n        List<String> exts = Arrays.asList(extensions.split(\",\"));\r\n        exts.replaceAll(String::trim);\r\n        GZConsumer cons = new GZConsumer(inputDir.toFile(), outputDir);\r\n        Files.walk(inputDir).filter(path -> {\r\n            for (String ext : exts) {\r\n                if (path.getFileName().toString().endsWith(\".\" + ext)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }).forEach(cons);\r\n        if (cons.getThrowable() != null) {\r\n            throw new MojoExecutionException(cons.getThrowable().toString(), cons.getThrowable());\r\n        }\r\n    } catch (Throwable t) {\r\n        throw new MojoExecutionException(t.toString(), t);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\shade\\resource",
  "methodName" : "canTransformResource",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean canTransformResource(String resource)\n{\r\n    if (resource.startsWith(SERVICES_PATH)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\shade\\resource",
  "methodName" : "processResource",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void processResource(String resource, InputStream is, List<Relocator> relocatorz) throws IOException\n{\r\n    ServiceStream out = serviceEntries.get(resource);\r\n    if (out == null) {\r\n        out = new ServiceStream();\r\n        serviceEntries.put(resource, out);\r\n    }\r\n    out.append(is);\r\n    is.close();\r\n    if (this.relocators == null) {\r\n        this.relocators = relocatorz;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\shade\\resource",
  "methodName" : "hasTransformedResource",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean hasTransformedResource()\n{\r\n    return serviceEntries.size() > 0;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\shade\\resource",
  "methodName" : "modifyOutputStream",
  "errType" : null,
  "containingMethodsNum" : 15,
  "sourceCodeText" : "void modifyOutputStream(JarOutputStream jos) throws IOException\n{\r\n    for (Map.Entry<String, ServiceStream> entry : serviceEntries.entrySet()) {\r\n        String key = entry.getKey();\r\n        ServiceStream data = entry.getValue();\r\n        if (relocators != null) {\r\n            key = key.substring(SERVICES_PATH.length() + 1);\r\n            for (Relocator relocator : relocators) {\r\n                if (relocator.canRelocateClass(key)) {\r\n                    key = relocator.relocateClass(key);\r\n                    break;\r\n                }\r\n            }\r\n            key = SERVICES_PATH + '/' + key;\r\n        }\r\n        jos.putNextEntry(new JarEntry(key));\r\n        PrintWriter writer = new PrintWriter(new OutputStreamWriter(jos, StandardCharsets.UTF_8));\r\n        InputStreamReader streamReader = new InputStreamReader(data.toInputStream(), StandardCharsets.UTF_8);\r\n        BufferedReader reader = new BufferedReader(streamReader);\r\n        String className;\r\n        while ((className = reader.readLine()) != null) {\r\n            if (relocators != null) {\r\n                for (Relocator relocator : relocators) {\r\n                    if (relocator.canRelocateClass(className)) {\r\n                        className = relocator.applyToSourceContent(className);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            writer.println(className);\r\n            writer.flush();\r\n        }\r\n        reader.close();\r\n        data.reset();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\paralleltests",
  "methodName" : "execute",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void execute() throws MojoExecutionException\n{\r\n    int numDirs = getTestsThreadCount();\r\n    mkParallelDirs(testBuildDir, numDirs);\r\n    mkParallelDirs(testBuildData, numDirs);\r\n    mkParallelDirs(hadoopTmpDir, numDirs);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\paralleltests",
  "methodName" : "getTestsThreadCount",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "int getTestsThreadCount()\n{\r\n    int threadCount = 1;\r\n    if (testsThreadCount != null) {\r\n        String trimProp = testsThreadCount.trim();\r\n        if (trimProp.endsWith(\"C\")) {\r\n            double multiplier = Double.parseDouble(trimProp.substring(0, trimProp.length() - 1));\r\n            double calculated = multiplier * ((double) Runtime.getRuntime().availableProcessors());\r\n            threadCount = calculated > 0d ? Math.max((int) calculated, 1) : 0;\r\n        } else {\r\n            threadCount = Integer.parseInt(testsThreadCount);\r\n        }\r\n    }\r\n    return threadCount;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\paralleltests",
  "methodName" : "mkParallelDirs",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void mkParallelDirs(File testDir, int numDirs) throws MojoExecutionException\n{\r\n    for (int i = 1; i <= numDirs; i++) {\r\n        File newDir = new File(testDir, String.valueOf(i));\r\n        if (!newDir.exists()) {\r\n            getLog().info(\"Creating \" + newDir.toString());\r\n            if (!newDir.mkdirs()) {\r\n                throw new MojoExecutionException(\"Unable to create \" + newDir.toString());\r\n            }\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\cmakebuilder",
  "methodName" : "validatePlatform",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void validatePlatform() throws MojoExecutionException\n{\r\n    if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).startsWith(\"windows\")) {\r\n        throw new MojoExecutionException(\"CMakeBuilder does not yet support \" + \"the Windows platform.\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\cmakebuilder",
  "methodName" : "writeStatusFile",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void writeStatusFile(String status) throws IOException\n{\r\n    FileOutputStream fos = new FileOutputStream(new File(results, testName + \".pstatus\"));\r\n    BufferedWriter out = null;\r\n    try {\r\n        out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\r\n        out.write(status + \"\\n\");\r\n    } finally {\r\n        if (out != null) {\r\n            out.close();\r\n        } else {\r\n            fos.close();\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\cmakebuilder",
  "methodName" : "isTruthy",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "boolean isTruthy(String str)\n{\r\n    if (str == null)\r\n        return false;\r\n    if (str.equalsIgnoreCase(\"\"))\r\n        return false;\r\n    if (str.equalsIgnoreCase(\"false\"))\r\n        return false;\r\n    if (str.equalsIgnoreCase(\"no\"))\r\n        return false;\r\n    if (str.equalsIgnoreCase(\"off\"))\r\n        return false;\r\n    if (str.equalsIgnoreCase(\"disable\"))\r\n        return false;\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\cmakebuilder",
  "methodName" : "validateParameters",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void validateParameters() throws MojoExecutionException\n{\r\n    if (!(expectedResult.equals(\"success\") || expectedResult.equals(\"failure\") || expectedResult.equals(\"any\"))) {\r\n        throw new MojoExecutionException(\"expectedResult must be either \" + \"success, failure, or any\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\cmakebuilder",
  "methodName" : "shouldRunTest",
  "errType" : null,
  "containingMethodsNum" : 19,
  "sourceCodeText" : "boolean shouldRunTest() throws MojoExecutionException\n{\r\n    String skipTests = session.getSystemProperties().getProperty(\"skipTests\");\r\n    if (isTruthy(skipTests)) {\r\n        getLog().info(\"skipTests is in effect for test \" + testName);\r\n        return false;\r\n    }\r\n    if (!binary.exists()) {\r\n        if (skipIfMissing) {\r\n            getLog().info(\"Skipping missing test \" + testName);\r\n            return false;\r\n        } else {\r\n            throw new MojoExecutionException(\"Test \" + binary + \" was not built!  (File does not exist.)\");\r\n        }\r\n    }\r\n    String testProp = session.getSystemProperties().getProperty(\"test\");\r\n    if (testProp != null) {\r\n        String[] testPropArr = testProp.split(\",\");\r\n        boolean found = false;\r\n        for (String test : testPropArr) {\r\n            if (test.equals(ALL_NATIVE)) {\r\n                found = true;\r\n                break;\r\n            }\r\n            if (test.equals(testName)) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            getLog().debug(\"did not find test '\" + testName + \"' in \" + \"list \" + testProp);\r\n            return false;\r\n        }\r\n    }\r\n    if (preconditions != null) {\r\n        int idx = 1;\r\n        for (Map.Entry<String, String> entry : preconditions.entrySet()) {\r\n            String key = entry.getKey();\r\n            String val = entry.getValue();\r\n            if (key == null) {\r\n                throw new MojoExecutionException(\"NULL is not a valid \" + \"precondition type.  \" + VALID_PRECONDITION_TYPES_STR);\r\n            }\r\n            if (key.equals(\"and\")) {\r\n                if (!isTruthy(val)) {\r\n                    getLog().info(\"Skipping test \" + testName + \" because precondition number \" + idx + \" was not met.\");\r\n                    return false;\r\n                }\r\n            } else if (key.equals(\"andNot\")) {\r\n                if (isTruthy(val)) {\r\n                    getLog().info(\"Skipping test \" + testName + \" because negative precondition number \" + idx + \" was met.\");\r\n                    return false;\r\n                }\r\n            } else {\r\n                throw new MojoExecutionException(key + \" is not a valid \" + \"precondition type.  \" + VALID_PRECONDITION_TYPES_STR);\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\cmakebuilder",
  "methodName" : "execute",
  "errType" : [ "IOException", "IOException", "InterruptedException", "InterruptedException", "Exception" ],
  "containingMethodsNum" : 42,
  "sourceCodeText" : "void execute() throws MojoExecutionException\n{\r\n    if (testName == null) {\r\n        testName = binary.getName();\r\n    }\r\n    validatePlatform();\r\n    validateParameters();\r\n    if (!shouldRunTest()) {\r\n        return;\r\n    }\r\n    if (!results.isDirectory()) {\r\n        if (!results.mkdirs()) {\r\n            throw new MojoExecutionException(\"Failed to create \" + \"output directory '\" + results + \"'!\");\r\n        }\r\n    }\r\n    List<String> cmd = new LinkedList<String>();\r\n    cmd.add(binary.getAbsolutePath());\r\n    getLog().info(\"-------------------------------------------------------\");\r\n    getLog().info(\" C M A K E B U I L D E R    T E S T\");\r\n    getLog().info(\"-------------------------------------------------------\");\r\n    StringBuilder bld = new StringBuilder();\r\n    bld.append(testName).append(\": running \");\r\n    bld.append(binary.getAbsolutePath());\r\n    for (String entry : args) {\r\n        cmd.add(entry);\r\n        bld.append(\" \").append(entry);\r\n    }\r\n    getLog().info(bld.toString());\r\n    ProcessBuilder pb = new ProcessBuilder(cmd);\r\n    Exec.addEnvironment(pb, env);\r\n    if (workingDirectory != null) {\r\n        pb.directory(workingDirectory);\r\n    }\r\n    pb.redirectError(new File(results, testName + \".stderr\"));\r\n    pb.redirectOutput(new File(results, testName + \".stdout\"));\r\n    getLog().info(\"with extra environment variables \" + Exec.envToString(env));\r\n    Process proc = null;\r\n    TestThread testThread = null;\r\n    int retCode = -1;\r\n    String status = \"IN_PROGRESS\";\r\n    try {\r\n        writeStatusFile(status);\r\n    } catch (IOException e) {\r\n        throw new MojoExecutionException(\"Error writing the status file\", e);\r\n    }\r\n    long start = System.nanoTime();\r\n    try {\r\n        proc = pb.start();\r\n        testThread = new TestThread(proc);\r\n        testThread.start();\r\n        testThread.join(timeout * 1000);\r\n        if (!testThread.isAlive()) {\r\n            retCode = testThread.retCode();\r\n            testThread = null;\r\n            proc = null;\r\n        }\r\n    } catch (IOException e) {\r\n        throw new MojoExecutionException(\"IOException while executing the test \" + testName, e);\r\n    } catch (InterruptedException e) {\r\n        throw new MojoExecutionException(\"Interrupted while executing \" + \"the test \" + testName, e);\r\n    } finally {\r\n        if (testThread != null) {\r\n            testThread.interrupt();\r\n            try {\r\n                testThread.join();\r\n            } catch (InterruptedException e) {\r\n                getLog().error(\"Interrupted while waiting for testThread\", e);\r\n            }\r\n            status = \"TIMED OUT\";\r\n        } else if (retCode == 0) {\r\n            status = \"SUCCESS\";\r\n        } else {\r\n            status = \"ERROR CODE \" + String.valueOf(retCode);\r\n        }\r\n        try {\r\n            writeStatusFile(status);\r\n        } catch (Exception e) {\r\n            getLog().error(\"failed to write status file!\", e);\r\n        }\r\n        if (proc != null) {\r\n            proc.destroy();\r\n        }\r\n    }\r\n    long end = System.nanoTime();\r\n    getLog().info(\"STATUS: \" + status + \" after \" + TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS) + \" millisecond(s).\");\r\n    getLog().info(\"-------------------------------------------------------\");\r\n    if (status.equals(\"TIMED_OUT\")) {\r\n        if (expectedResult.equals(\"success\")) {\r\n            throw new MojoExecutionException(\"Test \" + binary + \" timed out after \" + timeout + \" seconds!\");\r\n        }\r\n    } else if (!status.equals(\"SUCCESS\")) {\r\n        if (expectedResult.equals(\"success\")) {\r\n            throw new MojoExecutionException(\"Test \" + binary + \" returned \" + status);\r\n        }\r\n    } else if (expectedResult.equals(\"failure\")) {\r\n        throw new MojoExecutionException(\"Test \" + binary + \" succeeded, but we expected failure!\");\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 4,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\util",
  "methodName" : "getCommaSeparatedList",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String getCommaSeparatedList(List<String> list)\n{\r\n    StringBuilder buffer = new StringBuilder();\r\n    String separator = \"\";\r\n    for (Object e : list) {\r\n        buffer.append(separator).append(e);\r\n        separator = \",\";\r\n    }\r\n    return buffer.toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\util",
  "methodName" : "convertFileSetToFiles",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "List<File> convertFileSetToFiles(FileSet source) throws IOException\n{\r\n    String includes = getCommaSeparatedList(source.getIncludes());\r\n    String excludes = getCommaSeparatedList(source.getExcludes());\r\n    return FileUtils.getFiles(new File(source.getDirectory()), includes, excludes);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\versioninfo",
  "methodName" : "execute",
  "errType" : [ "Throwable" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void execute() throws MojoExecutionException\n{\r\n    try {\r\n        SCM scm = determineSCM();\r\n        project.getProperties().setProperty(buildTimeProperty, getBuildTime());\r\n        project.getProperties().setProperty(scmUriProperty, getSCMUri(scm));\r\n        project.getProperties().setProperty(scmBranchProperty, getSCMBranch(scm));\r\n        project.getProperties().setProperty(scmCommitProperty, getSCMCommit(scm));\r\n        project.getProperties().setProperty(md5Property, computeMD5());\r\n    } catch (Throwable ex) {\r\n        throw new MojoExecutionException(ex.toString(), ex);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\versioninfo",
  "methodName" : "getBuildTime",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String getBuildTime()\n{\r\n    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\r\n    dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n    return dateFormat.format(new Date());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\versioninfo",
  "methodName" : "determineSCM",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "SCM determineSCM() throws Exception\n{\r\n    Exec exec = new Exec(this);\r\n    SCM scm = SCM.NONE;\r\n    scmOut = new ArrayList<String>();\r\n    int ret;\r\n    ret = exec.run(Arrays.asList(gitCommand, \"branch\"), scmOut);\r\n    if (ret == 0) {\r\n        ret = exec.run(Arrays.asList(gitCommand, \"remote\", \"-v\"), scmOut);\r\n        if (ret != 0) {\r\n            scm = SCM.NONE;\r\n            scmOut = null;\r\n        } else {\r\n            ret = exec.run(Arrays.asList(gitCommand, \"log\", \"-n\", \"1\"), scmOut);\r\n            if (ret != 0) {\r\n                scm = SCM.NONE;\r\n                scmOut = null;\r\n            } else {\r\n                scm = SCM.GIT;\r\n            }\r\n        }\r\n    }\r\n    if (scmOut != null) {\r\n        getLog().debug(scmOut.toString());\r\n    }\r\n    getLog().info(\"SCM: \" + scm);\r\n    return scm;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\versioninfo",
  "methodName" : "getSCMUri",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "String getSCMUri(SCM scm)\n{\r\n    String uri = \"Unknown\";\r\n    switch(scm) {\r\n        case GIT:\r\n            for (String s : scmOut) {\r\n                if (s.startsWith(\"origin\") && s.endsWith(\"(fetch)\")) {\r\n                    uri = s.substring(\"origin\".length());\r\n                    uri = uri.substring(0, uri.length() - \"(fetch)\".length());\r\n                    break;\r\n                }\r\n            }\r\n            break;\r\n    }\r\n    return uri.trim();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\versioninfo",
  "methodName" : "getSCMCommit",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "String getSCMCommit(SCM scm)\n{\r\n    String commit = \"Unknown\";\r\n    switch(scm) {\r\n        case GIT:\r\n            for (String s : scmOut) {\r\n                if (s.startsWith(\"commit\")) {\r\n                    commit = s.substring(\"commit\".length());\r\n                    break;\r\n                }\r\n            }\r\n            break;\r\n    }\r\n    return commit.trim();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\versioninfo",
  "methodName" : "getSCMBranch",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "String getSCMBranch(SCM scm)\n{\r\n    String branch = \"Unknown\";\r\n    switch(scm) {\r\n        case GIT:\r\n            for (String s : scmOut) {\r\n                if (s.startsWith(\"*\")) {\r\n                    branch = s.substring(\"*\".length());\r\n                    break;\r\n                }\r\n            }\r\n            break;\r\n    }\r\n    return branch.trim();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\versioninfo",
  "methodName" : "readFile",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "byte[] readFile(File file) throws IOException\n{\r\n    RandomAccessFile raf = new RandomAccessFile(file, \"r\");\r\n    byte[] buffer = new byte[(int) raf.length()];\r\n    raf.readFully(buffer);\r\n    raf.close();\r\n    return buffer;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\versioninfo",
  "methodName" : "computeMD5",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "byte[] computeMD5(List<File> files) throws IOException, NoSuchAlgorithmException\n{\r\n    MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\r\n    for (File file : files) {\r\n        getLog().debug(\"Computing MD5 for: \" + file);\r\n        md5.update(readFile(file));\r\n    }\r\n    return md5.digest();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\versioninfo",
  "methodName" : "byteArrayToString",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String byteArrayToString(byte[] array)\n{\r\n    StringBuilder sb = new StringBuilder();\r\n    for (byte b : array) {\r\n        sb.append(Integer.toHexString(0xff & b));\r\n    }\r\n    return sb.toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\versioninfo",
  "methodName" : "computeMD5",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "String computeMD5() throws Exception\n{\r\n    List<File> files = FileSetUtils.convertFileSetToFiles(source);\r\n    Collections.sort(files, new MD5Comparator());\r\n    byte[] md5 = computeMD5(files);\r\n    String md5str = byteArrayToString(md5);\r\n    getLog().info(\"Computed MD5: \" + md5str);\r\n    return md5str;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\protoc",
  "methodName" : "execute",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void execute() throws MojoExecutionException\n{\r\n    final ProtocRunner protoc = new ProtocRunner(project, imports, output, source, protocCommand, protocVersion, checksumPath, this, true);\r\n    protoc.execute();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\util",
  "methodName" : "run",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "int run(List<String> command, List<String> output)\n{\r\n    return this.run(command, output, null);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\util",
  "methodName" : "run",
  "errType" : [ "IOException", "InterruptedException" ],
  "containingMethodsNum" : 15,
  "sourceCodeText" : "int run(List<String> command, List<String> output, List<String> errors)\n{\r\n    int retCode = 1;\r\n    ProcessBuilder pb = new ProcessBuilder(command);\r\n    try {\r\n        Process p = pb.start();\r\n        OutputBufferThread stdOut = new OutputBufferThread(p.getInputStream());\r\n        OutputBufferThread stdErr = new OutputBufferThread(p.getErrorStream());\r\n        stdOut.start();\r\n        stdErr.start();\r\n        retCode = p.waitFor();\r\n        if (retCode != 0) {\r\n            mojo.getLog().warn(command + \" failed with error code \" + retCode);\r\n            for (String s : stdErr.getOutput()) {\r\n                mojo.getLog().debug(s);\r\n            }\r\n        }\r\n        stdOut.join();\r\n        stdErr.join();\r\n        output.addAll(stdOut.getOutput());\r\n        if (errors != null) {\r\n            errors.addAll(stdErr.getOutput());\r\n        }\r\n    } catch (IOException ioe) {\r\n        mojo.getLog().warn(command + \" failed: \" + ioe.toString());\r\n    } catch (InterruptedException ie) {\r\n        mojo.getLog().warn(command + \" failed: \" + ie.toString());\r\n    }\r\n    return retCode;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\util",
  "methodName" : "addEnvironment",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void addEnvironment(ProcessBuilder pb, Map<String, String> env)\n{\r\n    if (env == null) {\r\n        return;\r\n    }\r\n    Map<String, String> processEnv = pb.environment();\r\n    for (Map.Entry<String, String> entry : env.entrySet()) {\r\n        String val = entry.getValue();\r\n        if (val == null) {\r\n            val = \"\";\r\n        }\r\n        processEnv.put(entry.getKey(), val);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\util",
  "methodName" : "envToString",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "String envToString(Map<String, String> env)\n{\r\n    StringBuilder bld = new StringBuilder();\r\n    bld.append(\"{\");\r\n    if (env != null) {\r\n        for (Map.Entry<String, String> entry : env.entrySet()) {\r\n            String val = entry.getValue();\r\n            if (val == null) {\r\n                val = \"\";\r\n            }\r\n            bld.append(\"\\n  \").append(entry.getKey()).append(\" = '\").append(val).append(\"'\\n\");\r\n        }\r\n    }\r\n    bld.append(\"}\");\r\n    return bld.toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\protoc",
  "methodName" : "execute",
  "errType" : [ "Throwable" ],
  "containingMethodsNum" : 33,
  "sourceCodeText" : "void execute() throws MojoExecutionException\n{\r\n    try {\r\n        List<String> command = new ArrayList<String>();\r\n        command.add(protocCommand);\r\n        command.add(\"--version\");\r\n        Exec exec = new Exec(mojo);\r\n        List<String> out = new ArrayList<String>();\r\n        if (exec.run(command, out) == 127) {\r\n            mojo.getLog().error(\"protoc, not found at: \" + protocCommand);\r\n            throw new MojoExecutionException(\"protoc failure\");\r\n        } else {\r\n            if (out.isEmpty()) {\r\n                mojo.getLog().error(\"stdout: \" + out);\r\n                throw new MojoExecutionException(\"'protoc --version' did not return a version\");\r\n            } else {\r\n                if (!out.get(0).endsWith(protocVersion)) {\r\n                    throw new MojoExecutionException(\"protoc version is '\" + out.get(0) + \"', expected version is '\" + protocVersion + \"'\");\r\n                }\r\n            }\r\n        }\r\n        if (!output.mkdirs()) {\r\n            if (!output.exists()) {\r\n                throw new MojoExecutionException(\"Could not create directory: \" + output);\r\n            }\r\n        }\r\n        ChecksumComparator comparator = new ChecksumComparator(checksumPath);\r\n        boolean importsChanged = false;\r\n        command = new ArrayList<String>();\r\n        command.add(protocCommand);\r\n        command.add(\"--java_out=\" + output.getCanonicalPath());\r\n        if (imports != null) {\r\n            for (File i : imports) {\r\n                if (comparator.hasChanged(i)) {\r\n                    importsChanged = true;\r\n                }\r\n                command.add(\"-I\" + i.getCanonicalPath());\r\n            }\r\n        }\r\n        List<File> changedSources = new ArrayList<>();\r\n        boolean sourcesChanged = false;\r\n        for (File f : FileSetUtils.convertFileSetToFiles(source)) {\r\n            if (comparator.hasChanged(f) || importsChanged) {\r\n                sourcesChanged = true;\r\n                changedSources.add(f);\r\n                command.add(f.getCanonicalPath());\r\n            }\r\n        }\r\n        if (!sourcesChanged && !importsChanged) {\r\n            mojo.getLog().info(\"No changes detected in protoc files, skipping \" + \"generation.\");\r\n        } else {\r\n            if (mojo.getLog().isDebugEnabled()) {\r\n                StringBuilder b = new StringBuilder();\r\n                b.append(\"Generating classes for the following protoc files: [\");\r\n                String prefix = \"\";\r\n                for (File f : changedSources) {\r\n                    b.append(prefix);\r\n                    b.append(f.toString());\r\n                    prefix = \", \";\r\n                }\r\n                b.append(\"]\");\r\n                mojo.getLog().debug(b.toString());\r\n            }\r\n            exec = new Exec(mojo);\r\n            out = new ArrayList<String>();\r\n            List<String> err = new ArrayList<>();\r\n            if (exec.run(command, out, err) != 0) {\r\n                mojo.getLog().error(\"protoc compiler error\");\r\n                for (String s : out) {\r\n                    mojo.getLog().error(s);\r\n                }\r\n                for (String s : err) {\r\n                    mojo.getLog().error(s);\r\n                }\r\n                throw new MojoExecutionException(\"protoc failure\");\r\n            }\r\n            comparator.writeChecksums();\r\n        }\r\n    } catch (Throwable ex) {\r\n        throw new MojoExecutionException(ex.toString(), ex);\r\n    }\r\n    if (test) {\r\n        project.addTestCompileSourceRoot(output.getAbsolutePath());\r\n    } else {\r\n        project.addCompileSourceRoot(output.getAbsolutePath());\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\cmakebuilder",
  "methodName" : "validatePlatform",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void validatePlatform() throws MojoExecutionException\n{\r\n    if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).startsWith(\"windows\")) {\r\n        throw new MojoExecutionException(\"CMakeBuilder does not yet support \" + \"the Windows platform.\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\cmakebuilder",
  "methodName" : "execute",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void execute() throws MojoExecutionException\n{\r\n    long start = System.nanoTime();\r\n    validatePlatform();\r\n    runCMake();\r\n    runMake();\r\n    long end = System.nanoTime();\r\n    getLog().info(\"cmake compilation finished successfully in \" + TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS) + \" millisecond(s).\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\cmakebuilder",
  "methodName" : "validateSourceParams",
  "errType" : [ "IOException", "IOException" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void validateSourceParams(File source, File output) throws MojoExecutionException\n{\r\n    String cOutput = null, cSource = null;\r\n    try {\r\n        cOutput = output.getCanonicalPath();\r\n    } catch (IOException e) {\r\n        throw new MojoExecutionException(\"error getting canonical path \" + \"for output\", e);\r\n    }\r\n    try {\r\n        cSource = source.getCanonicalPath();\r\n    } catch (IOException e) {\r\n        throw new MojoExecutionException(\"error getting canonical path \" + \"for source\", e);\r\n    }\r\n    if (cSource.startsWith(cOutput)) {\r\n        throw new MojoExecutionException(\"The source directory must not be \" + \"inside the output directory (it would be destroyed by \" + \"'mvn clean')\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\cmakebuilder",
  "methodName" : "runCMake",
  "errType" : [ "IOException", "InterruptedException", "InterruptedException" ],
  "containingMethodsNum" : 28,
  "sourceCodeText" : "void runCMake() throws MojoExecutionException\n{\r\n    validatePlatform();\r\n    validateSourceParams(source, output);\r\n    if (output.mkdirs()) {\r\n        getLog().info(\"mkdirs '\" + output + \"'\");\r\n    }\r\n    List<String> cmd = new LinkedList<String>();\r\n    cmd.add(\"cmake\");\r\n    cmd.add(source.getAbsolutePath());\r\n    for (Map.Entry<String, String> entry : vars.entrySet()) {\r\n        if ((entry.getValue() != null) && (!entry.getValue().equals(\"\"))) {\r\n            cmd.add(\"-D\" + entry.getKey() + \"=\" + entry.getValue());\r\n        }\r\n    }\r\n    cmd.add(\"-G\");\r\n    cmd.add(\"Unix Makefiles\");\r\n    String prefix = \"\";\r\n    StringBuilder bld = new StringBuilder();\r\n    for (String c : cmd) {\r\n        bld.append(prefix).append(c);\r\n        prefix = \" \";\r\n    }\r\n    getLog().info(\"Running \" + bld.toString());\r\n    getLog().info(\"with extra environment variables \" + Exec.envToString(env));\r\n    ProcessBuilder pb = new ProcessBuilder(cmd);\r\n    pb.directory(output);\r\n    pb.redirectErrorStream(true);\r\n    Exec.addEnvironment(pb, env);\r\n    Process proc = null;\r\n    OutputBufferThread outThread = null;\r\n    int retCode = -1;\r\n    try {\r\n        proc = pb.start();\r\n        outThread = new OutputBufferThread(proc.getInputStream());\r\n        outThread.start();\r\n        retCode = proc.waitFor();\r\n        if (retCode != 0) {\r\n            throw new MojoExecutionException(\"CMake failed with error code \" + retCode);\r\n        }\r\n    } catch (IOException e) {\r\n        throw new MojoExecutionException(\"Error executing CMake\", e);\r\n    } catch (InterruptedException e) {\r\n        throw new MojoExecutionException(\"Interrupted while waiting for \" + \"CMake process\", e);\r\n    } finally {\r\n        if (proc != null) {\r\n            proc.destroy();\r\n        }\r\n        if (outThread != null) {\r\n            try {\r\n                outThread.interrupt();\r\n                outThread.join();\r\n            } catch (InterruptedException e) {\r\n                getLog().error(\"Interrupted while joining output thread\", e);\r\n            }\r\n            if (retCode != 0) {\r\n                for (String line : outThread.getOutput()) {\r\n                    getLog().warn(line);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\cmakebuilder",
  "methodName" : "runMake",
  "errType" : [ "InterruptedException", "IOException", "InterruptedException", "InterruptedException" ],
  "containingMethodsNum" : 23,
  "sourceCodeText" : "void runMake() throws MojoExecutionException\n{\r\n    List<String> cmd = new LinkedList<String>();\r\n    cmd.add(\"make\");\r\n    cmd.add(\"-j\");\r\n    cmd.add(String.valueOf(availableProcessors));\r\n    cmd.add(\"VERBOSE=1\");\r\n    if (target != null) {\r\n        cmd.add(target);\r\n    }\r\n    StringBuilder bld = new StringBuilder();\r\n    String prefix = \"\";\r\n    for (String c : cmd) {\r\n        bld.append(prefix).append(c);\r\n        prefix = \" \";\r\n    }\r\n    getLog().info(\"Running \" + bld.toString());\r\n    ProcessBuilder pb = new ProcessBuilder(cmd);\r\n    pb.directory(output);\r\n    Process proc = null;\r\n    int retCode = -1;\r\n    OutputBufferThread stdoutThread = null, stderrThread = null;\r\n    try {\r\n        proc = pb.start();\r\n        stdoutThread = new OutputBufferThread(proc.getInputStream());\r\n        stderrThread = new OutputBufferThread(proc.getErrorStream());\r\n        stdoutThread.start();\r\n        stderrThread.start();\r\n        retCode = proc.waitFor();\r\n        if (retCode != 0) {\r\n            throw new MojoExecutionException(\"make failed with error code \" + retCode);\r\n        }\r\n    } catch (InterruptedException e) {\r\n        throw new MojoExecutionException(\"Interrupted during Process#waitFor\", e);\r\n    } catch (IOException e) {\r\n        throw new MojoExecutionException(\"Error executing make\", e);\r\n    } finally {\r\n        if (stdoutThread != null) {\r\n            try {\r\n                stdoutThread.join();\r\n            } catch (InterruptedException e) {\r\n                getLog().error(\"Interrupted while joining stdoutThread\", e);\r\n            }\r\n            if (retCode != 0) {\r\n                for (String line : stdoutThread.getOutput()) {\r\n                    getLog().warn(line);\r\n                }\r\n            }\r\n        }\r\n        if (stderrThread != null) {\r\n            try {\r\n                stderrThread.join();\r\n            } catch (InterruptedException e) {\r\n                getLog().error(\"Interrupted while joining stderrThread\", e);\r\n            }\r\n            for (String line : stderrThread.getOutput()) {\r\n                getLog().warn(line);\r\n            }\r\n        }\r\n        if (proc != null) {\r\n            proc.destroy();\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 3,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-maven-plugins\\src\\main\\java\\org\\apache\\hadoop\\maven\\plugin\\protoc",
  "methodName" : "execute",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void execute() throws MojoExecutionException\n{\r\n    final ProtocRunner protoc = new ProtocRunner(project, imports, output, source, protocCommand, protocVersion, checksumPath, this, false);\r\n    protoc.execute();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
} ]