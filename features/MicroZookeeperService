[ {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "getConnectionString",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "String getConnectionString()\n{\r\n    Preconditions.checkState(factory != null, \"service not started\");\r\n    InetSocketAddress addr = factory.getLocalAddress();\r\n    return String.format(\"%s:%d\", addr.getHostName(), addr.getPort());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "getConnectionAddress",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "InetSocketAddress getConnectionAddress()\n{\r\n    Preconditions.checkState(factory != null, \"service not started\");\r\n    return factory.getLocalAddress();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "getAddress",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "InetSocketAddress getAddress(int port) throws UnknownHostException\n{\r\n    return new InetSocketAddress(host, port <= 0 ? getRandomAvailablePort() : port);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "serviceInit",
  "errType" : null,
  "containingMethodsNum" : 13,
  "sourceCodeText" : "void serviceInit(Configuration conf) throws Exception\n{\r\n    port = conf.getInt(KEY_ZKSERVICE_PORT, 0);\r\n    tickTime = conf.getInt(KEY_ZKSERVICE_TICK_TIME, ZooKeeperServer.DEFAULT_TICK_TIME);\r\n    String instancedirname = conf.getTrimmed(KEY_ZKSERVICE_DIR, \"\");\r\n    host = conf.getTrimmed(KEY_ZKSERVICE_HOST, DEFAULT_ZKSERVICE_HOST);\r\n    if (instancedirname.isEmpty()) {\r\n        File testdir = new File(System.getProperty(\"test.dir\", \"target\"));\r\n        instanceDir = new File(testdir, \"zookeeper\" + getName());\r\n    } else {\r\n        instanceDir = new File(instancedirname);\r\n        FileUtil.fullyDelete(instanceDir);\r\n    }\r\n    LOG.debug(\"Instance directory is {}\", instanceDir);\r\n    mkdirStrict(instanceDir);\r\n    dataDir = new File(instanceDir, \"data\");\r\n    confDir = new File(instanceDir, \"conf\");\r\n    mkdirStrict(dataDir);\r\n    mkdirStrict(confDir);\r\n    super.serviceInit(conf);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "mkdirStrict",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void mkdirStrict(File dir) throws IOException\n{\r\n    if (!dir.mkdirs()) {\r\n        if (!dir.isDirectory()) {\r\n            throw new IOException(\"Failed to mkdir \" + dir);\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "addDiagnostics",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void addDiagnostics(String text, Object... args)\n{\r\n    diagnostics.append(String.format(text, args)).append('\\n');\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "getDiagnostics",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String getDiagnostics()\n{\r\n    return diagnostics.toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "setupSecurity",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "boolean setupSecurity() throws IOException\n{\r\n    Configuration conf = getConfig();\r\n    String jaasContext = conf.getTrimmed(KEY_REGISTRY_ZKSERVICE_JAAS_CONTEXT);\r\n    secureServer = StringUtils.isNotEmpty(jaasContext);\r\n    if (secureServer) {\r\n        RegistrySecurity.validateContext(jaasContext);\r\n        RegistrySecurity.bindZKToServerJAASContext(jaasContext);\r\n        System.setProperty(PROP_ZK_ALLOW_FAILED_SASL_CLIENTS, conf.get(KEY_ZKSERVICE_ALLOW_FAILED_SASL_CLIENTS, \"true\"));\r\n        System.setProperty(RegistryInternalConstants.ZOOKEEPER_AUTH_PROVIDER + \".1\", RegistryInternalConstants.SASLAUTHENTICATION_PROVIDER);\r\n        String serverContext = System.getProperty(PROP_ZK_SERVER_SASL_CONTEXT);\r\n        addDiagnostics(\"Server JAAS context s = %s\", serverContext);\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "serviceStart",
  "errType" : null,
  "containingMethodsNum" : 14,
  "sourceCodeText" : "void serviceStart() throws Exception\n{\r\n    setupSecurity();\r\n    FileTxnSnapLog ftxn = new FileTxnSnapLog(dataDir, dataDir);\r\n    ZooKeeperServer zkServer = new ZooKeeperServer(ftxn, tickTime, \"\");\r\n    LOG.info(\"Starting Local Zookeeper service\");\r\n    factory = ServerCnxnFactory.createFactory();\r\n    factory.configure(getAddress(port), -1);\r\n    factory.startup(zkServer);\r\n    String connectString = getConnectionString();\r\n    LOG.info(\"In memory ZK started at {}\\n\", connectString);\r\n    if (LOG.isDebugEnabled()) {\r\n        StringWriter sw = new StringWriter();\r\n        PrintWriter pw = new PrintWriter(sw);\r\n        zkServer.dumpConf(pw);\r\n        pw.flush();\r\n        LOG.debug(\"ZooKeeper config:\\n\" + sw.toString());\r\n    }\r\n    binding = new BindingInformation();\r\n    binding.ensembleProvider = new FixedEnsembleProvider(connectString);\r\n    binding.description = getName() + \" reachable at \\\"\" + connectString + \"\\\"\";\r\n    addDiagnostics(binding.description);\r\n    getConfig().set(KEY_REGISTRY_ZK_QUORUM, connectString);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "serviceStop",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void serviceStop() throws Exception\n{\r\n    if (factory != null) {\r\n        factory.shutdown();\r\n        factory = null;\r\n    }\r\n    if (dataDir != null) {\r\n        FileUtil.fullyDelete(dataDir);\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "supplyBindingInformation",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "BindingInformation supplyBindingInformation()\n{\r\n    Preconditions.checkNotNull(binding, \"Service is not started: binding information undefined\");\r\n    return binding;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "getRandomAvailablePort",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "int getRandomAvailablePort()\n{\r\n    port = 0;\r\n    try {\r\n        final ServerSocket s = new ServerSocket(0);\r\n        port = s.getLocalPort();\r\n        s.close();\r\n    } catch (IOException e) {\r\n        LOG.warn(\"ERROR during selecting random port for ZooKeeper server to bind.\", e);\r\n    }\r\n    return port;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getIpv6Address",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "InetAddress getIpv6Address(InetAddress address) throws UnknownHostException\n{\r\n    String[] octets = address.getHostAddress().split(\"\\\\.\");\r\n    byte[] octetBytes = new byte[4];\r\n    for (int i = 0; i < 4; ++i) {\r\n        octetBytes[i] = (byte) Integer.parseInt(octets[i]);\r\n    }\r\n    byte[] ipv4asIpV6addr = new byte[16];\r\n    ipv4asIpV6addr[10] = (byte) 0xff;\r\n    ipv4asIpV6addr[11] = (byte) 0xff;\r\n    ipv4asIpV6addr[12] = octetBytes[0];\r\n    ipv4asIpV6addr[13] = octetBytes[1];\r\n    ipv4asIpV6addr[14] = octetBytes[2];\r\n    ipv4asIpV6addr[15] = octetBytes[3];\r\n    return Inet6Address.getByAddress(null, ipv4asIpV6addr, 0);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "reverseIP",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Name reverseIP(String ip) throws UnknownHostException\n{\r\n    return ReverseMap.fromAddress(ip);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "manageDNSRecords",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void manageDNSRecords(RegistryDNS.RegistryCommand command) throws IOException\n{\r\n    for (Map.Entry<Integer, List<RecordDescriptor>> entry : typeToDescriptorMap.entrySet()) {\r\n        for (RecordDescriptor recordDescriptor : entry.getValue()) {\r\n            for (Name name : recordDescriptor.getNames()) {\r\n                RecordCreatorFactory.RecordCreator recordCreator = RecordCreatorFactory.getRecordCreator(entry.getKey());\r\n                command.exec(zoneSelctor.findBestZone(name), recordCreator.create(name, recordDescriptor.getTarget()));\r\n            }\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "registerRecordDescriptor",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void registerRecordDescriptor(int type, RecordDescriptor recordDescriptor)\n{\r\n    List<RecordDescriptor> infos = new ArrayList<>();\r\n    infos.add(recordDescriptor);\r\n    typeToDescriptorMap.put(type, infos);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "registerRecordDescriptor",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void registerRecordDescriptor(int type, List<RecordDescriptor> recordDescriptors)\n{\r\n    typeToDescriptorMap.put(type, recordDescriptors);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getPath",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getPath()\n{\r\n    return path;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "setPath",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void setPath(String path)\n{\r\n    this.path = path;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl",
  "methodName" : "getFs",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "FileSystem getFs()\n{\r\n    return this.fs;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl",
  "methodName" : "serviceInit",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void serviceInit(Configuration conf)\n{\r\n    try {\r\n        this.fs = FileSystem.get(conf);\r\n        LOG.info(\"Initialized Yarn-registry with Filesystem \" + fs.getClass().getCanonicalName());\r\n    } catch (IOException e) {\r\n        LOG.error(\"Failed to get FileSystem for registry\", e);\r\n        throw new RuntimeException(e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl",
  "methodName" : "makePath",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Path makePath(String path)\n{\r\n    return new Path(path);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl",
  "methodName" : "formatDataPath",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Path formatDataPath(String basePath)\n{\r\n    return Path.mergePaths(new Path(basePath), new Path(\"/_record\"));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl",
  "methodName" : "relativize",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String relativize(String basePath, String childPath)\n{\r\n    String relative = new File(basePath).toURI().relativize(new File(childPath).toURI()).getPath();\r\n    return relative;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl",
  "methodName" : "mknode",
  "errType" : [ "FileNotFoundException" ],
  "containingMethodsNum" : 8,
  "sourceCodeText" : "boolean mknode(String path, boolean createParents) throws PathNotFoundException, InvalidPathnameException, IOException\n{\r\n    Path registryPath = makePath(path);\r\n    try {\r\n        fs.getFileStatus(registryPath);\r\n        return false;\r\n    } catch (FileNotFoundException e) {\r\n    }\r\n    if (createParents) {\r\n        fs.mkdirs(registryPath);\r\n    } else {\r\n        FileStatus parentStatus = null;\r\n        if (registryPath.getParent() != null) {\r\n            parentStatus = fs.getFileStatus(registryPath.getParent());\r\n        }\r\n        if (registryPath.getParent() == null || parentStatus.isDirectory()) {\r\n            fs.mkdirs(registryPath);\r\n        } else {\r\n            throw new PathNotFoundException(\"no parent for \" + path);\r\n        }\r\n    }\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl",
  "methodName" : "bind",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void bind(String path, ServiceRecord record, int flags) throws PathNotFoundException, FileAlreadyExistsException, InvalidPathnameException, IOException\n{\r\n    Preconditions.checkArgument(record != null, \"null record\");\r\n    RegistryTypeUtils.validateServiceRecord(path, record);\r\n    Path dataPath = formatDataPath(path);\r\n    Boolean overwrite = ((flags & BindFlags.OVERWRITE) != 0);\r\n    if (fs.exists(dataPath) && !overwrite) {\r\n        throw new FileAlreadyExistsException();\r\n    } else {\r\n        FSDataOutputStream stream = fs.create(dataPath);\r\n        byte[] bytes = serviceRecordMarshal.toBytes(record);\r\n        stream.write(bytes);\r\n        stream.close();\r\n        LOG.info(\"Bound record to path \" + dataPath);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl",
  "methodName" : "resolve",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "ServiceRecord resolve(String path) throws PathNotFoundException, NoRecordException, InvalidRecordException, IOException\n{\r\n    Long size = fs.getFileStatus(formatDataPath(path)).getLen();\r\n    byte[] bytes = new byte[size.intValue()];\r\n    FSDataInputStream instream = fs.open(formatDataPath(path));\r\n    int bytesRead = instream.read(bytes);\r\n    instream.close();\r\n    if (bytesRead < size) {\r\n        throw new InvalidRecordException(path, \"Expected \" + size + \" bytes, but read \" + bytesRead);\r\n    }\r\n    ServiceRecord record = serviceRecordMarshal.fromBytes(path, bytes);\r\n    RegistryTypeUtils.validateServiceRecord(path, record);\r\n    return record;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl",
  "methodName" : "stat",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "RegistryPathStatus stat(String path) throws PathNotFoundException, InvalidPathnameException, IOException\n{\r\n    FileStatus fstat = fs.getFileStatus(formatDataPath(path));\r\n    int numChildren = fs.listStatus(makePath(path)).length;\r\n    RegistryPathStatus regstat = new RegistryPathStatus(fstat.getPath().toString(), fstat.getModificationTime(), fstat.getLen(), numChildren);\r\n    return regstat;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl",
  "methodName" : "exists",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean exists(String path) throws IOException\n{\r\n    return fs.exists(makePath(path));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl",
  "methodName" : "list",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "List<String> list(String path) throws PathNotFoundException, InvalidPathnameException, IOException\n{\r\n    FileStatus[] statArray = fs.listStatus(makePath(path));\r\n    String basePath = fs.getFileStatus(makePath(path)).getPath().toString();\r\n    List<String> paths = new ArrayList<String>();\r\n    FileStatus stat;\r\n    for (int i = 0; i < statArray.length; i++) {\r\n        stat = statArray[i];\r\n        if (stat.isDirectory()) {\r\n            String relativePath = relativize(basePath, stat.getPath().toString());\r\n            paths.add(relativePath);\r\n        }\r\n    }\r\n    return paths;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl",
  "methodName" : "delete",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void delete(String path, boolean recursive) throws PathNotFoundException, PathIsNotEmptyDirectoryException, InvalidPathnameException, IOException\n{\r\n    Path dirPath = makePath(path);\r\n    if (!fs.exists(dirPath)) {\r\n        throw new PathNotFoundException(path);\r\n    }\r\n    if (recursive || list(path).isEmpty()) {\r\n        fs.delete(makePath(path), true);\r\n        return;\r\n    }\r\n    throw new PathIsNotEmptyDirectoryException(path);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl",
  "methodName" : "addWriteAccessor",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean addWriteAccessor(String id, String pass) throws IOException\n{\r\n    throw new NotImplementedException(\"Code is not implemented\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl",
  "methodName" : "clearWriteAccessors",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void clearWriteAccessors()\n{\r\n    throw new NotImplementedException(\"Code is not implemented\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "urlEndpoint",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Endpoint urlEndpoint(String api, String protocolType, URI... uris)\n{\r\n    return new Endpoint(api, protocolType, uris);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "restEndpoint",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Endpoint restEndpoint(String api, URI... uris)\n{\r\n    return urlEndpoint(api, ProtocolTypes.PROTOCOL_REST, uris);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "webEndpoint",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Endpoint webEndpoint(String api, URI... uris)\n{\r\n    return urlEndpoint(api, ProtocolTypes.PROTOCOL_WEBUI, uris);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "inetAddrEndpoint",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "Endpoint inetAddrEndpoint(String api, String protocolType, String hostname, int port)\n{\r\n    Preconditions.checkArgument(api != null, \"null API\");\r\n    Preconditions.checkArgument(protocolType != null, \"null protocolType\");\r\n    Preconditions.checkArgument(hostname != null, \"null hostname\");\r\n    return new Endpoint(api, ADDRESS_HOSTNAME_AND_PORT, protocolType, hostnamePortPair(hostname, port));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "ipcEndpoint",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Endpoint ipcEndpoint(String api, InetSocketAddress address)\n{\r\n    return new Endpoint(api, ADDRESS_HOSTNAME_AND_PORT, ProtocolTypes.PROTOCOL_HADOOP_IPC, address == null ? null : hostnamePortPair(address));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "map",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Map<String, String> map(String key, String val)\n{\r\n    Map<String, String> map = new HashMap<String, String>(1);\r\n    map.put(key, val);\r\n    return map;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "uri",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Map<String, String> uri(String uri)\n{\r\n    return map(ADDRESS_URI, uri);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "hostnamePortPair",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "Map<String, String> hostnamePortPair(String hostname, int port)\n{\r\n    Map<String, String> map = map(ADDRESS_HOSTNAME_FIELD, hostname);\r\n    map.put(ADDRESS_PORT_FIELD, Integer.toString(port));\r\n    return map;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "hostnamePortPair",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Map<String, String> hostnamePortPair(InetSocketAddress address)\n{\r\n    return hostnamePortPair(address.getHostName(), address.getPort());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "requireAddressType",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void requireAddressType(String required, Endpoint epr) throws InvalidRecordException\n{\r\n    if (!required.equals(epr.addressType)) {\r\n        throw new InvalidRecordException(epr.toString(), \"Address type of \" + epr.addressType + \" does not match required type of \" + required);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "retrieveAddressesUriType",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "List<String> retrieveAddressesUriType(Endpoint epr) throws InvalidRecordException\n{\r\n    if (epr == null) {\r\n        return null;\r\n    }\r\n    requireAddressType(ADDRESS_URI, epr);\r\n    List<Map<String, String>> addresses = epr.addresses;\r\n    if (addresses.size() < 1) {\r\n        throw new InvalidRecordException(epr.toString(), \"No addresses in endpoint\");\r\n    }\r\n    List<String> results = new ArrayList<String>(addresses.size());\r\n    for (Map<String, String> address : addresses) {\r\n        results.add(getAddressField(address, ADDRESS_URI));\r\n    }\r\n    return results;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "getAddressField",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String getAddressField(Map<String, String> address, String field) throws InvalidRecordException\n{\r\n    String val = address.get(field);\r\n    if (val == null) {\r\n        throw new InvalidRecordException(\"\", \"Missing address field: \" + field);\r\n    }\r\n    return val;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "retrieveAddressURLs",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "List<URL> retrieveAddressURLs(Endpoint epr) throws InvalidRecordException, MalformedURLException\n{\r\n    if (epr == null) {\r\n        throw new InvalidRecordException(\"\", \"Null endpoint\");\r\n    }\r\n    List<String> addresses = retrieveAddressesUriType(epr);\r\n    List<URL> results = new ArrayList<URL>(addresses.size());\r\n    for (String address : addresses) {\r\n        results.add(new URL(address));\r\n    }\r\n    return results;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "validateServiceRecord",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void validateServiceRecord(String path, ServiceRecord record) throws InvalidRecordException\n{\r\n    if (record == null) {\r\n        throw new InvalidRecordException(path, \"Null record\");\r\n    }\r\n    if (!ServiceRecord.RECORD_TYPE.equals(record.type)) {\r\n        throw new InvalidRecordException(path, \"invalid record type field: \\\"\" + record.type + \"\\\"\");\r\n    }\r\n    if (record.external != null) {\r\n        for (Endpoint endpoint : record.external) {\r\n            validateEndpoint(path, endpoint);\r\n        }\r\n    }\r\n    if (record.internal != null) {\r\n        for (Endpoint endpoint : record.internal) {\r\n            validateEndpoint(path, endpoint);\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "validateEndpoint",
  "errType" : [ "RuntimeException" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void validateEndpoint(String path, Endpoint endpoint) throws InvalidRecordException\n{\r\n    if (endpoint == null) {\r\n        throw new InvalidRecordException(path, \"Null endpoint\");\r\n    }\r\n    try {\r\n        endpoint.validate();\r\n    } catch (RuntimeException e) {\r\n        throw new InvalidRecordException(path, e.toString());\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "serviceInit",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void serviceInit(Configuration conf) throws Exception\n{\r\n    registryRoot = conf.getTrimmed(KEY_REGISTRY_ZK_ROOT, DEFAULT_ZK_REGISTRY_ROOT);\r\n    addService(registrySecurity);\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"Creating Registry with root {}\", registryRoot);\r\n    }\r\n    super.serviceInit(conf);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "setKerberosPrincipalAndKeytab",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void setKerberosPrincipalAndKeytab(String principal, String keytab)\n{\r\n    registrySecurity.setKerberosPrincipalAndKeytab(principal, keytab);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "serviceStart",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void serviceStart() throws Exception\n{\r\n    super.serviceStart();\r\n    curator = createCurator();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "serviceStop",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void serviceStop() throws Exception\n{\r\n    IOUtils.closeStream(curator);\r\n    if (curatorCacheBridge != null) {\r\n        curatorCacheBridge.close();\r\n    }\r\n    super.serviceStop();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "checkServiceLive",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void checkServiceLive() throws ServiceStateException\n{\r\n    if (!isInState(STATE.STARTED)) {\r\n        throw new ServiceStateException(\"Service \" + getName() + \" is in wrong state: \" + getServiceState());\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "isSecure",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean isSecure()\n{\r\n    return registrySecurity.isSecureRegistry();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "getRegistrySecurity",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "RegistrySecurity getRegistrySecurity()\n{\r\n    return registrySecurity;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "buildSecurityDiagnostics",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "String buildSecurityDiagnostics()\n{\r\n    if (!isSecure()) {\r\n        return \"security disabled\";\r\n    } else {\r\n        StringBuilder builder = new StringBuilder();\r\n        builder.append(\"secure cluster; \");\r\n        builder.append(registrySecurity.buildSecurityDiagnostics());\r\n        return builder.toString();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "createCurator",
  "errType" : null,
  "containingMethodsNum" : 16,
  "sourceCodeText" : "CuratorFramework createCurator() throws IOException\n{\r\n    Configuration conf = getConfig();\r\n    createEnsembleProvider();\r\n    int sessionTimeout = conf.getInt(KEY_REGISTRY_ZK_SESSION_TIMEOUT, DEFAULT_ZK_SESSION_TIMEOUT);\r\n    int connectionTimeout = conf.getInt(KEY_REGISTRY_ZK_CONNECTION_TIMEOUT, DEFAULT_ZK_CONNECTION_TIMEOUT);\r\n    int retryTimes = conf.getInt(KEY_REGISTRY_ZK_RETRY_TIMES, DEFAULT_ZK_RETRY_TIMES);\r\n    int retryInterval = conf.getInt(KEY_REGISTRY_ZK_RETRY_INTERVAL, DEFAULT_ZK_RETRY_INTERVAL);\r\n    int retryCeiling = conf.getInt(KEY_REGISTRY_ZK_RETRY_CEILING, DEFAULT_ZK_RETRY_CEILING);\r\n    LOG.info(\"Creating CuratorService with connection {}\", connectionDescription);\r\n    CuratorFramework framework;\r\n    synchronized (CuratorService.class) {\r\n        CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();\r\n        builder.ensembleProvider(ensembleProvider).connectionTimeoutMs(connectionTimeout).sessionTimeoutMs(sessionTimeout).retryPolicy(new BoundedExponentialBackoffRetry(retryInterval, retryCeiling, retryTimes));\r\n        registrySecurity.applySecurityEnvironment(builder);\r\n        securityConnectionDiagnostics = buildSecurityDiagnostics();\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(securityConnectionDiagnostics);\r\n        }\r\n        framework = builder.build();\r\n        framework.start();\r\n    }\r\n    return framework;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "toString",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String toString()\n{\r\n    return super.toString() + \" \" + bindingDiagnosticDetails();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "bindingDiagnosticDetails",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String bindingDiagnosticDetails()\n{\r\n    return \" Connection=\\\"\" + connectionDescription + \"\\\"\" + \" root=\\\"\" + registryRoot + \"\\\"\" + \" \" + securityConnectionDiagnostics;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "createFullPath",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String createFullPath(String path) throws IOException\n{\r\n    return RegistryPathUtils.createFullPath(registryRoot, path);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "getBindingSource",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "RegistryBindingSource getBindingSource()\n{\r\n    return bindingSource;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "createEnsembleProvider",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void createEnsembleProvider()\n{\r\n    BindingInformation binding = bindingSource.supplyBindingInformation();\r\n    connectionDescription = binding.description + \" \" + securityConnectionDiagnostics;\r\n    ensembleProvider = binding.ensembleProvider;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "supplyBindingInformation",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "BindingInformation supplyBindingInformation()\n{\r\n    BindingInformation binding = new BindingInformation();\r\n    String connectString = buildConnectionString();\r\n    binding.ensembleProvider = new FixedEnsembleProvider(connectString);\r\n    binding.description = \"fixed ZK quorum \\\"\" + connectString + \"\\\"\";\r\n    return binding;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "buildConnectionString",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String buildConnectionString()\n{\r\n    return getConfig().getTrimmed(KEY_REGISTRY_ZK_QUORUM, DEFAULT_REGISTRY_ZK_QUORUM);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "operationFailure",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "IOException operationFailure(String path, String operation, Exception exception)\n{\r\n    return operationFailure(path, operation, exception, null);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "operationFailure",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "IOException operationFailure(String path, String operation, Exception exception, List<ACL> acls)\n{\r\n    IOException ioe;\r\n    String aclList = \"[\" + RegistrySecurity.aclsToString(acls) + \"]\";\r\n    if (exception instanceof KeeperException.NoNodeException) {\r\n        ioe = new PathNotFoundException(path);\r\n    } else if (exception instanceof KeeperException.NodeExistsException) {\r\n        ioe = new FileAlreadyExistsException(path);\r\n    } else if (exception instanceof KeeperException.NoAuthException) {\r\n        ioe = new NoPathPermissionsException(path, \"Not authorized to access path; ACLs: \" + aclList);\r\n    } else if (exception instanceof KeeperException.NotEmptyException) {\r\n        ioe = new PathIsNotEmptyDirectoryException(path);\r\n    } else if (exception instanceof KeeperException.AuthFailedException) {\r\n        ioe = new AuthenticationFailedException(path, \"Authentication Failed: \" + exception + \"; \" + securityConnectionDiagnostics, exception);\r\n    } else if (exception instanceof KeeperException.NoChildrenForEphemeralsException) {\r\n        ioe = new NoChildrenForEphemeralsException(path, \"Cannot create a path under an ephemeral node: \" + exception, exception);\r\n    } else if (exception instanceof KeeperException.InvalidACLException) {\r\n        StringBuilder builder = new StringBuilder();\r\n        builder.append(\"Path access failure \").append(aclList);\r\n        builder.append(\" \");\r\n        builder.append(securityConnectionDiagnostics);\r\n        ioe = new NoPathPermissionsException(path, builder.toString());\r\n    } else {\r\n        ioe = new RegistryIOException(path, \"Failure of \" + operation + \" on \" + path + \": \" + exception.toString(), exception);\r\n    }\r\n    if (ioe.getCause() == null) {\r\n        ioe.initCause(exception);\r\n    }\r\n    return ioe;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "maybeCreate",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean maybeCreate(String path, CreateMode mode, List<ACL> acl, boolean createParents) throws IOException\n{\r\n    return zkMkPath(path, mode, createParents, acl);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "zkStat",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "Stat zkStat(String path) throws IOException\n{\r\n    checkServiceLive();\r\n    String fullpath = createFullPath(path);\r\n    Stat stat;\r\n    try {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Stat {}\", fullpath);\r\n        }\r\n        stat = curator.checkExists().forPath(fullpath);\r\n    } catch (Exception e) {\r\n        throw operationFailure(fullpath, \"read()\", e);\r\n    }\r\n    if (stat == null) {\r\n        throw new PathNotFoundException(path);\r\n    }\r\n    return stat;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "zkGetACLS",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "List<ACL> zkGetACLS(String path) throws IOException\n{\r\n    checkServiceLive();\r\n    String fullpath = createFullPath(path);\r\n    List<ACL> acls;\r\n    try {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"GetACLS {}\", fullpath);\r\n        }\r\n        acls = curator.getACL().forPath(fullpath);\r\n    } catch (Exception e) {\r\n        throw operationFailure(fullpath, \"read()\", e);\r\n    }\r\n    if (acls == null) {\r\n        throw new PathNotFoundException(path);\r\n    }\r\n    return acls;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "zkPathExists",
  "errType" : [ "PathNotFoundException", "IOException" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "boolean zkPathExists(String path) throws IOException\n{\r\n    checkServiceLive();\r\n    try {\r\n        zkStat(path);\r\n        return true;\r\n    } catch (PathNotFoundException e) {\r\n        return false;\r\n    } catch (IOException e) {\r\n        throw e;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "zkPathMustExist",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String zkPathMustExist(String path) throws IOException\n{\r\n    zkStat(path);\r\n    return path;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "zkMkPath",
  "errType" : [ "KeeperException.NodeExistsException", "Exception" ],
  "containingMethodsNum" : 12,
  "sourceCodeText" : "boolean zkMkPath(String path, CreateMode mode, boolean createParents, List<ACL> acls) throws IOException\n{\r\n    checkServiceLive();\r\n    path = createFullPath(path);\r\n    if (acls == null || acls.isEmpty()) {\r\n        throw new NoPathPermissionsException(path, \"Empty ACL list\");\r\n    }\r\n    try {\r\n        RegistrySecurity.AclListInfo aclInfo = new RegistrySecurity.AclListInfo(acls);\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Creating path {} with mode {} and ACL {}\", path, mode, aclInfo);\r\n        }\r\n        CreateBuilder createBuilder = curator.create();\r\n        createBuilder.withMode(mode).withACL(acls);\r\n        if (createParents) {\r\n            createBuilder.creatingParentsIfNeeded();\r\n        }\r\n        createBuilder.forPath(path);\r\n    } catch (KeeperException.NodeExistsException e) {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"path already present: {}\", path, e);\r\n        }\r\n        return false;\r\n    } catch (Exception e) {\r\n        throw operationFailure(path, \"mkdir() \", e, acls);\r\n    }\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "zkMkParentPath",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void zkMkParentPath(String path, List<ACL> acl) throws IOException\n{\r\n    zkMkPath(RegistryPathUtils.parentOf(path), CreateMode.PERSISTENT, true, acl);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "zkCreate",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void zkCreate(String path, CreateMode mode, byte[] data, List<ACL> acls) throws IOException\n{\r\n    Preconditions.checkArgument(data != null, \"null data\");\r\n    checkServiceLive();\r\n    String fullpath = createFullPath(path);\r\n    try {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Creating {} with {} bytes of data and ACL {}\", fullpath, data.length, new RegistrySecurity.AclListInfo(acls));\r\n        }\r\n        curator.create().withMode(mode).withACL(acls).forPath(fullpath, data);\r\n    } catch (Exception e) {\r\n        throw operationFailure(fullpath, \"create()\", e, acls);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "zkUpdate",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void zkUpdate(String path, byte[] data) throws IOException\n{\r\n    Preconditions.checkArgument(data != null, \"null data\");\r\n    checkServiceLive();\r\n    path = createFullPath(path);\r\n    try {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Updating {} with {} bytes\", path, data.length);\r\n        }\r\n        curator.setData().forPath(path, data);\r\n    } catch (Exception e) {\r\n        throw operationFailure(path, \"update()\", e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "zkSet",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "boolean zkSet(String path, CreateMode mode, byte[] data, List<ACL> acl, boolean overwrite) throws IOException\n{\r\n    Preconditions.checkArgument(data != null, \"null data\");\r\n    checkServiceLive();\r\n    if (!zkPathExists(path)) {\r\n        zkCreate(path, mode, data, acl);\r\n        return true;\r\n    } else {\r\n        if (overwrite) {\r\n            zkUpdate(path, data);\r\n            return false;\r\n        } else {\r\n            throw new FileAlreadyExistsException(path);\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "zkDelete",
  "errType" : [ "KeeperException.NoNodeException", "Exception" ],
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void zkDelete(String path, boolean recursive, BackgroundCallback backgroundCallback) throws IOException\n{\r\n    checkServiceLive();\r\n    String fullpath = createFullPath(path);\r\n    try {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Deleting {}\", fullpath);\r\n        }\r\n        DeleteBuilder delete = curator.delete();\r\n        if (recursive) {\r\n            delete.deletingChildrenIfNeeded();\r\n        }\r\n        if (backgroundCallback != null) {\r\n            delete.inBackground(backgroundCallback);\r\n        }\r\n        delete.forPath(fullpath);\r\n    } catch (KeeperException.NoNodeException e) {\r\n    } catch (Exception e) {\r\n        throw operationFailure(fullpath, \"delete()\", e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "zkList",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "List<String> zkList(String path) throws IOException\n{\r\n    checkServiceLive();\r\n    String fullpath = createFullPath(path);\r\n    try {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"ls {}\", fullpath);\r\n        }\r\n        GetChildrenBuilder builder = curator.getChildren();\r\n        List<String> children = builder.forPath(fullpath);\r\n        return children;\r\n    } catch (Exception e) {\r\n        throw operationFailure(path, \"ls()\", e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "zkRead",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "byte[] zkRead(String path) throws IOException\n{\r\n    checkServiceLive();\r\n    String fullpath = createFullPath(path);\r\n    try {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Reading {}\", fullpath);\r\n        }\r\n        return curator.getData().forPath(fullpath);\r\n    } catch (Exception e) {\r\n        throw operationFailure(fullpath, \"read()\", e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "dumpPath",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "ZKPathDumper dumpPath(boolean verbose)\n{\r\n    return new ZKPathDumper(curator, registryRoot, verbose);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "addWriteAccessor",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "boolean addWriteAccessor(String id, String pass) throws IOException\n{\r\n    RegistrySecurity security = getRegistrySecurity();\r\n    ACL digestACL = new ACL(ZooDefs.Perms.ALL, security.toDigestId(security.digest(id, pass)));\r\n    return security.addDigestACL(digestACL);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "clearWriteAccessors",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void clearWriteAccessors()\n{\r\n    getRegistrySecurity().resetDigestACLs();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "dumpRegistryRobustly",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "String dumpRegistryRobustly(boolean verbose)\n{\r\n    try {\r\n        ZKPathDumper pathDumper = dumpPath(verbose);\r\n        return pathDumper.toString();\r\n    } catch (Exception e) {\r\n        LOG.debug(\"Ignoring exception:  {}\", e);\r\n    }\r\n    return \"\";\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "registerPathListener",
  "errType" : [ "IOException", "IOException" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void registerPathListener(final PathListener listener)\n{\r\n    CuratorCacheListener cacheListener = CuratorCacheListener.builder().forCreatesAndChanges((oldNode, node) -> {\r\n        final String path = node.getPath();\r\n        LOG.info(\"Informing listener of added/updated node {}\", path);\r\n        try {\r\n            listener.nodeAdded(path);\r\n        } catch (IOException e) {\r\n            LOG.error(\"Error while processing Curator listener \" + \"NODE_CREATED / NODE_CHANGED event\");\r\n            throw new UncheckedIOException(e);\r\n        }\r\n    }).forDeletes(childData -> {\r\n        final String path = childData.getPath();\r\n        LOG.info(\"Informing listener of removed node {}\", path);\r\n        try {\r\n            listener.nodeRemoved(path);\r\n        } catch (IOException e) {\r\n            LOG.error(\"Error while processing Curator listener \" + \"NODE_DELETED event\");\r\n            throw new UncheckedIOException(e);\r\n        }\r\n    }).build();\r\n    curatorCacheBridge.listenable().addListener(cacheListener);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "instantiateCacheForRegistry",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void instantiateCacheForRegistry()\n{\r\n    String registryPath = getConfig().get(RegistryConstants.KEY_REGISTRY_ZK_ROOT, RegistryConstants.DEFAULT_ZK_REGISTRY_ROOT);\r\n    curatorCacheBridge = CuratorCache.bridgeBuilder(curator, registryPath).build();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "startCache",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void startCache()\n{\r\n    curatorCacheBridge.start();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "addRecord",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void addRecord(Record r)\n{\r\n    if (records == null) {\r\n        records = new ArrayList<Record>();\r\n    }\r\n    super.addRecord(r);\r\n    records.add(r);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "removeRecord",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void removeRecord(Record r)\n{\r\n    if (records == null) {\r\n        records = new ArrayList<Record>();\r\n    }\r\n    super.removeRecord(r);\r\n    records.remove(r);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getNXTRecord",
  "errType" : null,
  "containingMethodsNum" : 13,
  "sourceCodeText" : "Record getNXTRecord(Record queryRecord, Zone zone)\n{\r\n    Collections.sort(records);\r\n    int index = Collections.binarySearch(records, queryRecord, new Comparator<Record>() {\r\n\r\n        @Override\r\n        public int compare(Record r1, Record r2) {\r\n            return r1.compareTo(r2);\r\n        }\r\n    });\r\n    if (index >= 0) {\r\n        return null;\r\n    }\r\n    index = -index - 1;\r\n    if (index >= records.size()) {\r\n        index = records.size() - 1;\r\n    }\r\n    Record base = records.get(index);\r\n    SetResponse sr = zone.findRecords(base.getName(), Type.ANY);\r\n    BitSet bitMap = new BitSet();\r\n    bitMap.set(Type.NXT);\r\n    for (RRset rRset : sr.answers()) {\r\n        int typeCode = rRset.getType();\r\n        if (typeCode > 0 && typeCode < 128) {\r\n            bitMap.set(typeCode);\r\n        }\r\n    }\r\n    return new NXTRecord(base.getName(), DClass.IN, zone.getSOA().getMinimum(), queryRecord.getName(), bitMap);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getReverseZoneNetworkAddress",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "String getReverseZoneNetworkAddress(String baseIp, int range, int index) throws UnknownHostException\n{\r\n    if (index < 0) {\r\n        throw new IllegalArgumentException(String.format(\"Invalid index provided, must be positive: %d\", index));\r\n    }\r\n    if (range < 0) {\r\n        throw new IllegalArgumentException(String.format(\"Invalid range provided, cannot be negative: %d\", range));\r\n    }\r\n    return calculateIp(baseIp, range, index);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getSubnetCountForReverseZones",
  "errType" : [ "NumberFormatException", "IllegalArgumentException" ],
  "containingMethodsNum" : 10,
  "sourceCodeText" : "long getSubnetCountForReverseZones(Configuration conf)\n{\r\n    String subnet = conf.get(KEY_DNS_ZONE_SUBNET);\r\n    String mask = conf.get(KEY_DNS_ZONE_MASK);\r\n    String range = conf.get(KEY_DNS_SPLIT_REVERSE_ZONE_RANGE);\r\n    int parsedRange;\r\n    try {\r\n        parsedRange = Integer.parseInt(range);\r\n    } catch (NumberFormatException e) {\r\n        LOG.error(\"The supplied range is not a valid integer: Supplied range: \", range);\r\n        throw e;\r\n    }\r\n    if (parsedRange < 0) {\r\n        String msg = String.format(\"Range cannot be negative: Supplied range: %d\", parsedRange);\r\n        LOG.error(msg);\r\n        throw new IllegalArgumentException(msg);\r\n    }\r\n    long ipCount;\r\n    try {\r\n        SubnetUtils subnetUtils = new SubnetUtils(subnet, mask);\r\n        subnetUtils.setInclusiveHostCount(true);\r\n        ipCount = subnetUtils.getInfo().getAddressCountLong();\r\n    } catch (IllegalArgumentException e) {\r\n        LOG.error(\"The subnet or mask is invalid: Subnet: {} Mask: {}\", subnet, mask);\r\n        throw e;\r\n    }\r\n    if (parsedRange == 0) {\r\n        return ipCount;\r\n    }\r\n    return ipCount / parsedRange;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "calculateIp",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "String calculateIp(String baseIp, int range, int index) throws UnknownHostException\n{\r\n    long[] ipParts = splitIp(baseIp);\r\n    long ipNum1 = POW3 * ipParts[0];\r\n    long ipNum2 = POW2 * ipParts[1];\r\n    long ipNum3 = POW1 * ipParts[2];\r\n    long ipNum4 = ipParts[3];\r\n    long ipNum = ipNum1 + ipNum2 + ipNum3 + ipNum4;\r\n    ArrayList<Long> ipPartsOut = new ArrayList<>();\r\n    long temp = ipNum + range * (long) index;\r\n    ipPartsOut.add(0, temp / POW3);\r\n    temp = temp - ipPartsOut.get(0) * POW3;\r\n    ipPartsOut.add(1, temp / POW2);\r\n    temp = temp - ipPartsOut.get(1) * POW2;\r\n    ipPartsOut.add(2, temp / POW1);\r\n    temp = temp - ipPartsOut.get(2) * POW1;\r\n    ipPartsOut.add(3, temp);\r\n    return StringUtils.join(ipPartsOut, '.');\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "splitIp",
  "errType" : [ "UnknownHostException" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "long[] splitIp(String baseIp) throws UnknownHostException\n{\r\n    InetAddress inetAddress;\r\n    try {\r\n        inetAddress = InetAddress.getByName(baseIp);\r\n    } catch (UnknownHostException e) {\r\n        LOG.error(\"Base IP address is invalid\");\r\n        throw e;\r\n    }\r\n    if (inetAddress instanceof Inet6Address) {\r\n        throw new IllegalArgumentException(\"IPv6 is not yet supported for \" + \"reverse zones\");\r\n    }\r\n    byte[] octets = inetAddress.getAddress();\r\n    if (octets.length != 4) {\r\n        throw new IllegalArgumentException(\"Base IP address is invalid\");\r\n    }\r\n    long[] results = new long[4];\r\n    for (int i = 0; i < octets.length; i++) {\r\n        results[i] = octets[i] & 0xff;\r\n    }\r\n    return results;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\api",
  "methodName" : "createInstance",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "DNSOperations createInstance(Configuration conf)\n{\r\n    return createInstance(\"DNSOperations\", DNSImplementation.DNSJAVA, conf);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\api",
  "methodName" : "createInstance",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "DNSOperations createInstance(String name, DNSImplementation impl, Configuration conf)\n{\r\n    Preconditions.checkArgument(conf != null, \"Null configuration\");\r\n    DNSOperations operations = null;\r\n    switch(impl) {\r\n        case DNSJAVA:\r\n            operations = new RegistryDNS(name);\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(String.format(\"%s is not available\", impl.toString()));\r\n    }\r\n    return operations;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\api",
  "methodName" : "createInstance",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "RegistryOperations createInstance(Configuration conf)\n{\r\n    return createInstance(\"RegistryOperations\", conf);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\api",
  "methodName" : "createInstance",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "RegistryOperations createInstance(String name, Configuration conf)\n{\r\n    Preconditions.checkArgument(conf != null, \"Null configuration\");\r\n    RegistryOperationsClient operations = new RegistryOperationsClient(name);\r\n    operations.init(conf);\r\n    return operations;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\api",
  "methodName" : "createClient",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "RegistryOperationsClient createClient(String name, Configuration conf)\n{\r\n    Preconditions.checkArgument(conf != null, \"Null configuration\");\r\n    RegistryOperationsClient operations = new RegistryOperationsClient(name);\r\n    operations.init(conf);\r\n    return operations;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\api",
  "methodName" : "createAnonymousInstance",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "RegistryOperations createAnonymousInstance(Configuration conf)\n{\r\n    Preconditions.checkArgument(conf != null, \"Null configuration\");\r\n    conf.set(KEY_REGISTRY_CLIENT_AUTH, REGISTRY_CLIENT_AUTH_ANONYMOUS);\r\n    return createInstance(\"AnonymousRegistryOperations\", conf);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\api",
  "methodName" : "createKerberosInstance",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "RegistryOperations createKerberosInstance(Configuration conf, String jaasContext)\n{\r\n    Preconditions.checkArgument(conf != null, \"Null configuration\");\r\n    conf.set(KEY_REGISTRY_CLIENT_AUTH, REGISTRY_CLIENT_AUTH_KERBEROS);\r\n    conf.set(KEY_REGISTRY_CLIENT_JAAS_CONTEXT, jaasContext);\r\n    return createInstance(\"KerberosRegistryOperations\", conf);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\api",
  "methodName" : "createKerberosInstance",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "RegistryOperations createKerberosInstance(Configuration conf, String jaasClientEntry, String principal, String keytab)\n{\r\n    Preconditions.checkArgument(conf != null, \"Null configuration\");\r\n    conf.set(KEY_REGISTRY_CLIENT_AUTH, REGISTRY_CLIENT_AUTH_KERBEROS);\r\n    conf.set(KEY_REGISTRY_CLIENT_JAAS_CONTEXT, jaasClientEntry);\r\n    RegistryOperationsClient operations = new RegistryOperationsClient(\"KerberosRegistryOperations\");\r\n    operations.setKerberosPrincipalAndKeytab(principal, keytab);\r\n    operations.init(conf);\r\n    return operations;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\api",
  "methodName" : "createAuthenticatedInstance",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "RegistryOperations createAuthenticatedInstance(Configuration conf, String id, String password)\n{\r\n    Preconditions.checkArgument(!StringUtils.isEmpty(id), \"empty Id\");\r\n    Preconditions.checkArgument(!StringUtils.isEmpty(password), \"empty Password\");\r\n    Preconditions.checkArgument(conf != null, \"Null configuration\");\r\n    conf.set(KEY_REGISTRY_CLIENT_AUTH, REGISTRY_CLIENT_AUTH_DIGEST);\r\n    conf.set(KEY_REGISTRY_CLIENT_AUTHENTICATION_ID, id);\r\n    conf.set(KEY_REGISTRY_CLIENT_AUTHENTICATION_PASSWORD, password);\r\n    return createInstance(\"DigestRegistryOperations\", conf);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "validateZKPath",
  "errType" : [ "IllegalArgumentException" ],
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String validateZKPath(String path) throws InvalidPathnameException\n{\r\n    try {\r\n        PathUtils.validatePath(path);\r\n    } catch (IllegalArgumentException e) {\r\n        throw new InvalidPathnameException(path, \"Invalid Path \\\"\" + path + \"\\\" : \" + e, e);\r\n    }\r\n    return path;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "validateElementsAsDNS",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String validateElementsAsDNS(String path) throws InvalidPathnameException\n{\r\n    List<String> splitpath = split(path);\r\n    for (String fragment : splitpath) {\r\n        if (!PATH_ENTRY_VALIDATION_PATTERN.matcher(fragment).matches()) {\r\n            throw new InvalidPathnameException(path, \"Invalid Path element \\\"\" + fragment + \"\\\"\");\r\n        }\r\n    }\r\n    return path;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "createFullPath",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "String createFullPath(String base, String path) throws InvalidPathnameException\n{\r\n    Preconditions.checkArgument(path != null, \"null path\");\r\n    Preconditions.checkArgument(base != null, \"null path\");\r\n    return validateZKPath(join(base, path));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "join",
  "errType" : null,
  "containingMethodsNum" : 15,
  "sourceCodeText" : "String join(String base, String path)\n{\r\n    Preconditions.checkArgument(path != null, \"null path\");\r\n    Preconditions.checkArgument(base != null, \"null path\");\r\n    StringBuilder fullpath = new StringBuilder();\r\n    if (!base.startsWith(\"/\")) {\r\n        fullpath.append('/');\r\n    }\r\n    fullpath.append(base);\r\n    if (!fullpath.toString().endsWith(\"/\")) {\r\n        fullpath.append(\"/\");\r\n    }\r\n    if (path.startsWith(\"/\")) {\r\n        if (path.length() > 1) {\r\n            fullpath.append(path.substring(1));\r\n        }\r\n    } else {\r\n        fullpath.append(path);\r\n    }\r\n    String finalpath = fullpath.toString();\r\n    if (finalpath.endsWith(\"/\") && !\"/\".equals(finalpath)) {\r\n        finalpath = finalpath.substring(0, finalpath.length() - 1);\r\n    }\r\n    return finalpath;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "split",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "List<String> split(String path)\n{\r\n    String[] pathelements = path.split(\"/\");\r\n    List<String> dirs = new ArrayList<String>(pathelements.length);\r\n    for (String pathelement : pathelements) {\r\n        if (!pathelement.isEmpty()) {\r\n            dirs.add(pathelement);\r\n        }\r\n    }\r\n    return dirs;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "lastPathEntry",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "String lastPathEntry(String path)\n{\r\n    List<String> splits = split(path);\r\n    if (splits.isEmpty()) {\r\n        return \"\";\r\n    } else {\r\n        return splits.get(splits.size() - 1);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "parentOf",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "String parentOf(String path) throws PathNotFoundException\n{\r\n    List<String> elements = split(path);\r\n    int size = elements.size();\r\n    if (size == 0) {\r\n        throw new PathNotFoundException(\"No parent of \" + path);\r\n    }\r\n    if (size == 1) {\r\n        return \"/\";\r\n    }\r\n    elements.remove(size - 1);\r\n    StringBuilder parent = new StringBuilder(path.length());\r\n    for (String element : elements) {\r\n        parent.append(\"/\");\r\n        parent.append(element);\r\n    }\r\n    return parent.toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "encodeForRegistry",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String encodeForRegistry(String element)\n{\r\n    return IDN.toASCII(element);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "encodeYarnID",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String encodeYarnID(String yarnId)\n{\r\n    return yarnId.replace(\"container\", \"ctr\").replace(\"_\", \"-\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "getUsername",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "String getUsername(String recPath)\n{\r\n    String user = \"anonymous\";\r\n    Matcher matcher = USER_NAME.matcher(recPath);\r\n    if (matcher.find()) {\r\n        user = matcher.group(1);\r\n    }\r\n    return user;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "fromBytes",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "T fromBytes(String path, byte[] bytes) throws IOException\n{\r\n    return fromBytes(path, bytes, \"\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "fromBytes",
  "errType" : [ "JsonProcessingException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "T fromBytes(String path, byte[] bytes, String marker) throws IOException\n{\r\n    int len = bytes.length;\r\n    if (len == 0) {\r\n        throw new NoRecordException(path, E_NO_DATA);\r\n    }\r\n    if (StringUtils.isNotEmpty(marker) && len < marker.length()) {\r\n        throw new NoRecordException(path, E_DATA_TOO_SHORT);\r\n    }\r\n    String json = new String(bytes, 0, len, UTF_8);\r\n    if (StringUtils.isNotEmpty(marker) && !json.contains(marker)) {\r\n        throw new NoRecordException(path, E_MISSING_MARKER_STRING + marker);\r\n    }\r\n    try {\r\n        return fromJson(json);\r\n    } catch (JsonProcessingException e) {\r\n        throw new InvalidRecordException(path, e.toString(), e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "initTypeToInfoMapping",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void initTypeToInfoMapping(ServiceRecord serviceRecord) throws Exception\n{\r\n    if (serviceRecord.get(YarnRegistryAttributes.YARN_IP) != null) {\r\n        for (int type : getRecordTypes()) {\r\n            switch(type) {\r\n                case Type.A:\r\n                    createAInfo(serviceRecord);\r\n                    break;\r\n                case Type.AAAA:\r\n                    createAAAAInfo(serviceRecord);\r\n                    break;\r\n                case Type.PTR:\r\n                    createPTRInfo(serviceRecord);\r\n                    break;\r\n                case Type.TXT:\r\n                    createTXTInfo(serviceRecord);\r\n                    break;\r\n                default:\r\n                    throw new IllegalArgumentException(\"Unknown type \" + type);\r\n            }\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "createTXTInfo",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void createTXTInfo(ServiceRecord serviceRecord) throws Exception\n{\r\n    TXTContainerRecordDescriptor txtInfo = new TXTContainerRecordDescriptor(getPath(), serviceRecord);\r\n    registerRecordDescriptor(Type.TXT, txtInfo);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "createPTRInfo",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void createPTRInfo(ServiceRecord record) throws Exception\n{\r\n    PTRContainerRecordDescriptor ptrInfo = new PTRContainerRecordDescriptor(getPath(), record);\r\n    registerRecordDescriptor(Type.PTR, ptrInfo);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "createAAAAInfo",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void createAAAAInfo(ServiceRecord record) throws Exception\n{\r\n    AAAAContainerRecordDescriptor recordInfo = new AAAAContainerRecordDescriptor(getPath(), record);\r\n    registerRecordDescriptor(Type.AAAA, recordInfo);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "createAInfo",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void createAInfo(ServiceRecord record) throws Exception\n{\r\n    AContainerRecordDescriptor recordInfo = new AContainerRecordDescriptor(getPath(), record);\r\n    registerRecordDescriptor(Type.A, recordInfo);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getRecordTypes",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "int[] getRecordTypes()\n{\r\n    return new int[] { Type.A, Type.AAAA, Type.PTR, Type.TXT };\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "toString",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "String toString()\n{\r\n    StringBuilder builder = new StringBuilder();\r\n    builder.append(\"ZK tree for \").append(root).append('\\n');\r\n    expand(builder, root, 1);\r\n    return builder.toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "expand",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 17,
  "sourceCodeText" : "void expand(StringBuilder builder, String path, int indent)\n{\r\n    try {\r\n        GetChildrenBuilder childrenBuilder = curator.getChildren();\r\n        List<String> children = childrenBuilder.forPath(path);\r\n        for (String child : children) {\r\n            String childPath = path + \"/\" + child;\r\n            String body;\r\n            Stat stat = curator.checkExists().forPath(childPath);\r\n            StringBuilder bodyBuilder = new StringBuilder(256);\r\n            bodyBuilder.append(\"  [\").append(stat.getDataLength()).append(\"]\");\r\n            if (stat.getEphemeralOwner() > 0) {\r\n                bodyBuilder.append(\"*\");\r\n            }\r\n            if (verbose) {\r\n                builder.append(\" -- \");\r\n                List<ACL> acls = curator.getACL().forPath(childPath);\r\n                for (ACL acl : acls) {\r\n                    builder.append(RegistrySecurity.aclToString(acl));\r\n                    builder.append(\" \");\r\n                }\r\n            }\r\n            body = bodyBuilder.toString();\r\n            append(builder, indent, ' ');\r\n            builder.append('/').append(child);\r\n            builder.append(body);\r\n            builder.append('\\n');\r\n            expand(builder, childPath, indent + INDENT);\r\n        }\r\n    } catch (Exception e) {\r\n        builder.append(e.toString()).append(\"\\n\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "append",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void append(StringBuilder builder, int indent, char c)\n{\r\n    for (int i = 0; i < indent; i++) {\r\n        builder.append(c);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\cli",
  "methodName" : "main",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void main(String[] args) throws Exception\n{\r\n    int res = -1;\r\n    try (RegistryCli cli = new RegistryCli(System.out, System.err)) {\r\n        res = ToolRunner.run(cli, args);\r\n    } catch (Exception e) {\r\n        ExitUtil.terminate(res, e);\r\n    }\r\n    ExitUtil.terminate(res);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\cli",
  "methodName" : "close",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void close() throws IOException\n{\r\n    ServiceOperations.stopQuietly(registry);\r\n    registry = null;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\cli",
  "methodName" : "usageError",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "int usageError(String err, String usage)\n{\r\n    syserr.println(\"Error: \" + err);\r\n    syserr.println(\"Usage: \" + usage);\r\n    return -1;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\cli",
  "methodName" : "validatePath",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "boolean validatePath(String path)\n{\r\n    if (!path.startsWith(\"/\")) {\r\n        syserr.println(\"Path must start with /; given path was: \" + path);\r\n        return false;\r\n    }\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\cli",
  "methodName" : "run",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "int run(String[] args) throws Exception\n{\r\n    Preconditions.checkArgument(getConf() != null, \"null configuration\");\r\n    if (args.length > 0) {\r\n        switch(args[0]) {\r\n            case \"ls\":\r\n                return ls(args);\r\n            case \"resolve\":\r\n                return resolve(args);\r\n            case \"bind\":\r\n                return bind(args);\r\n            case \"mknode\":\r\n                return mknode(args);\r\n            case \"rm\":\r\n                return rm(args);\r\n            default:\r\n                return usageError(\"Invalid command: \" + args[0], USAGE);\r\n        }\r\n    }\r\n    return usageError(\"No command arg passed.\", USAGE);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\cli",
  "methodName" : "ls",
  "errType" : [ "ParseException", "Exception" ],
  "containingMethodsNum" : 9,
  "sourceCodeText" : "int ls(String[] args)\n{\r\n    Options lsOption = new Options();\r\n    CommandLineParser parser = new GnuParser();\r\n    try {\r\n        CommandLine line = parser.parse(lsOption, args);\r\n        List<String> argsList = line.getArgList();\r\n        if (argsList.size() != 2) {\r\n            return usageError(\"ls requires exactly one path argument\", LS_USAGE);\r\n        }\r\n        if (!validatePath(argsList.get(1))) {\r\n            return -1;\r\n        }\r\n        try {\r\n            List<String> children = registry.list(argsList.get(1));\r\n            for (String child : children) {\r\n                sysout.println(child);\r\n            }\r\n            return 0;\r\n        } catch (Exception e) {\r\n            syserr.println(analyzeException(\"ls\", e, argsList));\r\n        }\r\n        return -1;\r\n    } catch (ParseException exp) {\r\n        return usageError(\"Invalid syntax \" + exp, LS_USAGE);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\cli",
  "methodName" : "resolve",
  "errType" : [ "ParseException", "Exception" ],
  "containingMethodsNum" : 14,
  "sourceCodeText" : "int resolve(String[] args)\n{\r\n    Options resolveOption = new Options();\r\n    CommandLineParser parser = new GnuParser();\r\n    try {\r\n        CommandLine line = parser.parse(resolveOption, args);\r\n        List<String> argsList = line.getArgList();\r\n        if (argsList.size() != 2) {\r\n            return usageError(\"resolve requires exactly one path argument\", RESOLVE_USAGE);\r\n        }\r\n        if (!validatePath(argsList.get(1))) {\r\n            return -1;\r\n        }\r\n        try {\r\n            ServiceRecord record = registry.resolve(argsList.get(1));\r\n            for (Endpoint endpoint : record.external) {\r\n                sysout.println(\" Endpoint(ProtocolType=\" + endpoint.protocolType + \", Api=\" + endpoint.api + \");\" + \" Addresses(AddressType=\" + endpoint.addressType + \") are: \");\r\n                for (Map<String, String> address : endpoint.addresses) {\r\n                    sysout.println(\"[ \");\r\n                    for (Map.Entry<String, String> entry : address.entrySet()) {\r\n                        sysout.print(\"\\t\" + entry.getKey() + \":\" + entry.getValue());\r\n                    }\r\n                    sysout.println(\"\\n]\");\r\n                }\r\n                sysout.println();\r\n            }\r\n            return 0;\r\n        } catch (Exception e) {\r\n            syserr.println(analyzeException(\"resolve\", e, argsList));\r\n        }\r\n        return -1;\r\n    } catch (ParseException exp) {\r\n        return usageError(\"Invalid syntax \" + exp, RESOLVE_USAGE);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\cli",
  "methodName" : "bind",
  "errType" : [ "ParseException", "URISyntaxException", "ParseException", "URISyntaxException", "ParseException", "NumberFormatException", "Exception" ],
  "containingMethodsNum" : 53,
  "sourceCodeText" : "int bind(String[] args)\n{\r\n    Option rest = OptionBuilder.withArgName(\"rest\").hasArg().withDescription(\"rest Option\").create(\"rest\");\r\n    Option webui = OptionBuilder.withArgName(\"webui\").hasArg().withDescription(\"webui Option\").create(\"webui\");\r\n    Option inet = OptionBuilder.withArgName(\"inet\").withDescription(\"inet Option\").create(\"inet\");\r\n    Option port = OptionBuilder.withArgName(\"port\").hasArg().withDescription(\"port to listen on [9999]\").create(\"p\");\r\n    Option host = OptionBuilder.withArgName(\"host\").hasArg().withDescription(\"host name\").create(\"h\");\r\n    Option apiOpt = OptionBuilder.withArgName(\"api\").hasArg().withDescription(\"api\").create(\"api\");\r\n    Options inetOption = new Options();\r\n    inetOption.addOption(inet);\r\n    inetOption.addOption(port);\r\n    inetOption.addOption(host);\r\n    inetOption.addOption(apiOpt);\r\n    Options webuiOpt = new Options();\r\n    webuiOpt.addOption(webui);\r\n    webuiOpt.addOption(apiOpt);\r\n    Options restOpt = new Options();\r\n    restOpt.addOption(rest);\r\n    restOpt.addOption(apiOpt);\r\n    CommandLineParser parser = new GnuParser();\r\n    ServiceRecord sr = new ServiceRecord();\r\n    CommandLine line;\r\n    if (args.length <= 1) {\r\n        return usageError(\"Invalid syntax \", BIND_USAGE);\r\n    }\r\n    if (args[1].equals(\"-inet\")) {\r\n        int portNum;\r\n        String hostName;\r\n        String api;\r\n        try {\r\n            line = parser.parse(inetOption, args);\r\n        } catch (ParseException exp) {\r\n            return usageError(\"Invalid syntax \" + exp.getMessage(), BIND_USAGE);\r\n        }\r\n        if (line.hasOption(\"inet\") && line.hasOption(\"p\") && line.hasOption(\"h\") && line.hasOption(\"api\")) {\r\n            try {\r\n                portNum = Integer.parseInt(line.getOptionValue(\"p\"));\r\n            } catch (NumberFormatException exp) {\r\n                return usageError(\"Invalid Port - int required\" + exp.getMessage(), BIND_USAGE);\r\n            }\r\n            hostName = line.getOptionValue(\"h\");\r\n            api = line.getOptionValue(\"api\");\r\n            sr.addExternalEndpoint(inetAddrEndpoint(api, ProtocolTypes.PROTOCOL_HADOOP_IPC, hostName, portNum));\r\n        } else {\r\n            return usageError(\"Missing options: must have host, port and api\", BIND_USAGE);\r\n        }\r\n    } else if (args[1].equals(\"-webui\")) {\r\n        try {\r\n            line = parser.parse(webuiOpt, args);\r\n        } catch (ParseException exp) {\r\n            return usageError(\"Invalid syntax \" + exp.getMessage(), BIND_USAGE);\r\n        }\r\n        if (line.hasOption(\"webui\") && line.hasOption(\"api\")) {\r\n            URI theUri;\r\n            try {\r\n                theUri = new URI(line.getOptionValue(\"webui\"));\r\n            } catch (URISyntaxException e) {\r\n                return usageError(\"Invalid URI: \" + e.getMessage(), BIND_USAGE);\r\n            }\r\n            sr.addExternalEndpoint(webEndpoint(line.getOptionValue(\"api\"), theUri));\r\n        } else {\r\n            return usageError(\"Missing options: must have value for uri and api\", BIND_USAGE);\r\n        }\r\n    } else if (args[1].equals(\"-rest\")) {\r\n        try {\r\n            line = parser.parse(restOpt, args);\r\n        } catch (ParseException exp) {\r\n            return usageError(\"Invalid syntax \" + exp.getMessage(), BIND_USAGE);\r\n        }\r\n        if (line.hasOption(\"rest\") && line.hasOption(\"api\")) {\r\n            URI theUri = null;\r\n            try {\r\n                theUri = new URI(line.getOptionValue(\"rest\"));\r\n            } catch (URISyntaxException e) {\r\n                return usageError(\"Invalid URI: \" + e.getMessage(), BIND_USAGE);\r\n            }\r\n            sr.addExternalEndpoint(restEndpoint(line.getOptionValue(\"api\"), theUri));\r\n        } else {\r\n            return usageError(\"Missing options: must have value for uri and api\", BIND_USAGE);\r\n        }\r\n    } else {\r\n        return usageError(\"Invalid syntax\", BIND_USAGE);\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    List<String> argsList = line.getArgList();\r\n    if (argsList.size() != 2) {\r\n        return usageError(\"bind requires exactly one path argument\", BIND_USAGE);\r\n    }\r\n    if (!validatePath(argsList.get(1))) {\r\n        return -1;\r\n    }\r\n    try {\r\n        registry.bind(argsList.get(1), sr, BindFlags.OVERWRITE);\r\n        return 0;\r\n    } catch (Exception e) {\r\n        syserr.println(analyzeException(\"bind\", e, argsList));\r\n    }\r\n    return -1;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 7,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\cli",
  "methodName" : "mknode",
  "errType" : [ "ParseException", "Exception" ],
  "containingMethodsNum" : 8,
  "sourceCodeText" : "int mknode(String[] args)\n{\r\n    Options mknodeOption = new Options();\r\n    CommandLineParser parser = new GnuParser();\r\n    try {\r\n        CommandLine line = parser.parse(mknodeOption, args);\r\n        List<String> argsList = line.getArgList();\r\n        if (argsList.size() != 2) {\r\n            return usageError(\"mknode requires exactly one path argument\", MKNODE_USAGE);\r\n        }\r\n        if (!validatePath(argsList.get(1))) {\r\n            return -1;\r\n        }\r\n        try {\r\n            registry.mknode(args[1], false);\r\n            return 0;\r\n        } catch (Exception e) {\r\n            syserr.println(analyzeException(\"mknode\", e, argsList));\r\n        }\r\n        return -1;\r\n    } catch (ParseException exp) {\r\n        return usageError(\"Invalid syntax \" + exp.toString(), MKNODE_USAGE);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\cli",
  "methodName" : "rm",
  "errType" : [ "ParseException", "Exception" ],
  "containingMethodsNum" : 11,
  "sourceCodeText" : "int rm(String[] args)\n{\r\n    Option recursive = OptionBuilder.withArgName(\"recursive\").withDescription(\"delete recursively\").create(\"r\");\r\n    Options rmOption = new Options();\r\n    rmOption.addOption(recursive);\r\n    boolean recursiveOpt = false;\r\n    CommandLineParser parser = new GnuParser();\r\n    try {\r\n        CommandLine line = parser.parse(rmOption, args);\r\n        List<String> argsList = line.getArgList();\r\n        if (argsList.size() != 2) {\r\n            return usageError(\"RM requires exactly one path argument\", RM_USAGE);\r\n        }\r\n        if (!validatePath(argsList.get(1))) {\r\n            return -1;\r\n        }\r\n        try {\r\n            if (line.hasOption(\"r\")) {\r\n                recursiveOpt = true;\r\n            }\r\n            registry.delete(argsList.get(1), recursiveOpt);\r\n            return 0;\r\n        } catch (Exception e) {\r\n            syserr.println(analyzeException(\"rm\", e, argsList));\r\n        }\r\n        return -1;\r\n    } catch (ParseException exp) {\r\n        return usageError(\"Invalid syntax \" + exp.toString(), RM_USAGE);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\cli",
  "methodName" : "analyzeException",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "String analyzeException(String operation, Exception e, List<String> argsList)\n{\r\n    String pathArg = !argsList.isEmpty() ? argsList.get(1) : \"(none)\";\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"Operation {} on path {} failed with exception {}\", operation, pathArg, e, e);\r\n    }\r\n    if (e instanceof InvalidPathnameException) {\r\n        return \"InvalidPath :\" + pathArg + \": \" + e;\r\n    }\r\n    if (e instanceof PathNotFoundException) {\r\n        return \"Path not found: \" + pathArg;\r\n    }\r\n    if (e instanceof NoRecordException) {\r\n        return \"No service record at path \" + pathArg;\r\n    }\r\n    if (e instanceof AuthenticationFailedException) {\r\n        return \"Failed to authenticate to registry : \" + e;\r\n    }\r\n    if (e instanceof NoPathPermissionsException) {\r\n        return \"No Permission to path: \" + pathArg + \": \" + e;\r\n    }\r\n    if (e instanceof AccessControlException) {\r\n        return \"No Permission to path: \" + pathArg + \": \" + e;\r\n    }\r\n    if (e instanceof InvalidRecordException) {\r\n        return \"Unable to read record at: \" + pathArg + \": \" + e;\r\n    }\r\n    if (e instanceof IOException) {\r\n        return \"IO Exception when accessing path :\" + pathArg + \": \" + e;\r\n    }\r\n    return \"Exception \" + e;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "initTypeToInfoMapping",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "void initTypeToInfoMapping(ServiceRecord serviceRecord) throws Exception\n{\r\n    if (serviceRecord.external.isEmpty()) {\r\n        LOG.info(serviceRecord.description + \": No external endpoints defined.\");\r\n        return;\r\n    }\r\n    for (int type : getRecordTypes()) {\r\n        switch(type) {\r\n            case Type.A:\r\n                createAInfo(serviceRecord);\r\n                break;\r\n            case Type.AAAA:\r\n                createAAAAInfo(serviceRecord);\r\n                break;\r\n            case Type.TXT:\r\n                createTXTInfo(serviceRecord);\r\n                break;\r\n            case Type.CNAME:\r\n                createCNAMEInfo(serviceRecord);\r\n                break;\r\n            case Type.SRV:\r\n                createSRVInfo(serviceRecord);\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(\"Unknown type \" + type);\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "createTXTInfo",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void createTXTInfo(ServiceRecord serviceRecord) throws Exception\n{\r\n    List<Endpoint> endpoints = serviceRecord.external;\r\n    List<RecordDescriptor> recordDescriptors = new ArrayList<>();\r\n    TXTApplicationRecordDescriptor txtInfo;\r\n    for (Endpoint endpoint : endpoints) {\r\n        txtInfo = new TXTApplicationRecordDescriptor(serviceRecord, endpoint);\r\n        recordDescriptors.add(txtInfo);\r\n    }\r\n    registerRecordDescriptor(Type.TXT, recordDescriptors);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "createSRVInfo",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void createSRVInfo(ServiceRecord serviceRecord) throws Exception\n{\r\n    List<Endpoint> endpoints = serviceRecord.external;\r\n    List<RecordDescriptor> recordDescriptors = new ArrayList<>();\r\n    SRVApplicationRecordDescriptor srvInfo;\r\n    for (Endpoint endpoint : endpoints) {\r\n        srvInfo = new SRVApplicationRecordDescriptor(serviceRecord, endpoint);\r\n        recordDescriptors.add(srvInfo);\r\n    }\r\n    registerRecordDescriptor(Type.SRV, recordDescriptors);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "createCNAMEInfo",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void createCNAMEInfo(ServiceRecord serviceRecord) throws Exception\n{\r\n    List<Endpoint> endpoints = serviceRecord.external;\r\n    List<RecordDescriptor> recordDescriptors = new ArrayList<>();\r\n    CNAMEApplicationRecordDescriptor cnameInfo;\r\n    for (Endpoint endpoint : endpoints) {\r\n        cnameInfo = new CNAMEApplicationRecordDescriptor(serviceRecord, endpoint);\r\n        recordDescriptors.add(cnameInfo);\r\n    }\r\n    registerRecordDescriptor(Type.CNAME, recordDescriptors);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "createAAAAInfo",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void createAAAAInfo(ServiceRecord record) throws Exception\n{\r\n    AAAAApplicationRecordDescriptor recordInfo = new AAAAApplicationRecordDescriptor(getPath(), record);\r\n    registerRecordDescriptor(Type.AAAA, recordInfo);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "createAInfo",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void createAInfo(ServiceRecord record) throws Exception\n{\r\n    AApplicationRecordDescriptor recordInfo = new AApplicationRecordDescriptor(getPath(), record);\r\n    registerRecordDescriptor(Type.A, recordInfo);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getRecordTypes",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "int[] getRecordTypes()\n{\r\n    return new int[] { Type.A, Type.AAAA, Type.CNAME, Type.SRV, Type.TXT };\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "serviceInit",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void serviceInit(Configuration conf) throws Exception\n{\r\n    pathToRecordMap = new ConcurrentHashMap<>();\r\n    registryOperations = new RegistryOperationsService(\"RegistryDNSOperations\");\r\n    addService(registryOperations);\r\n    if (registryDNS == null) {\r\n        registryDNS = (RegistryDNS) DNSOperationsFactory.createInstance(conf);\r\n    }\r\n    addService(registryDNS);\r\n    super.serviceInit(conf);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "serviceStart",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void serviceStart() throws Exception\n{\r\n    super.serviceStart();\r\n    manageRegistryDNS();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "manageRegistryDNS",
  "errType" : [ "Exception", "PathNotFoundException" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void manageRegistryDNS()\n{\r\n    try {\r\n        registryOperations.instantiateCacheForRegistry();\r\n        registryOperations.registerPathListener(new PathListener() {\r\n\r\n            private String registryRoot = getConfig().get(RegistryConstants.KEY_REGISTRY_ZK_ROOT, RegistryConstants.DEFAULT_ZK_REGISTRY_ROOT);\r\n\r\n            @Override\r\n            public void nodeAdded(String path) throws IOException {\r\n                String relativePath = getPathRelativeToRegistryRoot(path);\r\n                String child = RegistryPathUtils.lastPathEntry(path);\r\n                Map<String, RegistryPathStatus> map = new HashMap<>();\r\n                map.put(child, registryOperations.stat(relativePath));\r\n                Map<String, ServiceRecord> records = RegistryUtils.extractServiceRecords(registryOperations, getAdjustedParentPath(path), map);\r\n                processServiceRecords(records, register);\r\n                pathToRecordMap.putAll(records);\r\n            }\r\n\r\n            private String getAdjustedParentPath(String path) {\r\n                Preconditions.checkNotNull(path);\r\n                String adjustedPath = null;\r\n                adjustedPath = getPathRelativeToRegistryRoot(path);\r\n                try {\r\n                    return RegistryPathUtils.parentOf(adjustedPath);\r\n                } catch (PathNotFoundException e) {\r\n                    return path;\r\n                }\r\n            }\r\n\r\n            private String getPathRelativeToRegistryRoot(String path) {\r\n                String adjustedPath;\r\n                if (path.equals(registryRoot)) {\r\n                    adjustedPath = \"/\";\r\n                } else {\r\n                    adjustedPath = path.substring(registryRoot.length());\r\n                }\r\n                return adjustedPath;\r\n            }\r\n\r\n            @Override\r\n            public void nodeRemoved(String path) throws IOException {\r\n                ServiceRecord record = pathToRecordMap.remove(path.substring(registryRoot.length()));\r\n                processServiceRecord(path, record, delete);\r\n            }\r\n        });\r\n        registryOperations.startCache();\r\n    } catch (Exception e) {\r\n        LOG.warn(\"Unable to monitor the registry.  DNS support disabled.\", e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "processServiceRecords",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void processServiceRecords(Map<String, ServiceRecord> records, ManagementCommand command) throws IOException\n{\r\n    for (Map.Entry<String, ServiceRecord> entry : records.entrySet()) {\r\n        processServiceRecord(entry.getKey(), entry.getValue(), command);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "processServiceRecord",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void processServiceRecord(String path, ServiceRecord record, ManagementCommand command) throws IOException\n{\r\n    command.exec(path, record);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "launchDNSServer",
  "errType" : [ "Throwable" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "RegistryDNSServer launchDNSServer(Configuration conf, RegistryDNS rdns)\n{\r\n    RegistryDNSServer dnsServer = null;\r\n    Thread.setDefaultUncaughtExceptionHandler(new HadoopUncaughtExceptionHandler());\r\n    try {\r\n        dnsServer = new RegistryDNSServer(\"RegistryDNSServer\", rdns);\r\n        ShutdownHookManager.get().addShutdownHook(new CompositeService.CompositeServiceShutdownHook(dnsServer), SHUTDOWN_HOOK_PRIORITY);\r\n        dnsServer.init(conf);\r\n        dnsServer.start();\r\n    } catch (Throwable t) {\r\n        LOG.error(\"Error starting Registry DNS Server\", t);\r\n        ExitUtil.terminate(-1, \"Error starting Registry DNS Server\");\r\n    }\r\n    return dnsServer;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "main",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void main(String[] args) throws IOException\n{\r\n    StringUtils.startupShutdownMessage(RegistryDNSServer.class, args, LOG);\r\n    Configuration conf = new RegistryConfiguration();\r\n    new GenericOptionsParser(conf, args);\r\n    launchDNSServer(conf, null);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "getClientAcls",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "List<ACL> getClientAcls()\n{\r\n    return getRegistrySecurity().getClientACLs();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "validatePath",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void validatePath(String path) throws InvalidPathnameException\n{\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "mknode",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "boolean mknode(String path, boolean createParents) throws IOException\n{\r\n    validatePath(path);\r\n    return zkMkPath(path, CreateMode.PERSISTENT, createParents, getClientAcls());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "bind",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void bind(String path, ServiceRecord record, int flags) throws IOException\n{\r\n    Preconditions.checkArgument(record != null, \"null record\");\r\n    validatePath(path);\r\n    RegistryTypeUtils.validateServiceRecord(path, record);\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"Bound at {} : ServiceRecord = {}\", path, record);\r\n    }\r\n    CreateMode mode = CreateMode.PERSISTENT;\r\n    byte[] bytes = serviceRecordMarshal.toBytes(record);\r\n    zkSet(path, mode, bytes, getClientAcls(), ((flags & BindFlags.OVERWRITE) != 0));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "resolve",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "ServiceRecord resolve(String path) throws IOException\n{\r\n    byte[] bytes = zkRead(path);\r\n    ServiceRecord record = serviceRecordMarshal.fromBytes(path, bytes, ServiceRecord.RECORD_TYPE);\r\n    RegistryTypeUtils.validateServiceRecord(path, record);\r\n    return record;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "exists",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "boolean exists(String path) throws IOException\n{\r\n    validatePath(path);\r\n    return zkPathExists(path);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "stat",
  "errType" : null,
  "containingMethodsNum" : 8,
  "sourceCodeText" : "RegistryPathStatus stat(String path) throws IOException\n{\r\n    validatePath(path);\r\n    Stat stat = zkStat(path);\r\n    String name = RegistryPathUtils.lastPathEntry(path);\r\n    RegistryPathStatus status = new RegistryPathStatus(name, stat.getCtime(), stat.getDataLength(), stat.getNumChildren());\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"Stat {} => {}\", path, status);\r\n    }\r\n    return status;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "list",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "List<String> list(String path) throws IOException\n{\r\n    validatePath(path);\r\n    return zkList(path);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "delete",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void delete(String path, boolean recursive) throws IOException\n{\r\n    validatePath(path);\r\n    zkDelete(path, recursive, null);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "homePathForUser",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "String homePathForUser(String username)\n{\r\n    Preconditions.checkArgument(username != null, \"null user\");\r\n    if (username.startsWith(RegistryConstants.PATH_USERS)) {\r\n        return username;\r\n    }\r\n    if (username.isEmpty()) {\r\n        return RegistryConstants.PATH_SYSTEM_SERVICES;\r\n    }\r\n    String convertedName = convertUsername(username);\r\n    return RegistryPathUtils.join(RegistryConstants.PATH_USERS, encodeForRegistry(convertedName));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "convertUsername",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "String convertUsername(String username)\n{\r\n    String converted = org.apache.hadoop.util.StringUtils.toLowerCase(username);\r\n    int atSymbol = converted.indexOf('@');\r\n    if (atSymbol > 0) {\r\n        converted = converted.substring(0, atSymbol);\r\n    }\r\n    int slashSymbol = converted.indexOf('/');\r\n    if (slashSymbol > 0) {\r\n        converted = converted.substring(0, slashSymbol);\r\n    }\r\n    return converted;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "serviceclassPath",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String serviceclassPath(String user, String serviceClass)\n{\r\n    String services = join(homePathForUser(user), RegistryConstants.PATH_USER_SERVICES);\r\n    return join(services, serviceClass);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "servicePath",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String servicePath(String user, String serviceClass, String serviceName)\n{\r\n    return join(serviceclassPath(user, serviceClass), serviceName);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "componentListPath",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String componentListPath(String user, String serviceClass, String serviceName)\n{\r\n    return join(servicePath(user, serviceClass, serviceName), RegistryConstants.SUBPATH_COMPONENTS);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "componentPath",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String componentPath(String user, String serviceClass, String serviceName, String componentName)\n{\r\n    return join(componentListPath(user, serviceClass, serviceName), componentName);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "listServiceRecords",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "Map<String, ServiceRecord> listServiceRecords(RegistryOperations registryOperations, String path) throws IOException\n{\r\n    Map<String, RegistryPathStatus> children = statChildren(registryOperations, path);\r\n    return extractServiceRecords(registryOperations, path, children.values());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "statChildren",
  "errType" : [ "PathNotFoundException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "Map<String, RegistryPathStatus> statChildren(RegistryOperations registryOperations, String path) throws PathNotFoundException, InvalidPathnameException, IOException\n{\r\n    List<String> childNames = registryOperations.list(path);\r\n    Map<String, RegistryPathStatus> results = new HashMap<String, RegistryPathStatus>();\r\n    for (String childName : childNames) {\r\n        String child = join(path, childName);\r\n        try {\r\n            RegistryPathStatus stat = registryOperations.stat(child);\r\n            results.put(childName, stat);\r\n        } catch (PathNotFoundException pnfe) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"stat failed on {}: moved? {}\", child, pnfe, pnfe);\r\n            }\r\n        }\r\n    }\r\n    return results;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "homePathForCurrentUser",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String homePathForCurrentUser()\n{\r\n    String shortUserName = currentUsernameUnencoded();\r\n    return homePathForUser(shortUserName);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "currentUsernameUnencoded",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String currentUsernameUnencoded()\n{\r\n    String env_hadoop_username = System.getenv(RegistryInternalConstants.HADOOP_USER_NAME);\r\n    return getCurrentUsernameUnencoded(env_hadoop_username);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "getCurrentUsernameUnencoded",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "String getCurrentUsernameUnencoded(String env_hadoop_username)\n{\r\n    String shortUserName = null;\r\n    if (!UserGroupInformation.isSecurityEnabled()) {\r\n        shortUserName = env_hadoop_username;\r\n    }\r\n    if (StringUtils.isEmpty(shortUserName)) {\r\n        try {\r\n            shortUserName = UserGroupInformation.getCurrentUser().getShortUserName();\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n    return shortUserName;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "currentUser",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String currentUser()\n{\r\n    String shortUserName = currentUsernameUnencoded();\r\n    return registryUser(shortUserName);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "registryUser",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "String registryUser(String shortUserName)\n{\r\n    String encodedName = encodeForRegistry(shortUserName);\r\n    encodedName = RegistryUtils.convertUsername(encodedName);\r\n    return encodedName.replace(\"_\", \"-\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "extractServiceRecords",
  "errType" : [ "EOFException", "InvalidRecordException", "NoRecordException" ],
  "containingMethodsNum" : 11,
  "sourceCodeText" : "Map<String, ServiceRecord> extractServiceRecords(RegistryOperations operations, String parentpath, Collection<RegistryPathStatus> stats) throws IOException\n{\r\n    Map<String, ServiceRecord> results = new HashMap<String, ServiceRecord>(stats.size());\r\n    for (RegistryPathStatus stat : stats) {\r\n        if (stat.size > ServiceRecord.RECORD_TYPE.length()) {\r\n            String path = join(parentpath, stat.path);\r\n            try {\r\n                ServiceRecord serviceRecord = operations.resolve(path);\r\n                results.put(path, serviceRecord);\r\n            } catch (EOFException ignored) {\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"data too short for {}\", path);\r\n                }\r\n            } catch (InvalidRecordException record) {\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Invalid record at {}\", path);\r\n                }\r\n            } catch (NoRecordException record) {\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"No record at {}\", path);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return results;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "extractServiceRecords",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Map<String, ServiceRecord> extractServiceRecords(RegistryOperations operations, String parentpath, Map<String, RegistryPathStatus> stats) throws IOException\n{\r\n    return extractServiceRecords(operations, parentpath, stats.values());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\binding",
  "methodName" : "extractServiceRecords",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Map<String, ServiceRecord> extractServiceRecords(RegistryOperations operations, String parentpath) throws IOException\n{\r\n    return extractServiceRecords(operations, parentpath, statChildren(operations, parentpath).values());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "equals",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "boolean equals(Object other)\n{\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other == null || getClass() != other.getClass()) {\r\n        return false;\r\n    }\r\n    RegistryPathStatus status = (RegistryPathStatus) other;\r\n    if (size != status.size) {\r\n        return false;\r\n    }\r\n    if (time != status.time) {\r\n        return false;\r\n    }\r\n    if (path != null ? !path.equals(status.path) : status.path != null) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "hashCode",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "int hashCode()\n{\r\n    return path != null ? path.hashCode() : 0;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "toString",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "String toString()\n{\r\n    final StringBuilder sb = new StringBuilder(\"RegistryPathStatus{\");\r\n    sb.append(\"path='\").append(path).append('\\'');\r\n    sb.append(\", time=\").append(time);\r\n    sb.append(\", size=\").append(size);\r\n    sb.append(\", children=\").append(children);\r\n    sb.append('}');\r\n    return sb.toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "addExternalEndpoint",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void addExternalEndpoint(Endpoint endpoint)\n{\r\n    Preconditions.checkArgument(endpoint != null);\r\n    endpoint.validate();\r\n    external.add(endpoint);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "addInternalEndpoint",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void addInternalEndpoint(Endpoint endpoint)\n{\r\n    Preconditions.checkArgument(endpoint != null);\r\n    endpoint.validate();\r\n    internal.add(endpoint);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "getInternalEndpoint",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Endpoint getInternalEndpoint(String api)\n{\r\n    return findByAPI(internal, api);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "getExternalEndpoint",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Endpoint getExternalEndpoint(String api)\n{\r\n    return findByAPI(external, api);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "set",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void set(String key, Object value)\n{\r\n    attributes.put(key, value.toString());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "attributes",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Map<String, String> attributes()\n{\r\n    return attributes;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "get",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String get(String key)\n{\r\n    return attributes.get(key);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "get",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String get(String key, String defVal)\n{\r\n    String val = attributes.get(key);\r\n    return val != null ? val : defVal;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "findByAPI",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Endpoint findByAPI(List<Endpoint> list, String api)\n{\r\n    for (Endpoint endpoint : list) {\r\n        if (endpoint.api.equals(api)) {\r\n            return endpoint;\r\n        }\r\n    }\r\n    return null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "toString",
  "errType" : null,
  "containingMethodsNum" : 15,
  "sourceCodeText" : "String toString()\n{\r\n    final StringBuilder sb = new StringBuilder(\"ServiceRecord{\");\r\n    sb.append(\"description='\").append(description).append('\\'');\r\n    sb.append(\"; external endpoints: {\");\r\n    for (Endpoint endpoint : external) {\r\n        sb.append(endpoint).append(\"; \");\r\n    }\r\n    sb.append(\"}; internal endpoints: {\");\r\n    for (Endpoint endpoint : internal) {\r\n        sb.append(endpoint != null ? endpoint.toString() : \"NULL ENDPOINT\");\r\n        sb.append(\"; \");\r\n    }\r\n    sb.append('}');\r\n    if (!attributes.isEmpty()) {\r\n        sb.append(\", attributes: {\");\r\n        for (Map.Entry<String, String> attr : attributes.entrySet()) {\r\n            sb.append(\"\\\"\").append(attr.getKey()).append(\"\\\"=\\\"\").append(attr.getValue()).append(\"\\\" \");\r\n        }\r\n    } else {\r\n        sb.append(\", attributes: {\");\r\n    }\r\n    sb.append('}');\r\n    sb.append('}');\r\n    return sb.toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "clone",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Object clone() throws CloneNotSupportedException\n{\r\n    return super.clone();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "hashCode",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "int hashCode()\n{\r\n    final int prime = 31;\r\n    int result = 1;\r\n    result = prime * result + ((attributes == null) ? 0 : attributes.hashCode());\r\n    result = prime * result + ((description == null) ? 0 : description.hashCode());\r\n    result = prime * result + ((external == null) ? 0 : external.hashCode());\r\n    result = prime * result + ((internal == null) ? 0 : internal.hashCode());\r\n    result = prime * result + ((type == null) ? 0 : type.hashCode());\r\n    return result;\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "equals",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "boolean equals(Object obj)\n{\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj == null) {\r\n        return false;\r\n    }\r\n    if (getClass() != obj.getClass()) {\r\n        return false;\r\n    }\r\n    ServiceRecord other = (ServiceRecord) obj;\r\n    if (attributes == null) {\r\n        if (other.attributes != null) {\r\n            return false;\r\n        }\r\n    } else if (!attributes.equals(other.attributes)) {\r\n        return false;\r\n    }\r\n    if (description == null) {\r\n        if (other.description != null) {\r\n            return false;\r\n        }\r\n    } else if (!description.equals(other.description)) {\r\n        return false;\r\n    }\r\n    if (external == null) {\r\n        if (other.external != null) {\r\n            return false;\r\n        }\r\n    } else if (!external.equals(other.external)) {\r\n        return false;\r\n    }\r\n    if (internal == null) {\r\n        if (other.internal != null) {\r\n            return false;\r\n        }\r\n    } else if (!internal.equals(other.internal)) {\r\n        return false;\r\n    }\r\n    if (type == null) {\r\n        if (other.type != null) {\r\n            return false;\r\n        }\r\n    } else if (!type.equals(other.type)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\integration",
  "methodName" : "shouldSelect",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "boolean shouldSelect(String path, RegistryPathStatus registryPathStatus, ServiceRecord serviceRecord)\n{\r\n    String policy = serviceRecord.get(YarnRegistryAttributes.YARN_PERSISTENCE, \"\");\r\n    return id.equals(serviceRecord.get(YarnRegistryAttributes.YARN_ID, \"\")) && (targetPolicy.equals(policy));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\integration",
  "methodName" : "toString",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String toString()\n{\r\n    return String.format(\"Select by ID %s and policy %s: {}\", id, targetPolicy);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "init",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void init(DaemonContext context) throws Exception\n{\r\n    String[] args = context.getArguments();\r\n    StringUtils.startupShutdownMessage(RegistryDNSServer.class, args, LOG);\r\n    conf = new RegistryConfiguration();\r\n    new GenericOptionsParser(conf, args);\r\n    int port = conf.getInt(KEY_DNS_PORT, DEFAULT_DNS_PORT);\r\n    if (port < 1 || port > 1023) {\r\n        throw new RuntimeException(\"Must start privileged registry DNS server \" + \"with '\" + KEY_DNS_PORT + \"' configured to a privileged port.\");\r\n    }\r\n    try {\r\n        registryDNS = (RegistryDNS) DNSOperationsFactory.createInstance(conf);\r\n        registryDNS.initializeChannels(conf);\r\n    } catch (Exception e) {\r\n        LOG.error(\"Error initializing Registry DNS\", e);\r\n        throw e;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "start",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void start() throws Exception\n{\r\n    registryDNSServer = RegistryDNSServer.launchDNSServer(conf, registryDNS);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "stop",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void stop() throws Exception\n{\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "destroy",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void destroy()\n{\r\n    registryDNSServer.stop();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "processResult",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void processResult(CuratorFramework client, CuratorEvent event) throws Exception\n{\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"Delete event {}\", event);\r\n    }\r\n    events.incrementAndGet();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "getEventCount",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "int getEventCount()\n{\r\n    return events.get();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "newAddresses",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "List<Map<String, String>> newAddresses(int size)\n{\r\n    return new ArrayList<Map<String, String>>(size);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "toString",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String toString()\n{\r\n    return marshalToString.toString(this);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "validate",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void validate()\n{\r\n    Preconditions.checkNotNull(api, \"null API field\");\r\n    Preconditions.checkNotNull(addressType, \"null addressType field\");\r\n    Preconditions.checkNotNull(protocolType, \"null protocolType field\");\r\n    Preconditions.checkNotNull(addresses, \"null addresses field\");\r\n    for (Map<String, String> address : addresses) {\r\n        Preconditions.checkNotNull(address, \"null element in address\");\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\types",
  "methodName" : "clone",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Object clone() throws CloneNotSupportedException\n{\r\n    return super.clone();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "initializeChannels",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void initializeChannels(Configuration conf) throws Exception\n{\r\n    if (channelsInitialized) {\r\n        return;\r\n    }\r\n    channelsInitialized = true;\r\n    int port = conf.getInt(KEY_DNS_PORT, DEFAULT_DNS_PORT);\r\n    InetAddress addr = InetAddress.getLocalHost();\r\n    String bindAddress = conf.get(KEY_DNS_BIND_ADDRESS);\r\n    if (bindAddress != null) {\r\n        addr = InetAddress.getByName(bindAddress);\r\n    }\r\n    LOG.info(\"Opening TCP and UDP channels on {} port {}\", addr, port);\r\n    addNIOUDP(addr, port);\r\n    addNIOTCP(addr, port);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "updateDNSServer",
  "errType" : [ "SocketException" ],
  "containingMethodsNum" : 22,
  "sourceCodeText" : "void updateDNSServer(Configuration conf)\n{\r\n    synchronized (resolverUpdateLock) {\r\n        if (!resolverUpdateRequested) {\r\n            return;\r\n        }\r\n        int port = conf.getInt(KEY_DNS_PORT, DEFAULT_DNS_PORT);\r\n        resolverUpdateRequested = false;\r\n        List<InetAddress> list = new ArrayList<InetAddress>();\r\n        try {\r\n            if (port != 53) {\r\n                throw new SocketException(\"Bypass filtering local DNS server.\");\r\n            }\r\n            Enumeration<NetworkInterface> net = NetworkInterface.getNetworkInterfaces();\r\n            while (net.hasMoreElements()) {\r\n                NetworkInterface n = (NetworkInterface) net.nextElement();\r\n                Enumeration<InetAddress> ee = n.getInetAddresses();\r\n                while (ee.hasMoreElements()) {\r\n                    InetAddress i = (InetAddress) ee.nextElement();\r\n                    list.add(i);\r\n                }\r\n            }\r\n        } catch (SocketException e) {\r\n        }\r\n        ResolverConfig.refresh();\r\n        ExtendedResolver resolver = new ExtendedResolver();\r\n        for (Resolver check : resolver.getResolvers()) {\r\n            if (check instanceof SimpleResolver) {\r\n                InetAddress address = ((SimpleResolver) check).getAddress().getAddress();\r\n                if (list.contains(address)) {\r\n                    resolver.deleteResolver(check);\r\n                    continue;\r\n                } else {\r\n                    check.setTimeout(Duration.ofSeconds(30));\r\n                }\r\n            } else {\r\n                LOG.error(\"Not simple resolver!!!?\" + check);\r\n            }\r\n        }\r\n        synchronized (Lookup.class) {\r\n            Lookup.setDefaultResolver(resolver);\r\n            Lookup.setDefaultSearchPath(ResolverConfig.getCurrentConfig().searchPath());\r\n        }\r\n        StringBuilder message = new StringBuilder();\r\n        message.append(\"DNS servers: \");\r\n        for (InetSocketAddress address : ResolverConfig.getCurrentConfig().servers()) {\r\n            message.append(address);\r\n            message.append(\" \");\r\n        }\r\n        LOG.info(message.toString());\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "serviceInit",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void serviceInit(Configuration conf) throws Exception\n{\r\n    super.serviceInit(conf);\r\n    try {\r\n        updateDNSServer(conf);\r\n        setDomainName(conf);\r\n        initializeZones(conf);\r\n        initializeChannels(conf);\r\n    } catch (IOException e) {\r\n        LOG.error(\"Error initializing Registry DNS Server\", e);\r\n        throw e;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "initializeZones",
  "errType" : null,
  "containingMethodsNum" : 11,
  "sourceCodeText" : "void initializeZones(Configuration conf) throws IOException\n{\r\n    ttl = conf.getTimeDuration(KEY_DNS_TTL, 1L, TimeUnit.SECONDS);\r\n    RecordCreatorFactory.setTtl(ttl);\r\n    setDNSSECEnabled(conf);\r\n    initializeZonesFromFiles(conf);\r\n    Zone registryZone = configureZone(Name.fromString(domainName), conf);\r\n    zones.put(registryZone.getOrigin(), registryZone);\r\n    initializeReverseLookupZone(conf);\r\n    StringBuilder builder = new StringBuilder();\r\n    builder.append(\"DNS zones: \").append(System.lineSeparator());\r\n    for (Map.Entry<Name, Zone> entry : zones.entrySet()) {\r\n        builder.append(System.lineSeparator()).append(entry.getValue());\r\n    }\r\n    LOG.info(builder.toString());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "signZones",
  "errType" : [ "DNSSEC.DNSSECException" ],
  "containingMethodsNum" : 7,
  "sourceCodeText" : "void signZones() throws IOException\n{\r\n    if (isDNSSECEnabled()) {\r\n        Collection<Zone> zoneCollection = zones.values();\r\n        for (Zone zone : zoneCollection) {\r\n            Iterator<RRset> itor = zone.iterator();\r\n            while (itor.hasNext()) {\r\n                RRset rRset = itor.next();\r\n                if (!rRset.sigs().isEmpty()) {\r\n                    try {\r\n                        signSiteRecord(zone, rRset.first());\r\n                    } catch (DNSSEC.DNSSECException e) {\r\n                        throw new IOException(e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "initializeZonesFromFiles",
  "errType" : null,
  "containingMethodsNum" : 9,
  "sourceCodeText" : "void initializeZonesFromFiles(Configuration conf) throws IOException\n{\r\n    String zonesDir = conf.get(KEY_DNS_ZONES_DIR);\r\n    if (zonesDir != null) {\r\n        Iterator<File> iterator = FileUtils.iterateFiles(new File(zonesDir), new IOFileFilter() {\r\n\r\n            @Override\r\n            public boolean accept(File file) {\r\n                return file.getName().endsWith(ZONE_SUFFIX);\r\n            }\r\n\r\n            @Override\r\n            public boolean accept(File file, String s) {\r\n                return s.endsWith(ZONE_SUFFIX);\r\n            }\r\n        }, null);\r\n        while (iterator.hasNext()) {\r\n            File file = iterator.next();\r\n            String name = file.getName();\r\n            name = name.substring(0, name.indexOf(ZONE_SUFFIX) + 1);\r\n            Zone zone = new SecureableZone(Name.fromString(name), file.getAbsolutePath());\r\n            zones.putIfAbsent(zone.getOrigin(), zone);\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getZoneCount",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "int getZoneCount()\n{\r\n    return zones.size();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "initializeReverseLookupZone",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void initializeReverseLookupZone(Configuration conf) throws IOException\n{\r\n    Boolean shouldSplitReverseZone = conf.getBoolean(KEY_DNS_SPLIT_REVERSE_ZONE, DEFAULT_DNS_SPLIT_REVERSE_ZONE);\r\n    if (shouldSplitReverseZone) {\r\n        long subnetCount = ReverseZoneUtils.getSubnetCountForReverseZones(conf);\r\n        addSplitReverseZones(conf, subnetCount);\r\n    } else {\r\n        Name reverseLookupZoneName = getReverseZoneName(conf);\r\n        if (reverseLookupZoneName == null) {\r\n            return;\r\n        }\r\n        Zone reverseLookupZone = configureZone(reverseLookupZoneName, conf);\r\n        zones.put(reverseLookupZone.getOrigin(), reverseLookupZone);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "addSplitReverseZones",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void addSplitReverseZones(Configuration conf, long subnetCount) throws IOException\n{\r\n    String subnet = conf.get(KEY_DNS_ZONE_SUBNET);\r\n    String range = conf.get(KEY_DNS_SPLIT_REVERSE_ZONE_RANGE);\r\n    for (int idx = 0; idx < subnetCount; idx++) {\r\n        Name reverseLookupZoneName = getReverseZoneName(ReverseZoneUtils.getReverseZoneNetworkAddress(subnet, Integer.parseInt(range), idx));\r\n        Zone reverseLookupZone = configureZone(reverseLookupZoneName, conf);\r\n        zones.put(reverseLookupZone.getOrigin(), reverseLookupZone);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getReverseZoneName",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "Name getReverseZoneName(Configuration conf)\n{\r\n    Name name = null;\r\n    String zoneSubnet = getZoneSubnet(conf);\r\n    if (zoneSubnet == null) {\r\n        LOG.warn(\"Zone subnet is not configured.  Reverse lookups disabled\");\r\n    } else {\r\n        String mask = conf.get(KEY_DNS_ZONE_MASK);\r\n        if (mask != null) {\r\n            SubnetUtils utils = new SubnetUtils(zoneSubnet, mask);\r\n            name = getReverseZoneName(utils, zoneSubnet);\r\n        } else {\r\n            name = getReverseZoneName(zoneSubnet);\r\n        }\r\n    }\r\n    return name;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getZoneSubnet",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String getZoneSubnet(Configuration conf)\n{\r\n    String subnet = conf.get(KEY_DNS_ZONE_SUBNET);\r\n    if (subnet != null) {\r\n        final String[] bytes = subnet.split(\"\\\\.\");\r\n        if (bytes.length == 3) {\r\n            subnet += \".0\";\r\n        }\r\n    }\r\n    return subnet;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getReverseZoneName",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Name getReverseZoneName(String networkAddress)\n{\r\n    return getReverseZoneName(null, networkAddress);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getReverseZoneName",
  "errType" : [ "TextParseException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "Name getReverseZoneName(SubnetUtils utils, String networkAddress)\n{\r\n    Name reverseZoneName = null;\r\n    boolean isLargeNetwork = false;\r\n    if (utils != null) {\r\n        isLargeNetwork = utils.getInfo().getAddressCountLong() > 256;\r\n    }\r\n    final String[] bytes = networkAddress.split(\"\\\\.\");\r\n    if (bytes.length == 4) {\r\n        String reverseLookupZoneName = null;\r\n        if (isLargeNetwork) {\r\n            reverseLookupZoneName = String.format(\"%s.%s.%s\", bytes[1], bytes[0], IN_ADDR_ARPA);\r\n        } else {\r\n            reverseLookupZoneName = String.format(\"%s.%s.%s.%s\", bytes[2], bytes[1], bytes[0], IN_ADDR_ARPA);\r\n        }\r\n        try {\r\n            reverseZoneName = Name.fromString(reverseLookupZoneName);\r\n        } catch (TextParseException e) {\r\n            LOG.warn(\"Unable to convert {} to DNS name\", reverseLookupZoneName);\r\n        }\r\n    }\r\n    return reverseZoneName;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "configureZone",
  "errType" : [ "NoSuchAlgorithmException", "InvalidKeySpecException", "DNSSEC.DNSSECException" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "Zone configureZone(Name zoneName, Configuration conf) throws IOException\n{\r\n    bindHost = Name.fromString(InetAddress.getLocalHost().getCanonicalHostName() + \".\");\r\n    SOARecord soaRecord = new SOARecord(zoneName, DClass.IN, ttl, bindHost, bindHost, getSerial(), 86000, 7200, 1209600, 600);\r\n    NSRecord nsRecord = new NSRecord(zoneName, DClass.IN, ttl, bindHost);\r\n    Zone zone = zones.get(zoneName);\r\n    if (zone == null) {\r\n        zone = new SecureableZone(zoneName, new Record[] { soaRecord, nsRecord });\r\n    }\r\n    try {\r\n        enableDNSSECIfNecessary(zone, conf, soaRecord, nsRecord);\r\n    } catch (NoSuchAlgorithmException e) {\r\n        throw new IOException(e);\r\n    } catch (InvalidKeySpecException e) {\r\n        throw new IOException(e);\r\n    } catch (DNSSEC.DNSSECException e) {\r\n        throw new IOException(e);\r\n    }\r\n    return zone;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getSerial",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "long getSerial()\n{\r\n    Date curDate = new Date();\r\n    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyyMMddHH\");\r\n    String serial = simpleDateFormat.format(curDate);\r\n    return Long.parseLong(serial);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "setDNSSECEnabled",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void setDNSSECEnabled(Configuration conf)\n{\r\n    dnssecEnabled = conf.getBoolean(KEY_DNSSEC_ENABLED, false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "isDNSSECEnabled",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean isDNSSECEnabled()\n{\r\n    return dnssecEnabled;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "enableDNSSECIfNecessary",
  "errType" : null,
  "containingMethodsNum" : 20,
  "sourceCodeText" : "void enableDNSSECIfNecessary(Zone zone, Configuration conf, SOARecord soaRecord, NSRecord nsRecord) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, DNSSEC.DNSSECException\n{\r\n    if (isDNSSECEnabled()) {\r\n        String publicKey = conf.get(KEY_DNSSEC_PUBLIC_KEY);\r\n        if (publicKey == null) {\r\n            throw new IOException(\"DNSSEC Key not configured\");\r\n        }\r\n        Name zoneName = zone.getOrigin();\r\n        DNSKEYRecord dnskeyRecord = dnsKeyRecs.get(zoneName);\r\n        if (dnskeyRecord == null) {\r\n            byte[] key = Base64.decodeBase64(publicKey.getBytes(\"UTF-8\"));\r\n            dnskeyRecord = new DNSKEYRecord(zoneName, DClass.IN, ttl, DNSKEYRecord.Flags.ZONE_KEY, DNSKEYRecord.Protocol.DNSSEC, DNSSEC.Algorithm.RSASHA256, key);\r\n            dnsKeyRecs.putIfAbsent(zoneName, dnskeyRecord);\r\n        }\r\n        LOG.info(\"Registering {}\", dnskeyRecord);\r\n        try (CloseableLock lock = writeLock.lock()) {\r\n            zone.addRecord(dnskeyRecord);\r\n            String privateKeyFile = conf.get(KEY_DNSSEC_PRIVATE_KEY_FILE, DEFAULT_DNSSEC_PRIVATE_KEY_FILE);\r\n            Properties props = new Properties();\r\n            try (FileInputStream inputStream = new FileInputStream(privateKeyFile)) {\r\n                props.load(inputStream);\r\n            }\r\n            String privateModulus = props.getProperty(\"Modulus\");\r\n            String privateExponent = props.getProperty(\"PrivateExponent\");\r\n            RSAPrivateKeySpec privateSpec = new RSAPrivateKeySpec(new BigInteger(1, Base64.decodeBase64(privateModulus)), new BigInteger(1, Base64.decodeBase64(privateExponent)));\r\n            KeyFactory factory = KeyFactory.getInstance(\"RSA\");\r\n            privateKey = factory.generatePrivate(privateSpec);\r\n            signSiteRecord(zone, dnskeyRecord);\r\n            signSiteRecord(zone, soaRecord);\r\n            signSiteRecord(zone, nsRecord);\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "signSiteRecord",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void signSiteRecord(Zone zone, Record record) throws DNSSEC.DNSSECException\n{\r\n    RRset rrset = zone.findExactMatch(record.getName(), record.getType());\r\n    Instant inception = Instant.now();\r\n    Instant expiration = inception.plus(365, ChronoUnit.DAYS);\r\n    RRSIGRecord rrsigRecord = DNSSEC.sign(rrset, dnsKeyRecs.get(zone.getOrigin()), privateKey, inception, expiration);\r\n    LOG.info(\"Adding {}\", record);\r\n    rrset.addRR(rrsigRecord);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "setDomainName",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void setDomainName(Configuration conf) throws IOException\n{\r\n    domainName = conf.get(KEY_DNS_DOMAIN);\r\n    if (domainName == null) {\r\n        throw new IOException(\"No DNS domain name specified\");\r\n    }\r\n    if (!domainName.endsWith(\".\")) {\r\n        domainName += \".\";\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "serviceStop",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void serviceStop() throws Exception\n{\r\n    stopExecutor();\r\n    super.serviceStop();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "stopExecutor",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void stopExecutor()\n{\r\n    if (executor != null) {\r\n        executor.shutdownNow();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "formErrorMessage",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 1,
  "sourceCodeText" : "byte[] formErrorMessage(byte[] in)\n{\r\n    Header header;\r\n    try {\r\n        header = new Header(in);\r\n    } catch (IOException e) {\r\n        return null;\r\n    }\r\n    return buildErrorMessage(header, Rcode.FORMERR, null);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "nioTCPClient",
  "errType" : [ "IOException", "BufferUnderflowException", "IOException" ],
  "containingMethodsNum" : 17,
  "sourceCodeText" : "void nioTCPClient(SocketChannel ch) throws IOException\n{\r\n    try {\r\n        ByteBuffer buf = ByteBuffer.allocate(1024);\r\n        ch.read(buf);\r\n        buf.flip();\r\n        int messageLength = getMessgeLength(buf);\r\n        byte[] in = new byte[messageLength];\r\n        buf.get(in, 0, messageLength);\r\n        Message query;\r\n        byte[] response;\r\n        try {\r\n            query = new Message(in);\r\n            LOG.info(\"received TCP query {}\", query.getQuestion());\r\n            response = generateReply(query, ch.socket());\r\n            if (response == null) {\r\n                return;\r\n            }\r\n        } catch (IOException e) {\r\n            response = formErrorMessage(in);\r\n        }\r\n        ByteBuffer out = ByteBuffer.allocate(response.length + 2);\r\n        out.clear();\r\n        byte[] data = new byte[2];\r\n        data[1] = (byte) (response.length & 0xFF);\r\n        data[0] = (byte) ((response.length >> 8) & 0xFF);\r\n        out.put(data);\r\n        out.put(response);\r\n        out.flip();\r\n        while (out.hasRemaining()) {\r\n            ch.write(out);\r\n        }\r\n    } catch (IOException e) {\r\n        throw NetUtils.wrapException(ch.socket().getInetAddress().getHostName(), ch.socket().getPort(), ch.socket().getLocalAddress().getHostName(), ch.socket().getLocalPort(), e);\r\n    } catch (BufferUnderflowException e) {\r\n    } finally {\r\n        IOUtils.closeStream(ch);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getMessgeLength",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "int getMessgeLength(ByteBuffer buf) throws EOFException\n{\r\n    int ch1 = buf.get();\r\n    int ch2 = buf.get();\r\n    if ((ch1 | ch2) < 0) {\r\n        throw new EOFException();\r\n    }\r\n    return (ch1 << 8) + (ch2 & 0xff);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "serveNIOTCP",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void serveNIOTCP(ServerSocketChannel serverSocketChannel, InetAddress addr, int port) throws Exception\n{\r\n    try {\r\n        while (true) {\r\n            final SocketChannel socketChannel = serverSocketChannel.accept();\r\n            if (socketChannel != null) {\r\n                executor.submit(new Callable<Boolean>() {\r\n\r\n                    @Override\r\n                    public Boolean call() throws Exception {\r\n                        nioTCPClient(socketChannel);\r\n                        return true;\r\n                    }\r\n                });\r\n            } else {\r\n                Thread.sleep(500);\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        throw NetUtils.wrapException(addr.getHostName(), port, addr.getHostName(), port, e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "openTCPChannel",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "ServerSocketChannel openTCPChannel(InetAddress addr, int port) throws IOException\n{\r\n    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\r\n    try {\r\n        serverSocketChannel.socket().bind(new InetSocketAddress(addr, port));\r\n        serverSocketChannel.configureBlocking(false);\r\n    } catch (IOException e) {\r\n        throw NetUtils.wrapException(null, 0, InetAddress.getLocalHost().getHostName(), port, e);\r\n    }\r\n    return serverSocketChannel;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "addNIOTCP",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void addNIOTCP(final InetAddress addr, final int port) throws Exception\n{\r\n    final ServerSocketChannel tcpChannel = openTCPChannel(addr, port);\r\n    executor.submit(new Callable<Boolean>() {\r\n\r\n        @Override\r\n        public Boolean call() throws Exception {\r\n            try {\r\n                serveNIOTCP(tcpChannel, addr, port);\r\n            } catch (Exception e) {\r\n                LOG.error(\"Error initializing DNS TCP listener\", e);\r\n                throw e;\r\n            }\r\n            return true;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "addNIOUDP",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void addNIOUDP(final InetAddress addr, final int port) throws Exception\n{\r\n    final DatagramChannel udpChannel = openUDPChannel(addr, port);\r\n    executor.submit(new Callable<Boolean>() {\r\n\r\n        @Override\r\n        public Boolean call() throws Exception {\r\n            try {\r\n                serveNIOUDP(udpChannel, addr, port);\r\n            } catch (Exception e) {\r\n                LOG.error(\"Error initializing DNS UDP listener\", e);\r\n                throw e;\r\n            }\r\n            return true;\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "serveNIOUDP",
  "errType" : [ "Exception", "IOException", "IOException" ],
  "containingMethodsNum" : 17,
  "sourceCodeText" : "void serveNIOUDP(DatagramChannel channel, InetAddress addr, int port) throws Exception\n{\r\n    SocketAddress remoteAddress = null;\r\n    try {\r\n        ByteBuffer input = ByteBuffer.allocate(4096);\r\n        ByteBuffer output = ByteBuffer.allocate(4096);\r\n        byte[] in = null;\r\n        while (true) {\r\n            input.clear();\r\n            try {\r\n                remoteAddress = channel.receive(input);\r\n            } catch (IOException e) {\r\n                LOG.debug(\"Error during message receipt\", e);\r\n                continue;\r\n            }\r\n            Message query;\r\n            byte[] response = null;\r\n            try {\r\n                int position = input.position();\r\n                in = new byte[position];\r\n                input.flip();\r\n                input.get(in);\r\n                query = new Message(in);\r\n                LOG.info(\"{}: received UDP query {}\", remoteAddress, query.getQuestion());\r\n                response = generateReply(query, null);\r\n                if (response == null) {\r\n                    continue;\r\n                }\r\n            } catch (IOException e) {\r\n                response = formErrorMessage(in);\r\n            }\r\n            output.clear();\r\n            output.put(response);\r\n            output.flip();\r\n            LOG.debug(\"{}:  sending response\", remoteAddress);\r\n            channel.send(output, remoteAddress);\r\n        }\r\n    } catch (Exception e) {\r\n        if (e instanceof IOException && remoteAddress != null) {\r\n            throw NetUtils.wrapException(addr.getHostName(), port, ((InetSocketAddress) remoteAddress).getHostName(), ((InetSocketAddress) remoteAddress).getPort(), (IOException) e);\r\n        } else {\r\n            throw e;\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 3,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "openUDPChannel",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 3,
  "sourceCodeText" : "DatagramChannel openUDPChannel(InetAddress addr, int port) throws IOException\n{\r\n    DatagramChannel channel = DatagramChannel.open();\r\n    try {\r\n        channel.socket().bind(new InetSocketAddress(addr, port));\r\n    } catch (IOException e) {\r\n        throw NetUtils.wrapException(null, 0, InetAddress.getLocalHost().getHostName(), port, e);\r\n    }\r\n    return channel;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "buildErrorMessage",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "byte[] buildErrorMessage(Header header, int rcode, Record question)\n{\r\n    Message response = new Message();\r\n    response.setHeader(header);\r\n    for (int i = 0; i < 4; i++) {\r\n        response.removeAllRecords(i);\r\n    }\r\n    response.addRecord(question, Section.QUESTION);\r\n    header.setRcode(rcode);\r\n    return response.toWire();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "errorMessage",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "byte[] errorMessage(Message query, int rcode)\n{\r\n    return buildErrorMessage(query.getHeader(), rcode, query.getQuestion());\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "generateReply",
  "errType" : null,
  "containingMethodsNum" : 31,
  "sourceCodeText" : "byte[] generateReply(Message query, Socket s) throws IOException\n{\r\n    Header header;\r\n    boolean badversion;\r\n    int maxLength;\r\n    int flags = 0;\r\n    OPTRecord queryOPT = query.getOPT();\r\n    maxLength = getMaxLength(s, queryOPT);\r\n    header = query.getHeader();\r\n    if (header.getFlag(Flags.QR)) {\r\n        LOG.debug(\"returning null\");\r\n        return null;\r\n    }\r\n    if (header.getRcode() != Rcode.NOERROR) {\r\n        return errorMessage(query, Rcode.FORMERR);\r\n    }\r\n    if (header.getOpcode() != Opcode.QUERY) {\r\n        return errorMessage(query, Rcode.NOTIMP);\r\n    }\r\n    Record queryRecord = query.getQuestion();\r\n    if (queryOPT != null && (queryOPT.getFlags() & ExtendedFlags.DO) != 0) {\r\n        flags = FLAG_DNSSECOK;\r\n    }\r\n    Message response = new Message(query.getHeader().getID());\r\n    response.getHeader().setFlag(Flags.QR);\r\n    if (query.getHeader().getFlag(Flags.RD)) {\r\n        response.getHeader().setFlag(Flags.RD);\r\n        response.getHeader().setFlag(Flags.RA);\r\n    }\r\n    response.addRecord(queryRecord, Section.QUESTION);\r\n    Name name = queryRecord.getName();\r\n    int type = queryRecord.getType();\r\n    int dclass = queryRecord.getDClass();\r\n    TSIGRecord queryTSIG = query.getTSIG();\r\n    if (type == Type.AXFR && s != null) {\r\n        return doAXFR(name, query, null, queryTSIG, s);\r\n    }\r\n    if (!Type.isRR(type) && type != Type.ANY) {\r\n        return errorMessage(query, Rcode.NOTIMP);\r\n    }\r\n    LOG.debug(\"calling addAnswer\");\r\n    byte rcode = addAnswer(response, name, type, dclass, 0, flags);\r\n    if (rcode != Rcode.NOERROR) {\r\n        rcode = remoteLookup(response, name, type, 0);\r\n        response.getHeader().setRcode(rcode);\r\n    }\r\n    addAdditional(response, flags);\r\n    if (queryOPT != null) {\r\n        int optflags = (flags == FLAG_DNSSECOK) ? ExtendedFlags.DO : 0;\r\n        OPTRecord opt = new OPTRecord((short) 4096, rcode >>> 16, (byte) 0, optflags);\r\n        response.addRecord(opt, Section.ADDITIONAL);\r\n    }\r\n    return response.toWire(maxLength);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "remoteLookup",
  "errType" : [ "NullPointerException", "Throwable" ],
  "containingMethodsNum" : 12,
  "sourceCodeText" : "byte remoteLookup(Message response, Name name, int type, int iterations)\n{\r\n    if (name.toString().equals(\".\")) {\r\n        type = Type.NS;\r\n    }\r\n    if (type != Type.CNAME) {\r\n        Record[] cnameAnswers = getRecords(name, Type.CNAME);\r\n        if (cnameAnswers != null) {\r\n            for (Record cnameR : cnameAnswers) {\r\n                if (!response.findRecord(cnameR)) {\r\n                    response.addRecord(cnameR, Section.ANSWER);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Record[] answers = getRecords(name, type);\r\n    try {\r\n        for (Record r : answers) {\r\n            if (!response.findRecord(r)) {\r\n                if (r.getType() == Type.SOA) {\r\n                    response.addRecord(r, Section.AUTHORITY);\r\n                } else {\r\n                    response.addRecord(r, Section.ANSWER);\r\n                }\r\n            }\r\n            if (r.getType() == Type.CNAME) {\r\n                Name cname = r.getName();\r\n                if (iterations < 6) {\r\n                    remoteLookup(response, cname, type, iterations + 1);\r\n                }\r\n            }\r\n        }\r\n    } catch (NullPointerException e) {\r\n        return Rcode.NXDOMAIN;\r\n    } catch (Throwable e) {\r\n        return Rcode.SERVFAIL;\r\n    }\r\n    return Rcode.NOERROR;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getRecords",
  "errType" : [ "InterruptedException|ExecutionException|TimeoutException|NullPointerException|ExceptionInInitializerError" ],
  "containingMethodsNum" : 5,
  "sourceCodeText" : "Record[] getRecords(Name name, int type)\n{\r\n    Record[] result = null;\r\n    ExecutorService executor = Executors.newSingleThreadExecutor();\r\n    Future<Record[]> future = executor.submit(new LookupTask(name, type));\r\n    try {\r\n        result = future.get(1500, TimeUnit.MILLISECONDS);\r\n        return result;\r\n    } catch (InterruptedException | ExecutionException | TimeoutException | NullPointerException | ExceptionInInitializerError e) {\r\n        LOG.warn(\"Failed to lookup: {} type: {}\", name, Type.string(type), e);\r\n        return result;\r\n    } finally {\r\n        executor.shutdown();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "createPrimaryQuery",
  "errType" : null,
  "containingMethodsNum" : 10,
  "sourceCodeText" : "Message createPrimaryQuery(Message query) throws NameTooLongException, TextParseException\n{\r\n    Name name = query.getQuestion().getName();\r\n    if (name.labels() > 0 && name.labels() <= 2) {\r\n        int id = query.getHeader().getID();\r\n        String queryName = name.getLabelString(0);\r\n        Name qualifiedName = Name.concatenate(Name.fromString(queryName), Name.fromString(domainName));\r\n        LOG.info(\"Received query {}.  Forwarding query {}\", name, qualifiedName);\r\n        Record question = Record.newRecord(qualifiedName, query.getQuestion().getType(), query.getQuestion().getDClass());\r\n        query = Message.newQuery(question);\r\n        query.getHeader().setID(id);\r\n    }\r\n    return query;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getMaxLength",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "int getMaxLength(Socket s, OPTRecord queryOPT)\n{\r\n    int maxLength;\r\n    if (s != null) {\r\n        maxLength = 65535;\r\n    } else if (queryOPT != null) {\r\n        maxLength = Math.max(queryOPT.getPayloadSize(), 512);\r\n    } else {\r\n        maxLength = 512;\r\n    }\r\n    return maxLength;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "addAdditional2",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void addAdditional2(Message response, int section, int flags)\n{\r\n    for (Record r : response.getSection(section)) {\r\n        Name glueName = r.getAdditionalName();\r\n        if (glueName != null) {\r\n            addGlue(response, glueName, flags);\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "addAdditional",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void addAdditional(Message response, int flags)\n{\r\n    addAdditional2(response, Section.ANSWER, flags);\r\n    addAdditional2(response, Section.AUTHORITY, flags);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "addGlue",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void addGlue(Message response, Name name, int flags)\n{\r\n    RRset a = findExactMatch(name, Type.A);\r\n    if (a == null) {\r\n        return;\r\n    }\r\n    addRRset(name, response, a, Section.ADDITIONAL, flags);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "findExactMatch",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "RRset findExactMatch(Name name, int type)\n{\r\n    try (CloseableLock lock = readLock.lock()) {\r\n        Zone zone = findBestZone(name);\r\n        if (zone != null) {\r\n            return zone.findExactMatch(name, type);\r\n        }\r\n    }\r\n    return null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "findBestZone",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "Zone findBestZone(Name name)\n{\r\n    Zone foundzone = null;\r\n    foundzone = zones.get(name);\r\n    if (foundzone != null) {\r\n        return foundzone;\r\n    }\r\n    int labels = name.labels();\r\n    for (int i = 1; i < labels; i++) {\r\n        Name tname = new Name(name, i);\r\n        foundzone = zones.get(tname);\r\n        if (foundzone != null) {\r\n            return foundzone;\r\n        }\r\n    }\r\n    return null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "addAnswer",
  "errType" : [ "TextParseException", "Exception" ],
  "containingMethodsNum" : 33,
  "sourceCodeText" : "byte addAnswer(Message response, Name name, int type, int dclass, int iterations, int flags)\n{\r\n    SetResponse sr = null;\r\n    byte rcode = Rcode.NOERROR;\r\n    if (iterations > 6) {\r\n        return Rcode.NOERROR;\r\n    }\r\n    if (type == Type.SIG || type == Type.RRSIG) {\r\n        type = Type.ANY;\r\n        flags |= FLAG_SIGONLY;\r\n    }\r\n    Zone zone = findBestZone(name);\r\n    LOG.debug(\"finding record\");\r\n    try (CloseableLock lock = readLock.lock()) {\r\n        if (zone != null) {\r\n            sr = zone.findRecords(name, type);\r\n        } else {\r\n            rcode = Rcode.NOTAUTH;\r\n        }\r\n    }\r\n    LOG.info(\"found local record? {}\", sr != null && sr.isSuccessful());\r\n    if (sr != null) {\r\n        if (sr.isCNAME()) {\r\n            CNAMERecord cname = sr.getCNAME();\r\n            RRset rrset = zone.findExactMatch(cname.getName(), Type.CNAME);\r\n            addRRset(name, response, rrset, Section.ANSWER, flags);\r\n            if (iterations == 0) {\r\n                response.getHeader().setFlag(Flags.AA);\r\n            }\r\n            rcode = addAnswer(response, cname.getTarget(), type, dclass, iterations + 1, flags);\r\n        }\r\n        if (sr.isNXDOMAIN()) {\r\n            response.getHeader().setRcode(Rcode.NXDOMAIN);\r\n            if (isDNSSECEnabled()) {\r\n                try {\r\n                    addNXT(response, flags);\r\n                } catch (Exception e) {\r\n                    LOG.warn(\"Unable to add NXTRecord to AUTHORITY Section\", e);\r\n                }\r\n            }\r\n            addSOA(response, zone, flags);\r\n            if (iterations == 0) {\r\n                response.getHeader().setFlag(Flags.AA);\r\n            }\r\n            rcode = Rcode.NXDOMAIN;\r\n        } else if (sr.isNXRRSET()) {\r\n            LOG.info(\"No data found the given name {} and type {}\", name, type);\r\n            addSOA(response, zone, flags);\r\n            if (iterations == 0) {\r\n                response.getHeader().setFlag(Flags.AA);\r\n            }\r\n        } else if (sr.isSuccessful()) {\r\n            List<RRset> rrsets = sr.answers();\r\n            LOG.info(\"found answers {}\", rrsets);\r\n            for (RRset rrset : rrsets) {\r\n                addRRset(name, response, rrset, Section.ANSWER, flags);\r\n            }\r\n            addNS(response, zone, flags);\r\n            if (iterations == 0) {\r\n                response.getHeader().setFlag(Flags.AA);\r\n            }\r\n        }\r\n    } else {\r\n        if (zone != null) {\r\n            Name defaultDomain = null;\r\n            try {\r\n                defaultDomain = Name.fromString(domainName);\r\n                zone = zones.get(defaultDomain);\r\n                addNS(response, zone, flags);\r\n                if (iterations == 0) {\r\n                    response.getHeader().setFlag(Flags.AA);\r\n                }\r\n            } catch (TextParseException e) {\r\n                LOG.warn(\"Unable to obtain default zone for unknown name response\", e);\r\n            }\r\n        }\r\n    }\r\n    return rcode;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 3,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "addSOA",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void addSOA(Message response, Zone zone, int flags)\n{\r\n    RRset soa = zone.findExactMatch(zone.getOrigin(), Type.SOA);\r\n    addRRset(soa.getName(), response, soa, Section.AUTHORITY, flags);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "addNXT",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void addNXT(Message response, int flags) throws DNSSEC.DNSSECException, IOException\n{\r\n    Record nxtRecord = getNXTRecord(response.getSection(Section.QUESTION).get(0));\r\n    Zone zone = findBestZone(nxtRecord.getName());\r\n    addRecordCommand.exec(zone, nxtRecord);\r\n    RRset nxtRR = zone.findExactMatch(nxtRecord.getName(), Type.NXT);\r\n    addRRset(nxtRecord.getName(), response, nxtRR, Section.AUTHORITY, flags);\r\n    removeRecordCommand.exec(zone, nxtRecord);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getNXTRecord",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "Record getNXTRecord(Record query)\n{\r\n    Record response = null;\r\n    SecureableZone zone = (SecureableZone) findBestZone(query.getName());\r\n    if (zone != null) {\r\n        response = zone.getNXTRecord(query, zone);\r\n        if (response == null) {\r\n            response = zone.getSOA();\r\n        }\r\n    }\r\n    return response;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "addNS",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void addNS(Message response, Zone zone, int flags)\n{\r\n    RRset nsRecords = zone.getNS();\r\n    addRRset(nsRecords.getName(), response, nsRecords, Section.AUTHORITY, flags);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "addRRset",
  "errType" : null,
  "containingMethodsNum" : 11,
  "sourceCodeText" : "void addRRset(Name name, Message response, RRset rrset, int section, int flags)\n{\r\n    for (int s = 1; s <= section; s++) {\r\n        if (response.findRRset(name, rrset.getType(), s)) {\r\n            return;\r\n        }\r\n    }\r\n    if ((flags & FLAG_SIGONLY) == 0) {\r\n        for (Record r : rrset.rrs()) {\r\n            if (r.getName().isWild() && !name.isWild()) {\r\n                r = r.withName(name);\r\n            }\r\n            response.addRecord(r, section);\r\n        }\r\n    }\r\n    if ((flags & (FLAG_SIGONLY | FLAG_DNSSECOK)) != 0) {\r\n        for (Record r : rrset.sigs()) {\r\n            if (r.getName().isWild() && !name.isWild()) {\r\n                r = r.withName(name);\r\n            }\r\n            response.addRecord(r, section);\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "doAXFR",
  "errType" : [ "IOException", "IOException" ],
  "containingMethodsNum" : 18,
  "sourceCodeText" : "byte[] doAXFR(Name name, Message query, TSIG tsig, TSIGRecord qtsig, Socket s)\n{\r\n    boolean first = true;\r\n    Zone zone = findBestZone(name);\r\n    if (zone == null) {\r\n        return errorMessage(query, Rcode.REFUSED);\r\n    }\r\n    Iterator<RRset> it = zone.AXFR();\r\n    try {\r\n        DataOutputStream dataOut;\r\n        dataOut = new DataOutputStream(s.getOutputStream());\r\n        int id = query.getHeader().getID();\r\n        while (it.hasNext()) {\r\n            RRset rrset = it.next();\r\n            Message response = new Message(id);\r\n            Header header = response.getHeader();\r\n            header.setFlag(Flags.QR);\r\n            header.setFlag(Flags.AA);\r\n            addRRset(rrset.getName(), response, rrset, Section.ANSWER, FLAG_DNSSECOK);\r\n            if (tsig != null) {\r\n                tsig.apply(response, qtsig, first);\r\n                qtsig = response.getTSIG();\r\n            }\r\n            first = false;\r\n            byte[] out = response.toWire();\r\n            dataOut.writeShort(out.length);\r\n            dataOut.write(out);\r\n        }\r\n    } catch (IOException ex) {\r\n        System.out.println(\"AXFR failed\");\r\n    }\r\n    try {\r\n        s.close();\r\n    } catch (IOException ex) {\r\n    }\r\n    return null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 2,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "op",
  "errType" : [ "Exception" ],
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void op(String path, ServiceRecord record, RegistryCommand command) throws IOException\n{\r\n    ServiceRecordProcessor processor;\r\n    try {\r\n        String yarnPersistanceValue = record.get(YarnRegistryAttributes.YARN_PERSISTENCE);\r\n        if (yarnPersistanceValue != null) {\r\n            if (yarnPersistanceValue.equals(CONTAINER)) {\r\n                processor = new ContainerServiceRecordProcessor(record, path, domainName, this);\r\n            } else {\r\n                LOG.debug(\"Creating ApplicationServiceRecordProcessor for {}\", yarnPersistanceValue);\r\n                processor = new ApplicationServiceRecordProcessor(record, path, domainName, this);\r\n            }\r\n            processor.manageDNSRecords(command);\r\n        } else {\r\n            LOG.warn(\"Yarn Registry record {} does not contain {} attribute \", record.toString(), YarnRegistryAttributes.YARN_PERSISTENCE);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new IOException(e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getUsername",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "String getUsername(String path)\n{\r\n    String user = \"anonymous\";\r\n    Matcher matcher = USER_NAME.matcher(path);\r\n    if (matcher.find()) {\r\n        user = matcher.group(1);\r\n    }\r\n    return user;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "register",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void register(String path, ServiceRecord record) throws IOException\n{\r\n    op(path, record, addRecordCommand);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "delete",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void delete(String path, ServiceRecord record) throws IOException\n{\r\n    op(path, record, removeRecordCommand);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "serviceInit",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void serviceInit(Configuration conf) throws Exception\n{\r\n    super.serviceInit(conf);\r\n    String auth = conf.getTrimmed(KEY_REGISTRY_CLIENT_AUTH, REGISTRY_CLIENT_AUTH_ANONYMOUS);\r\n    switch(auth) {\r\n        case REGISTRY_CLIENT_AUTH_KERBEROS:\r\n            access = AccessPolicy.sasl;\r\n            break;\r\n        case REGISTRY_CLIENT_AUTH_DIGEST:\r\n            access = AccessPolicy.digest;\r\n            break;\r\n        case REGISTRY_CLIENT_AUTH_ANONYMOUS:\r\n            access = AccessPolicy.anon;\r\n            break;\r\n        case REGISTRY_CLIENT_AUTH_SIMPLE:\r\n            access = AccessPolicy.simple;\r\n            break;\r\n        default:\r\n            throw new ServiceStateException(E_UNKNOWN_AUTHENTICATION_MECHANISM + \"\\\"\" + auth + \"\\\"\");\r\n    }\r\n    initSecurity();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "initSecurity",
  "errType" : null,
  "containingMethodsNum" : 35,
  "sourceCodeText" : "void initSecurity() throws IOException\n{\r\n    secureRegistry = getConfig().getBoolean(KEY_REGISTRY_SECURE, DEFAULT_REGISTRY_SECURE);\r\n    systemACLs.clear();\r\n    if (secureRegistry) {\r\n        addSystemACL(ALL_READ_ACCESS);\r\n        kerberosRealm = getConfig().get(KEY_REGISTRY_KERBEROS_REALM, getDefaultRealmInJVM());\r\n        String system = getOrFail(KEY_REGISTRY_SYSTEM_ACCOUNTS, DEFAULT_REGISTRY_SYSTEM_ACCOUNTS);\r\n        usesRealm = system.contains(\"@\");\r\n        systemACLs.addAll(buildACLs(system, kerberosRealm, ZooDefs.Perms.ALL));\r\n        LOG.info(\"Registry default system acls: \" + System.lineSeparator() + systemACLs);\r\n        String user = getConfig().get(KEY_REGISTRY_USER_ACCOUNTS, DEFAULT_REGISTRY_USER_ACCOUNTS);\r\n        List<ACL> userACLs = buildACLs(user, kerberosRealm, ZooDefs.Perms.ALL);\r\n        ACL self;\r\n        if (UserGroupInformation.isSecurityEnabled()) {\r\n            self = createSaslACLFromCurrentUser(ZooDefs.Perms.ALL);\r\n            if (self != null) {\r\n                userACLs.add(self);\r\n            }\r\n        }\r\n        LOG.info(\"Registry User ACLs \" + System.lineSeparator() + userACLs);\r\n        switch(access) {\r\n            case sasl:\r\n                if (!UserGroupInformation.isSecurityEnabled()) {\r\n                    throw new IOException(\"Kerberos required for secure registry access\");\r\n                }\r\n                UserGroupInformation currentUser = UserGroupInformation.getCurrentUser();\r\n                jaasClientEntry = getOrFail(KEY_REGISTRY_CLIENT_JAAS_CONTEXT, DEFAULT_REGISTRY_CLIENT_JAAS_CONTEXT);\r\n                jaasClientIdentity = currentUser.getShortUserName();\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Auth is SASL user=\\\"{}\\\" JAAS context=\\\"{}\\\"\", jaasClientIdentity, jaasClientEntry);\r\n                }\r\n                break;\r\n            case digest:\r\n                String id = getOrFail(KEY_REGISTRY_CLIENT_AUTHENTICATION_ID, \"\");\r\n                String pass = getOrFail(KEY_REGISTRY_CLIENT_AUTHENTICATION_PASSWORD, \"\");\r\n                if (userACLs.isEmpty()) {\r\n                    throw new ServiceStateException(E_NO_USER_DETERMINED_FOR_ACLS);\r\n                }\r\n                digest(id, pass);\r\n                ACL acl = new ACL(ZooDefs.Perms.ALL, toDigestId(id, pass));\r\n                userACLs.add(acl);\r\n                digestAuthUser = id;\r\n                digestAuthPassword = pass;\r\n                String authPair = id + \":\" + pass;\r\n                digestAuthData = authPair.getBytes(\"UTF-8\");\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Auth is Digest ACL: {}\", aclToString(acl));\r\n                }\r\n                break;\r\n            case anon:\r\n            case simple:\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Auth is anonymous\");\r\n                }\r\n                userACLs = new ArrayList<ACL>(0);\r\n                break;\r\n        }\r\n        systemACLs.addAll(userACLs);\r\n    } else {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Registry has no security\");\r\n        }\r\n        systemACLs.addAll(WorldReadWriteACL);\r\n    }\r\n}\n",
  "settingFlag" : true,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "addSystemACL",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void addSystemACL(ACL acl)\n{\r\n    systemACLs.add(acl);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "addDigestACL",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "boolean addDigestACL(ACL acl)\n{\r\n    if (secureRegistry) {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Added ACL {}\", aclToString(acl));\r\n        }\r\n        digestACLs.add(acl);\r\n        return true;\r\n    } else {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Ignoring added ACL - registry is insecure{}\", aclToString(acl));\r\n        }\r\n        return false;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "resetDigestACLs",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void resetDigestACLs()\n{\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"Cleared digest ACLs\");\r\n    }\r\n    digestACLs.clear();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "isSecureRegistry",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "boolean isSecureRegistry()\n{\r\n    return secureRegistry;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "getSystemACLs",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "List<ACL> getSystemACLs()\n{\r\n    Preconditions.checkNotNull(systemACLs, \"registry security is uninitialized\");\r\n    return Collections.unmodifiableList(systemACLs);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "getClientACLs",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "List<ACL> getClientACLs()\n{\r\n    List<ACL> clientACLs = new ArrayList<ACL>(systemACLs);\r\n    clientACLs.addAll(digestACLs);\r\n    return clientACLs;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "createSaslACLFromCurrentUser",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "ACL createSaslACLFromCurrentUser(int perms) throws IOException\n{\r\n    UserGroupInformation currentUser = UserGroupInformation.getCurrentUser();\r\n    if (currentUser.hasKerberosCredentials()) {\r\n        return createSaslACL(currentUser, perms);\r\n    } else {\r\n        return null;\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "createSaslACL",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "ACL createSaslACL(UserGroupInformation ugi, int perms)\n{\r\n    String userName = null;\r\n    if (usesRealm) {\r\n        userName = ugi.getUserName();\r\n    } else {\r\n        userName = ugi.getShortUserName();\r\n    }\r\n    return new ACL(perms, new Id(SCHEME_SASL, userName));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "getOrFail",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "String getOrFail(String key, String defval) throws IOException\n{\r\n    String val = getConfig().get(key, defval);\r\n    if (StringUtils.isEmpty(val)) {\r\n        throw new IOException(\"Missing value for configuration option \" + key);\r\n    }\r\n    return val;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "isValid",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "boolean isValid(String idPasswordPair)\n{\r\n    String[] parts = idPasswordPair.split(\":\");\r\n    return parts.length == 2 && !StringUtils.isEmpty(parts[0]) && !StringUtils.isEmpty(parts[1]);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "getKerberosRealm",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "String getKerberosRealm()\n{\r\n    return kerberosRealm;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "digest",
  "errType" : [ "NoSuchAlgorithmException" ],
  "containingMethodsNum" : 4,
  "sourceCodeText" : "String digest(String idPasswordPair) throws IOException\n{\r\n    if (StringUtils.isEmpty(idPasswordPair) || !isValid(idPasswordPair)) {\r\n        throw new IOException(\"Invalid id:password\");\r\n    }\r\n    try {\r\n        return DigestAuthenticationProvider.generateDigest(idPasswordPair);\r\n    } catch (NoSuchAlgorithmException e) {\r\n        throw new IOException(e.toString(), e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "digest",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String digest(String id, String password) throws IOException\n{\r\n    return digest(id + \":\" + password);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "toDigestId",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "Id toDigestId(String digest)\n{\r\n    return new Id(SCHEME_DIGEST, digest);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "toDigestId",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Id toDigestId(String id, String password) throws IOException\n{\r\n    return toDigestId(digest(id, password));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "splitAclPairs",
  "errType" : null,
  "containingMethodsNum" : 7,
  "sourceCodeText" : "List<String> splitAclPairs(String aclString, String realm)\n{\r\n    List<String> list = Lists.newArrayList(Splitter.on(',').omitEmptyStrings().trimResults().split(aclString));\r\n    ListIterator<String> listIterator = list.listIterator();\r\n    while (listIterator.hasNext()) {\r\n        String next = listIterator.next();\r\n        if (next.startsWith(SCHEME_SASL + \":\") && next.endsWith(\"@\")) {\r\n            listIterator.set(next + realm);\r\n        }\r\n    }\r\n    return list;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "parse",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "Id parse(String idPair, String realm)\n{\r\n    int firstColon = idPair.indexOf(':');\r\n    int lastColon = idPair.lastIndexOf(':');\r\n    if (firstColon == -1 || lastColon == -1 || firstColon != lastColon) {\r\n        throw new IllegalArgumentException(\"ACL '\" + idPair + \"' not of expected form scheme:id\");\r\n    }\r\n    String scheme = idPair.substring(0, firstColon);\r\n    String id = idPair.substring(firstColon + 1);\r\n    if (id.endsWith(\"@\")) {\r\n        Preconditions.checkArgument(StringUtils.isNotEmpty(realm), \"@ suffixed account but no realm %s\", id);\r\n        id = id + realm;\r\n    }\r\n    return new Id(scheme, id);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "buildACLs",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "List<ACL> buildACLs(String principalList, String realm, int perms) throws IOException\n{\r\n    List<String> aclPairs = splitAclPairs(principalList, realm);\r\n    List<ACL> ids = new ArrayList<ACL>(aclPairs.size());\r\n    for (String aclPair : aclPairs) {\r\n        ACL newAcl = new ACL();\r\n        newAcl.setId(parse(aclPair, realm));\r\n        newAcl.setPerms(perms);\r\n        ids.add(newAcl);\r\n    }\r\n    return ids;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "parseACLs",
  "errType" : [ "ZKUtil.BadAclFormatException" ],
  "containingMethodsNum" : 1,
  "sourceCodeText" : "List<ACL> parseACLs(String zkAclConf) throws IOException\n{\r\n    try {\r\n        return ZKUtil.parseACLs(ZKUtil.resolveConfIndirection(zkAclConf));\r\n    } catch (ZKUtil.BadAclFormatException e) {\r\n        throw new IOException(\"Parsing \" + zkAclConf + \" :\" + e, e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "getKerberosAuthModuleForJVM",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String getKerberosAuthModuleForJVM()\n{\r\n    if (System.getProperty(\"java.vendor\").contains(\"IBM\")) {\r\n        return \"com.ibm.security.auth.module.Krb5LoginModule\";\r\n    } else {\r\n        return \"com.sun.security.auth.module.Krb5LoginModule\";\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "createJAASEntry",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "String createJAASEntry(String context, String principal, File keytab)\n{\r\n    Preconditions.checkArgument(StringUtils.isNotEmpty(principal), \"invalid principal\");\r\n    Preconditions.checkArgument(StringUtils.isNotEmpty(context), \"invalid context\");\r\n    Preconditions.checkArgument(keytab != null && keytab.isFile(), \"Keytab null or missing: \");\r\n    String keytabpath = keytab.getAbsolutePath();\r\n    keytabpath = keytabpath.replace('\\\\', '/');\r\n    return String.format(Locale.ENGLISH, JAAS_ENTRY, context, getKerberosAuthModuleForJVM(), keytabpath, principal);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "bindJVMtoJAASFile",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void bindJVMtoJAASFile(File jaasFile)\n{\r\n    String path = jaasFile.getAbsolutePath();\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"Binding {} to {}\", Environment.JAAS_CONF_KEY, path);\r\n    }\r\n    System.setProperty(Environment.JAAS_CONF_KEY, path);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "bindZKToServerJAASContext",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void bindZKToServerJAASContext(String contextName)\n{\r\n    System.setProperty(PROP_ZK_SERVER_SASL_CONTEXT, contextName);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "clearJaasSystemProperties",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void clearJaasSystemProperties()\n{\r\n    System.clearProperty(Environment.JAAS_CONF_KEY);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "validateContext",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "AppConfigurationEntry[] validateContext(String context)\n{\r\n    if (context == null) {\r\n        throw new RuntimeException(\"Null context argument\");\r\n    }\r\n    if (context.isEmpty()) {\r\n        throw new RuntimeException(\"Empty context argument\");\r\n    }\r\n    javax.security.auth.login.Configuration configuration = javax.security.auth.login.Configuration.getConfiguration();\r\n    AppConfigurationEntry[] entries = configuration.getAppConfigurationEntry(context);\r\n    if (entries == null) {\r\n        throw new RuntimeException(String.format(\"Entry \\\"%s\\\" not found; \" + \"JAAS config = %s\", context, describeProperty(Environment.JAAS_CONF_KEY)));\r\n    }\r\n    return entries;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "applySecurityEnvironment",
  "errType" : null,
  "containingMethodsNum" : 12,
  "sourceCodeText" : "void applySecurityEnvironment(CuratorFrameworkFactory.Builder builder) throws IOException\n{\r\n    if (isSecureRegistry()) {\r\n        switch(access) {\r\n            case anon:\r\n                clearZKSaslClientProperties();\r\n                break;\r\n            case digest:\r\n                clearZKSaslClientProperties();\r\n                builder.authorization(SCHEME_DIGEST, digestAuthData);\r\n                break;\r\n            case sasl:\r\n                String existingJaasConf = System.getProperty(\"java.security.auth.login.config\");\r\n                if (existingJaasConf == null || existingJaasConf.isEmpty()) {\r\n                    if (principal == null || keytab == null) {\r\n                        throw new IOException(\"SASL is configured for registry, \" + \"but neither keytab/principal nor java.security.auth.login\" + \".config system property are specified\");\r\n                    }\r\n                    LOG.info(\"Enabling ZK sasl client: jaasClientEntry = \" + jaasClientEntry + \", principal = \" + principal + \", keytab = \" + keytab);\r\n                    JaasConfiguration jconf = new JaasConfiguration(jaasClientEntry, principal, keytab);\r\n                    javax.security.auth.login.Configuration.setConfiguration(jconf);\r\n                    setSystemPropertyIfUnset(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, \"true\");\r\n                    setSystemPropertyIfUnset(ZKClientConfig.LOGIN_CONTEXT_NAME_KEY, jaasClientEntry);\r\n                } else {\r\n                    LOG.info(\"Using existing ZK sasl configuration: \" + \"jaasClientEntry = \" + System.getProperty(ZKClientConfig.LOGIN_CONTEXT_NAME_KEY, \"Client\") + \", sasl client = \" + System.getProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, ZKClientConfig.ENABLE_CLIENT_SASL_DEFAULT) + \", jaas = \" + existingJaasConf);\r\n                }\r\n                break;\r\n            default:\r\n                clearZKSaslClientProperties();\r\n                break;\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "setKerberosPrincipalAndKeytab",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void setKerberosPrincipalAndKeytab(String principal, String keytab)\n{\r\n    this.principal = principal;\r\n    this.keytab = keytab;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "setZKSaslClientProperties",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "void setZKSaslClientProperties(String username, String context)\n{\r\n    RegistrySecurity.validateContext(context);\r\n    enableZookeeperClientSASL();\r\n    setSystemPropertyIfUnset(PROP_ZK_SASL_CLIENT_USERNAME, username);\r\n    setSystemPropertyIfUnset(PROP_ZK_SASL_CLIENT_CONTEXT, context);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "setSystemPropertyIfUnset",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void setSystemPropertyIfUnset(String name, String value)\n{\r\n    String existingValue = System.getProperty(name);\r\n    if (existingValue == null || existingValue.isEmpty()) {\r\n        System.setProperty(name, value);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "clearZKSaslClientProperties",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "void clearZKSaslClientProperties()\n{\r\n    disableZookeeperClientSASL();\r\n    System.clearProperty(PROP_ZK_SASL_CLIENT_CONTEXT);\r\n    System.clearProperty(PROP_ZK_SASL_CLIENT_USERNAME);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "enableZookeeperClientSASL",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void enableZookeeperClientSASL()\n{\r\n    System.setProperty(PROP_ZK_ENABLE_SASL_CLIENT, \"true\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "disableZookeeperClientSASL",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void disableZookeeperClientSASL()\n{\r\n    System.setProperty(ZookeeperConfigOptions.PROP_ZK_ENABLE_SASL_CLIENT, \"false\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "isClientSASLEnabled",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean isClientSASLEnabled()\n{\r\n    return Boolean.parseBoolean(System.getProperty(ZookeeperConfigOptions.PROP_ZK_ENABLE_SASL_CLIENT, \"true\"));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "logCurrentHadoopUser",
  "errType" : [ "IOException" ],
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void logCurrentHadoopUser()\n{\r\n    try {\r\n        UserGroupInformation currentUser = UserGroupInformation.getCurrentUser();\r\n        LOG.info(\"Current user = {}\", currentUser);\r\n        UserGroupInformation realUser = currentUser.getRealUser();\r\n        LOG.info(\"Real User = {}\", realUser);\r\n    } catch (IOException e) {\r\n        LOG.warn(\"Failed to get current user, {}\", e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "aclsToString",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "String aclsToString(List<ACL> acls)\n{\r\n    StringBuilder builder = new StringBuilder();\r\n    if (acls == null) {\r\n        builder.append(\"null ACL\");\r\n    } else {\r\n        builder.append('\\n');\r\n        for (ACL acl : acls) {\r\n            builder.append(aclToString(acl)).append(\" \");\r\n        }\r\n    }\r\n    return builder.toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "aclToString",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String aclToString(ACL acl)\n{\r\n    return String.format(Locale.ENGLISH, \"0x%02x: %s\", acl.getPerms(), idToString(acl.getId()));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "idToString",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "String idToString(Id id)\n{\r\n    String s;\r\n    if (id.getScheme().equals(SCHEME_DIGEST)) {\r\n        String ids = id.getId();\r\n        int colon = ids.indexOf(':');\r\n        if (colon > 0) {\r\n            ids = ids.substring(colon + 3);\r\n        }\r\n        s = SCHEME_DIGEST + \": \" + ids;\r\n    } else {\r\n        s = id.toString();\r\n    }\r\n    return s;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "buildSecurityDiagnostics",
  "errType" : null,
  "containingMethodsNum" : 16,
  "sourceCodeText" : "String buildSecurityDiagnostics()\n{\r\n    StringBuilder builder = new StringBuilder();\r\n    builder.append(secureRegistry ? \"secure registry; \" : \"insecure registry; \");\r\n    builder.append(\"Curator service access policy: \").append(access);\r\n    builder.append(\"; System ACLs: \").append(aclsToString(systemACLs));\r\n    builder.append(\"User: \").append(UgiInfo.fromCurrentUser());\r\n    builder.append(\"; Kerberos Realm: \").append(kerberosRealm);\r\n    builder.append(describeProperty(Environment.JAAS_CONF_KEY));\r\n    String sasl = System.getProperty(PROP_ZK_ENABLE_SASL_CLIENT, DEFAULT_ZK_ENABLE_SASL_CLIENT);\r\n    boolean saslEnabled = Boolean.parseBoolean(sasl);\r\n    builder.append(describeProperty(PROP_ZK_ENABLE_SASL_CLIENT, DEFAULT_ZK_ENABLE_SASL_CLIENT));\r\n    if (saslEnabled) {\r\n        builder.append(\"; JAAS Client Identity\").append(\"=\").append(jaasClientIdentity).append(\"; \");\r\n        builder.append(KEY_REGISTRY_CLIENT_JAAS_CONTEXT).append(\"=\").append(jaasClientEntry).append(\"; \");\r\n        builder.append(describeProperty(PROP_ZK_SASL_CLIENT_USERNAME));\r\n        builder.append(describeProperty(PROP_ZK_SASL_CLIENT_CONTEXT));\r\n    }\r\n    builder.append(describeProperty(PROP_ZK_ALLOW_FAILED_SASL_CLIENTS, \"(undefined but defaults to true)\"));\r\n    builder.append(describeProperty(PROP_ZK_SERVER_MAINTAIN_CONNECTION_DESPITE_SASL_FAILURE));\r\n    return builder.toString();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "describeProperty",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String describeProperty(String name)\n{\r\n    return describeProperty(name, \"(undefined)\");\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "describeProperty",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String describeProperty(String name, String def)\n{\r\n    return \"; \" + name + \"=\" + System.getProperty(name, def);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "getDefaultRealmInJVM",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String getDefaultRealmInJVM()\n{\r\n    String realm = KerberosUtil.getDefaultRealmProtected();\r\n    if (realm == null) {\r\n        realm = \"\";\r\n    }\r\n    return realm;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "createACLForUser",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "ACL createACLForUser(UserGroupInformation ugi, int perms)\n{\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"Creating ACL For \", new UgiInfo(ugi));\r\n    }\r\n    if (!secureRegistry) {\r\n        return ALL_READWRITE_ACCESS;\r\n    } else {\r\n        return createACLfromUsername(ugi.getUserName(), perms);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\client\\impl\\zk",
  "methodName" : "createACLfromUsername",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "ACL createACLfromUsername(String username, int perms)\n{\r\n    if (usesRealm && !username.contains(\"@\")) {\r\n        username = username + \"@\" + kerberosRealm;\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Appending kerberos realm to make {}\", username);\r\n        }\r\n    }\r\n    return new ACL(perms, new Id(SCHEME_SASL, username));\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "addService",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void addService(Service service)\n{\r\n    super.addService(service);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "removeService",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "boolean removeService(Service service)\n{\r\n    return super.removeService(service);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "call",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Record[] call() throws Exception\n{\r\n    return new Lookup(name, type).run();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "getRecordCreator",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "RecordCreator getRecordCreator(int type)\n{\r\n    switch(type) {\r\n        case A:\r\n            return new ARecordCreator();\r\n        case CNAME:\r\n            return new CNAMERecordCreator();\r\n        case TXT:\r\n            return new TXTRecordCreator();\r\n        case AAAA:\r\n            return new AAAARecordCreator();\r\n        case PTR:\r\n            return new PTRRecordCreator();\r\n        case SRV:\r\n            return new SRVRecordCreator();\r\n        default:\r\n            throw new IllegalArgumentException(\"No type \" + type);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\dns",
  "methodName" : "setTtl",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "void setTtl(long ttl)\n{\r\n    RecordCreatorFactory.ttl = ttl;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "serviceStop",
  "errType" : null,
  "containingMethodsNum" : 2,
  "sourceCodeText" : "void serviceStop() throws Exception\n{\r\n    stopExecutor();\r\n    super.serviceStop();\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "stopExecutor",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "void stopExecutor()\n{\r\n    if (executor != null) {\r\n        executor.shutdownNow();\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "getExecutor",
  "errType" : null,
  "containingMethodsNum" : 0,
  "sourceCodeText" : "ExecutorService getExecutor()\n{\r\n    return executor;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "submit",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "Future<V> submit(Callable<V> callable)\n{\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"Submitting {}\", callable);\r\n    }\r\n    return getExecutor().submit(callable);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "createDirAsync",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "Future<Boolean> createDirAsync(final String path, final List<ACL> acls, final boolean createParents) throws IOException\n{\r\n    return submit(new Callable<Boolean>() {\r\n\r\n        @Override\r\n        public Boolean call() throws Exception {\r\n            return maybeCreate(path, CreateMode.PERSISTENT, acls, createParents);\r\n        }\r\n    });\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "serviceInit",
  "errType" : null,
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void serviceInit(Configuration conf) throws Exception\n{\r\n    super.serviceInit(conf);\r\n    RegistrySecurity registrySecurity = getRegistrySecurity();\r\n    if (registrySecurity.isSecureRegistry()) {\r\n        ACL sasl = registrySecurity.createSaslACLFromCurrentUser(ZooDefs.Perms.ALL);\r\n        registrySecurity.addSystemACL(sasl);\r\n        LOG.info(\"Registry System ACLs:\", RegistrySecurity.aclsToString(registrySecurity.getSystemACLs()));\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "serviceStart",
  "errType" : [ "NoPathPermissionsException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "void serviceStart() throws Exception\n{\r\n    super.serviceStart();\r\n    try {\r\n        createRootRegistryPaths();\r\n    } catch (NoPathPermissionsException e) {\r\n        String message = String.format(Locale.ENGLISH, \"Failed to create root paths {%s};\" + \"%ndiagnostics={%s}\" + \"%ncurrent registry is:\" + \"%n{%s}\", e, bindingDiagnosticDetails(), dumpRegistryRobustly(true));\r\n        LOG.error(\" Failure {}\", e, e);\r\n        LOG.error(message);\r\n        throw new NoPathPermissionsException(e.getPath().toString(), message, e);\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "createRootRegistryPaths",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void createRootRegistryPaths() throws IOException\n{\r\n    List<ACL> systemACLs = getRegistrySecurity().getSystemACLs();\r\n    LOG.info(\"System ACLs {}\", RegistrySecurity.aclsToString(systemACLs));\r\n    maybeCreate(\"\", CreateMode.PERSISTENT, systemACLs, false);\r\n    maybeCreate(PATH_USERS, CreateMode.PERSISTENT, systemACLs, false);\r\n    maybeCreate(PATH_SYSTEM_SERVICES, CreateMode.PERSISTENT, systemACLs, false);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "homeDir",
  "errType" : null,
  "containingMethodsNum" : 1,
  "sourceCodeText" : "String homeDir(String username)\n{\r\n    return RegistryUtils.homePathForUser(username);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : false,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "aclsForUser",
  "errType" : null,
  "containingMethodsNum" : 4,
  "sourceCodeText" : "List<ACL> aclsForUser(String username, int perms) throws IOException\n{\r\n    List<ACL> clientACLs = getClientAcls();\r\n    RegistrySecurity security = getRegistrySecurity();\r\n    if (security.isSecureRegistry()) {\r\n        clientACLs.add(security.createACLfromUsername(username, perms));\r\n    }\r\n    return clientACLs;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "initUserRegistryAsync",
  "errType" : null,
  "containingMethodsNum" : 3,
  "sourceCodeText" : "Future<Boolean> initUserRegistryAsync(final String shortname) throws IOException\n{\r\n    String homeDir = homeDir(shortname);\r\n    if (!exists(homeDir)) {\r\n        return createDirAsync(homeDir, aclsForUser(shortname, USER_HOMEDIR_ACL_PERMISSIONS), false);\r\n    }\r\n    return null;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : true,
  "tryCatchBlockNum" : 0,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "initUserRegistry",
  "errType" : [ "InterruptedException", "ExecutionException" ],
  "containingMethodsNum" : 6,
  "sourceCodeText" : "String initUserRegistry(final String username) throws IOException\n{\r\n    try {\r\n        Future<Boolean> future = initUserRegistryAsync(username);\r\n        future.get();\r\n    } catch (InterruptedException e) {\r\n        throw (InterruptedIOException) (new InterruptedIOException(e.toString()).initCause(e));\r\n    } catch (ExecutionException e) {\r\n        Throwable cause = e.getCause();\r\n        if (cause instanceof IOException) {\r\n            throw (IOException) (cause);\r\n        } else {\r\n            throw new IOException(cause.toString(), cause);\r\n        }\r\n    }\r\n    return homeDir(username);\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 1,
  "logged" : false
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "verifyRealmValidity",
  "errType" : null,
  "containingMethodsNum" : 5,
  "sourceCodeText" : "void verifyRealmValidity() throws ServiceStateException\n{\r\n    if (isSecure()) {\r\n        String realm = getRegistrySecurity().getKerberosRealm();\r\n        if (StringUtils.isEmpty(realm)) {\r\n            throw new ServiceStateException(\"Cannot determine service realm\");\r\n        }\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Started Registry operations in realm {}\", realm);\r\n        }\r\n    }\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 0,
  "logged" : true
}, {
  "directory" : "E:\\MyPaper\\hadoop\\hadoop-common-project\\hadoop-registry\\src\\main\\java\\org\\apache\\hadoop\\registry\\server\\services",
  "methodName" : "purge",
  "errType" : [ "PathNotFoundException", "EOFException", "InvalidRecordException", "NoRecordException", "PathNotFoundException", "PathNotFoundException" ],
  "containingMethodsNum" : 17,
  "sourceCodeText" : "int purge(String path, NodeSelector selector, PurgePolicy purgePolicy, BackgroundCallback callback) throws IOException\n{\r\n    boolean toDelete = false;\r\n    Map<String, RegistryPathStatus> childEntries;\r\n    Collection<RegistryPathStatus> entries;\r\n    try {\r\n        childEntries = RegistryUtils.statChildren(this, path);\r\n        entries = childEntries.values();\r\n    } catch (PathNotFoundException e) {\r\n        return 0;\r\n    }\r\n    try {\r\n        RegistryPathStatus registryPathStatus = stat(path);\r\n        ServiceRecord serviceRecord = resolve(path);\r\n        toDelete = selector.shouldSelect(path, registryPathStatus, serviceRecord);\r\n    } catch (EOFException ignored) {\r\n    } catch (InvalidRecordException ignored) {\r\n    } catch (NoRecordException ignored) {\r\n    } catch (PathNotFoundException e) {\r\n        return 0;\r\n    }\r\n    if (toDelete && !entries.isEmpty()) {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Match on record @ {} with children \", path);\r\n        }\r\n        switch(purgePolicy) {\r\n            case SkipOnChildren:\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Skipping deletion\");\r\n                }\r\n                toDelete = false;\r\n                break;\r\n            case PurgeAll:\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Scheduling for deletion with children\");\r\n                }\r\n                toDelete = true;\r\n                entries = new ArrayList<RegistryPathStatus>(0);\r\n                break;\r\n            case FailOnChildren:\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Failing deletion operation\");\r\n                }\r\n                throw new PathIsNotEmptyDirectoryException(path);\r\n        }\r\n    }\r\n    int deleteOps = 0;\r\n    if (toDelete) {\r\n        try {\r\n            zkDelete(path, true, callback);\r\n        } catch (PathNotFoundException e) {\r\n            return deleteOps;\r\n        }\r\n        deleteOps++;\r\n    }\r\n    for (RegistryPathStatus status : entries) {\r\n        String childname = status.path;\r\n        String childpath = RegistryPathUtils.join(path, childname);\r\n        deleteOps += purge(childpath, selector, purgePolicy, callback);\r\n    }\r\n    return deleteOps;\r\n}\n",
  "settingFlag" : false,
  "hasThrow" : true,
  "returnSpecialValue" : false,
  "tryCatchBlockNum" : 3,
  "logged" : true
} ]